<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>内存管理及4种常见的内存泄漏处理 - chkaos - Find the calm in chaos</title><meta description="How JavaScript works 系列第三章"><meta property="og:type" content="blog"><meta property="og:title" content="内存管理及4种常见的内存泄漏处理"><meta property="og:url" content="https://chkaos.top/posts/5ba3987d.html"><meta property="og:site_name" content="chkaos - Find the calm in chaos"><meta property="og:description" content="How JavaScript works 系列第三章"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_memory_life_cycle.png"><meta property="article:published_time" content="2021-03-01T09:21:41.000Z"><meta property="article:modified_time" content="2021-03-01T09:21:41.000Z"><meta property="article:author" content="Chkaos"><meta property="article:tag" content="内存管理"><meta property="article:tag" content=" 内存泄漏"><meta property="article:tag" content=" How JavaScript works"><meta property="article:tag" content=" Javascript"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_memory_life_cycle.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://chkaos.top/posts/5ba3987d.html"},"headline":"chkaos - Find the calm in chaos","image":["https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_memory_life_cycle.png"],"datePublished":"2021-03-01T09:21:41.000Z","dateModified":"2021-03-01T09:21:41.000Z","author":{"@type":"Person","name":"Chkaos"},"description":"How JavaScript works 系列第三章"}</script><link rel="canonical" href="https://chkaos.top/posts/5ba3987d.html"><link id="favicon" rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?515142e072dc41d1d43a08637d816183";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><link rel="alternate" href="/atom.xml" title="chkaos - Find the calm in chaos" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main" id="navbar"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-logo" href="/"><img class="no-lazy" src="/img/logo.png" alt="Find the calm in chaos" height="32"></a><div class="navbar-item navbar-text">Chkaos</div><div class="navbar-item">Find the calm in chaos</div></div><div class="navbar-menu"><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="btn-toggle-dark" title="夜间模式" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile">内存管理及4种常见的内存泄漏处理</h1><div class="article-type translation"><span>翻译</span></div><div class="content"><blockquote>
<p>How JavaScript works: memory management + how to handle 4 common memory leaks</p>
<p>原文请查阅<a href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec">这里</a></p>
</blockquote>
<p>本章中, 我们将讨论日常使用中另一个被开发者越来越忽略的重要话题，这都是日益成熟和复杂的编程语言的锅，即内存管理。我们将会提供 <a href="https://www.sessionstack.com/?utm_source=medium&utm_medium=blog&utm_content=Post-3-v8-intro">SessionStack</a> 开发时所遵循的处理 JavaScript 内存泄漏的几条小技巧，因为我们需要保证 SessionStack 不会引起内存泄漏或者不会增加我们所集成的 web 应用程序的内存消耗。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一些语言, 比如 C 语言拥有底层的内存管理原语如 <code>malloc()</code> 和 <code>free()</code>。开发者使用这些原语在操作系统显式地分配和释放内存。</p>
<p>与此同时，当创建事物(对象，字符串等)的时，JavaScript 自动分配内存且当它们不再被使用时 “自动释放” 内存，这一过程称为内存垃圾回收。这个乍看起来本质上是 “自动化释放内存” 的释放资源是引起混乱的原因，并且给予 JavaScript(及其它高级语言)开发者一个错误的印象即他们可以选择忽略内存管理。<strong>这是一个巨大的错误</strong>。</p>
<p>即使是当使用高级语言的时候，开发者也应该要理解内存管理(或者至少是一些基础)。有时候自动化内存管理会存在一些问题(比如垃圾回收中的 bugs 或者实施的局限性等等)，为了能够合理地处理内存泄漏问题(或者以最小代价和代码缺陷来寻找一个合适的方案)，开发者就必须理解内存管理。</p>
<h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>不管你使用哪种编程语言，内存生命周期几乎是一样的：</p>
<p><img src="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_memory_life_cycle.png" class="lazyload" data-srcset="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_memory_life_cycle.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt=""></p>
<p>以下是生命周期概述：</p>
<ul>
<li>分配内存－内存由操作系统分配后允许你的程序使用它。在底层语言(例如 C 语言)，开发者可以显式地操作内存。而高级语言，其本身会帮你处理。</li>
<li>使用内存－这是程序实际使用之前分配的内存的阶段。当你在代码中使用已分配的变量时，就会发生内存读写的操作。</li>
<li>释放内存－该阶段你可以释放你不再使用的整块内存，该内存就可以被释放并重新使用。和内存分配操作一样，该操作也是用底层语言显式编写的。</li>
</ul>
<p>为快速浏览调用堆栈和动态内存管理的概念，你可以阅读第一篇<a href="1.overview.md">文章</a>。</p>
<h2 id="内存是什么？"><a href="#内存是什么？" class="headerlink" title="内存是什么？"></a>内存是什么？</h2><p>在直接跳向 JavaScript 内存之前，先来简要地介绍一下内存及其工作原理。</p>
<p>从硬件层面看，计算机内存是由大量的 <a href="https://en.wikipedia.org/wiki/Flip-flop_%28electronics%29">flip flops</a> 所组成的(这里大概查了下，即大量的二进制电路所组成的)。每个触发器(flip flop)包含少量晶体管并能够存储一个比特位。单个的触发器可以通过一个唯一标识符寻址，所以就可以读和覆写它们。因此，理论上，我们可以把整个计算机内存看成是由一个巨大的比特位数组所组成的，这样就可以进行读和写。</p>
<p>作为人类，我们并不擅长用位来进行所有的逻辑思考和计算，所以我们把位组织成一个更大的组，这样就可以用来表示数字。8 位称为一字节。除了字节还有字(16 或 32 位)。</p>
<p>内存中存储着很多东西：</p>
<ul>
<li>所有变量及所有程序使用的其它数据。</li>
<li>程序代码，包括操作系统的代码。</li>
</ul>
<p>编译器和操作系统一起协作为你进行内存管理，但我们建议你了解一下底层是如何实现的。</p>
<p>编译代码时，编译器会检查原始数据类型并提前计算出程序运行所需要的内存大小。在静态堆栈空间中，所需的内存大小会被分配给程序。这些变量所分配到的内存所在的空间之所以被称为静态内存空间是因为当调用函数的时候，函数所需的内存会被添加到现存内存的顶部。当函数中断，它们被以 LIFO(后进先出) 的顺序移出内存。比如，考虑如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n; &#x2F;&#x2F; 4 字节</span><br><span class="line">int x[4]; &#x2F;&#x2F; 4 个元素的数组，每个数组元素 4 个字节</span><br><span class="line">double m; &#x2F;&#x2F; 8 字节</span><br></pre></td></tr></table></figure>

<p>编译器会立即计算出代码所需的内存：4 + 4 x 4 + 8 = 28 字节。</p>
<blockquote>
<p>编译器是这样处理当前整数和浮点数的大小的。大约 20 年前，整数一般是 2 字节而 浮点数是 4 字节。代码不用依赖于当前基础数据类型的字节大小。</p>
</blockquote>
<p>编译器会插入标记，标记会和操作系统协商从堆栈中获取所需要的内存大小，以便在堆栈中存储变量。</p>
<p>在以上示例中，编译知道每个变量的准确内存地址。事实上，当你编写变量 <code>n</code> 的时候，会在内部把它转换为类似 “内存地址 412763” 的样子。</p>
<p>注意到这里当我们试图访问 <code>x[4]</code> 时候，将会访问到 m 相关的数据。这是因为我们访问了数组中不存在的数组元素－它超过了最后一个实际分配到内存的数组元素 <code>x[3]</code> 4 字节，并且有可能会读取(或者覆写) <code>m</code> 的位。这几乎可以确定会产生程序所预料不到的后果。</p>
<p><img src="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_memory_address.png" class="lazyload" data-srcset="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_memory_address.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt=""></p>
<p>当函数调用其它函数的时候，各个函数都会在被调用的时候取得其在堆栈中的各自分片内存地址。函数会把保存它所有的本地变量，但也会有一个程序计数器用来记住函数在其执行环境中的地址。当函数运行结束时，其内存块可以再次被用作其它用途。</p>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>不幸的是，想要知道编译时一个变量需要多少内存并没有想象中那般容易。设想一下若要做类似如下事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n &#x3D; readInput(); &#x2F;&#x2F; 从用户读取信息</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; 创建一个含有 n 个元素的数组</span><br></pre></td></tr></table></figure>

<p>这种情况下，编译器并不知道编译时数组需要多少内存，因为这是由用户输入的数组元素的值所决定的。</p>
<p>因此，就不能够在栈中为变量分配内存空间。相反，程序需要在运行时显式地从操作系统分配到正确的内存空间。这里的内存是由堆空间所分配。静态和动态内存分配的差异总结如下图表：</p>
<p><img src="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_difference.png" class="lazyload" data-srcset="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_difference.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="*静态和动态分配内存的区别*"></p>
<p>为了完全理解动态内存分配的工作原理，我们需要花点时间了解<strong>指针</strong>，这个就可能有点跑题了 ^.^。如果你对指针感兴趣，请留言，然后我们将会在以后的章节中讨论更多关于指针的内容。</p>
<h2 id="JavaScript-中的内存分配"><a href="#JavaScript-中的内存分配" class="headerlink" title="JavaScript 中的内存分配"></a>JavaScript 中的内存分配</h2><p>现在，我们将会介绍在 JavaScript 中是如何分配内存的((第一步)。</p>
<p>JavaScript 通过声明变量值，自己处理内存分配工作而不需要开发者干涉。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">374</span>; <span class="comment">// 为数字分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'sessionstack'</span>; <span class="comment">// 为字符串分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// 为对象及其值分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">'str'</span>]; <span class="comment">// (类似对象)为数组及其数组元素值分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">3</span>;</span><br><span class="line">&#125; <span class="comment">// 分配一个函数(一个可调用对象)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也分配一个对象</span></span><br><span class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>一些函数调用也会分配一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 分配一个日期对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); <span class="comment">// 分配一个 DOM 元素</span></span><br></pre></td></tr></table></figure>

<p>可以分配值或对象的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'sessionstack'</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substr(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 为一个新字符串</span></span><br><span class="line"><span class="comment">// 因为字符串是不可变的，所以 JavaScript 可能会选择不分配内存而只是存储数组 [0, 3] 的内存地址范围。</span></span><br><span class="line"><span class="keyword">var</span> a1 = [<span class="string">'str1'</span>, <span class="string">'str2'</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = [<span class="string">'str3'</span>, <span class="string">'str4'</span>];</span><br><span class="line"><span class="keyword">var</span> a3 = a1.concat(a2);</span><br><span class="line"><span class="comment">// 包含 4 个元素的新数组由 a1 和 a2 数组元素所组成</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-中的内存使用"><a href="#JavaScript-中的内存使用" class="headerlink" title="JavaScript 中的内存使用"></a>JavaScript 中的内存使用</h2><p>JavaScript 中使用分配的内存主要指的是内存读写。</p>
<p>可以通过为变量或者对象属性赋值，亦或是为函数传参来使用内存。</p>
<h2 id="释放空闲内存"><a href="#释放空闲内存" class="headerlink" title="释放空闲内存"></a>释放空闲内存</h2><p>大多数的内存管理问题是出现在这一阶段。</p>
<p>痛点在于检测出何时分配的内存是闲置的。它经常会要求开发者来决定程序中的这段内存是否已经不再使用，然后释放它。</p>
<p>高级程序语言集成垃圾回收器的软件，它的工作就是追踪内存分配和使用情况以便找出并自动释放闲置的分配内存片段。</p>
<p>不幸的是，这是个近似的过程，因为判定一些内存片段是否闲置的普遍问题在于其不可判定性(不能为算法所解决)。</p>
<p>大多数的垃圾回收器会收集那些不再被访问的内存，比如引用该内存的所有变量超出了内存寻址范围。然而还是会有低于近似值的内存空间被收集，因为在任何情况下仍然可能会有变量在内存寻址范围内引用该内存地址，即使该内存是闲置的。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>由于找出 “不再使用” 的内存的不可判定性，针对这一普遍问题，垃圾回收实现了一个有限的解决方案。本小节将会阐述必要的观点来理解主要的内存垃圾回收算法及其局限性。</p>
<h2 id="内存引用"><a href="#内存引用" class="headerlink" title="内存引用"></a>内存引用</h2><p><code>引用</code>是内存垃圾回收算法所依赖的主要概念之一。</p>
<p>在内存管理上下文中，如果对象 A 访问了另一个对象 B 表示 A 引用了对象 B(可以隐式或显式)。举个例子，一个 JavaScript 对象有引用了它的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain">原型</a>(隐式引用)和它的属性值(显式引用)。</p>
<p>在此上下文中，”对象” 的概念被拓展超过了一般的 JavaScript 对象并且包含函数作用域(或者全局词法作用域)。</p>
<blockquote>
<p>词法作用域定义了如何在嵌套函数中解析变量名。即使父函数已经返回，内部的函数仍然会包含父函数的作用域。</p>
</blockquote>
<h2 id="垃圾回收引用计数"><a href="#垃圾回收引用计数" class="headerlink" title="垃圾回收引用计数"></a>垃圾回收引用计数</h2><p>这是最简单的内存垃圾回收算法。当一个对象被 0 引用，会被标记为 “可回收内存垃圾”。</p>
<p>看下如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  o2: &#123;</span><br><span class="line">    x: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个对象。</span></span><br><span class="line"><span class="comment">// 'o1' 引用对象 'o2' 作为其属性。全部都是不可回收的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 'o3' 是第二个引用 'o1' 对象的变量</span></span><br><span class="line"><span class="keyword">var</span> o3 = o1;</span><br><span class="line"></span><br><span class="line">o1 = <span class="number">1</span>; <span class="comment">// 现在，原先在 'o1' 中的对象只有一个单一的引用，以变量 'o3' 来表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用对象的 'o2' 属性。</span></span><br><span class="line"><span class="comment">// 该对象有两个引用：一个是作为属性，另一个是 'o4' 变量</span></span><br><span class="line"><span class="keyword">var</span> o4 = o3.o2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'o1' 对象现在只有 0 引用，它可以被作为内存垃圾回收。</span></span><br><span class="line"><span class="comment">// 然而，其 'o2' 属性仍然被变量 'o4' 所引用，所以它的内存不能够被释放。</span></span><br><span class="line">o3 = <span class="string">'374'</span>;</span><br><span class="line"></span><br><span class="line">o4 = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 'o1' 中的 'o2' 属性现在只有 0 引用了。所以 'o1' 对象可以被回收。</span></span><br></pre></td></tr></table></figure>

<h2 id="循环引用造成的麻烦"><a href="#循环引用造成的麻烦" class="headerlink" title="循环引用造成的麻烦"></a>循环引用造成的麻烦</h2><p>循环引用会造成限制。在以下的示例中，创建了两个互相引用的对象，这样就会造成循环引用。函数调用之后他们将会超出范围，所以，实际上它们是无用且可以释放对他们的引用。然而，引用计数算法会认为由于两个对象都至少互相引用一次，所以他们都不可回收的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o1.p = o2; <span class="comment">// O1 引用 o2</span></span><br><span class="line">  o2.p = o1; <span class="comment">// o2 引用 o1. 这就造成循环引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<p><img src="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_object_cycle.png" class="lazyload" data-srcset="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_object_cycle.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt=""></p>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>为了判断是否需要释放对对象的引用，算法会确定该对象是否可到达。</p>
<p>标记-清除算法包含三个步骤：</p>
<ul>
<li>根：一般来说，根指的是代码中引用的全局变量。就拿 JavaScript 来说，window 对象即是根的全局变量。Node.js 中相对应的变量为 “global”。垃圾回收器会构建出一份所有根变量的完整列表。</li>
<li>随后，算法会检测所有的根变量及他们的后代变量并标记它们为激活状态(表示它们不可回收)。任何根变量所到达不了的变量(或者对象等等)都会被标记为内存垃圾。</li>
<li>最后，垃圾回收器会释放所有非激活状态的内存片段然后返还给操作系统。</li>
</ul>
<p><img src="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_mark&sweep.gif" class="lazyload" data-srcset="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_mark&sweep.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt=""></p>
<p><em>标记-清除算法的动态图示</em></p>
<p>该算法比之前的算法要好，因为对象零引用可以让对象不可获得。反之则不然，正如之前所看到的循环引用。</p>
<p>从 2012 年起，所有的现代浏览器都内置了一个标记－清除垃圾回收器。前些年所有对于 JavaScript 内存垃圾收集(分代/增量/并发/并行 垃圾收集)的优化都是针对标记-清除算法的实现的优化，但既没有提升垃圾收集算法本身，也没有提升判定对象是否可获得的能力。</p>
<p>你可以查看这篇<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">文章 </a>来了解追踪内存垃圾回收的详情及包含优化了的标记-清除算法。</p>
<h2 id="循环引用不再是问题"><a href="#循环引用不再是问题" class="headerlink" title="循环引用不再是问题"></a>循环引用不再是问题</h2><p>在之前的第一个示例中，当函数返回，全局对象不再引用这两个对象。结果，内存垃圾回收器发现它们是不可获得的。</p>
<p><img src="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_cycle_fixed.png" class="lazyload" data-srcset="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/how_javascript_works/3_cycle_fixed.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt=""></p>
<p>即使两个对象互相引用，也不能够从根变量获得他们。</p>
<h2 id="内存垃圾回收器的反直观行为"><a href="#内存垃圾回收器的反直观行为" class="headerlink" title="内存垃圾回收器的反直观行为"></a>内存垃圾回收器的反直观行为</h2><p>虽然内存垃圾回收器很方便，但是它们也有其一系列的代价。其中之一便是不确定性。意思即内存垃圾回收具有不可预见性。你不能确定内存垃圾收集的确切时机。这意味着在某些情况下，程序会使用比实际需要更多的内存。在其它情况下，在特定的交互敏感的程序中，你也许需要注意那些内存垃圾收集短暂停时间。虽然不确定性意味着不能够确定什么时候可以进行内存垃圾收集，但是大多数 GC 的实现都是在内存分配期间进行内存垃圾回收的一般模式。如果没有进行内存分配，大多数的内存垃圾回收就会保持闲置状态。考虑以下情况：</p>
<ul>
<li>执行大量的内存分配。</li>
<li>大多数的元素(或所有)被标记为不可获得(假设我们赋值我们不再需要的缓存为 null )</li>
<li>不再分配其它内存。</li>
</ul>
<p>在该情况下，大多数的内存垃圾回收器不会再运行任何的内存垃圾回收。换句话说，即使可以对该不可获得的引用进行垃圾回收，但是内存收集器不会进行标记。虽然这不是严格意义上的内存泄漏，但是这会导致高于平常的内存使用率。</p>
<h2 id="内存泄漏是什么？"><a href="#内存泄漏是什么？" class="headerlink" title="内存泄漏是什么？"></a>内存泄漏是什么？</h2><p>内存泄漏即一些程序在过去时使用但处于闲置状态，却没有返回给操作系统或者可用内存池。</p>
<p>编程语言喜欢用多种方法管理内存。然而，某个内存片段是否被使用是一个不确定的问题。换句话说，只有开发人员清楚某个内存片段是否可以返回给操作系统。</p>
<p>某些编程语言会为开发者提供功能函数来解决这个问题。其它的编程语言完全依赖于开发者全权掌控哪个内存片段是可回收的。维其百科上有关于<a href="https://en.wikipedia.org/wiki/Manual_memory_management">手动</a>和<a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29">自动</a>内存管理的好文章。</p>
<h2 id="四种常见的-JavaScript-内存泄漏"><a href="#四种常见的-JavaScript-内存泄漏" class="headerlink" title="四种常见的 JavaScript 内存泄漏"></a>四种常见的 JavaScript 内存泄漏</h2><h3 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1: 全局变量"></a>1: 全局变量</h3><p>JavaScript 以一种有趣的方式来处理未声明变量：当引用一个未声明的变量，会在全局对象上创建一个新的变量。在浏览器中，全局对象是 <code>window</code>，这意味着如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  bar = <span class="string">"some text"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等同于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.bar = <span class="string">"some text"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量 <code>bar</code> 本意是只能在 foo 函数中被引用。但是如果你没有用 <code>var</code> 来声明变量，那么将会创建一个多余的全局变量。在上面的例子中，并不会造成大的事故。但你可以很自然地想象一个更具破坏性的场景。</p>
<p>使用 <code>this</code> 关键字也可能在不经意间创建一个全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.var1 = <span class="string">"potential accidental global"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 foo 函数自身，this 会指向全局对象(window)而不是未定义</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>你可以通过在 JavaScript 文件的顶部添加 <code>&#39;use strict&#39;</code> 来避免以上的所有问题，<code>&#39;use strict&#39;</code> 会切换到更加严格的 JavaScript 解析模式，这样就可以防止创建意外的全局变量。</p>
</blockquote>
<p>意外的全局变量的确是个问题，而代码经常会被显式定义的全局变量所污染，根据定义这些全局变量是不会被内存垃圾回收器所收集的。你需要特别注意的是使用全局变量来临时存储和处理大型的位信息。只有在必要的时候使用全局变量来存储数据，记得一旦你不再使用的时候，把它赋值为 null 或者对其再分配。</p>
<h3 id="2：定时器及被遗忘的回调函数"><a href="#2：定时器及被遗忘的回调函数" class="headerlink" title="2：定时器及被遗忘的回调函数"></a>2：定时器及被遗忘的回调函数</h3><p>因为经常在 JavaScript 中使用 <code>setInterval</code>，所以让我们以它为例。</p>
<p>框架中提供了观察者和接受回调的其它指令通常会确保当他们的实例不可获得的时候，所有对回调的引用都会变成不可获得。很容易找到如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverData = loadData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> renderer = <span class="built_in">document</span>.getElementById(<span class="string">'renderer'</span>);</span><br><span class="line">  <span class="keyword">if</span> (renderer) &#123;</span><br><span class="line">    renderer.innerHTML = <span class="built_in">JSON</span>.stringify(serverData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>); <span class="comment">// 这将会每隔大约 5 秒钟执行一次</span></span><br></pre></td></tr></table></figure>

<p>以上代码片段展示了使用定时器来引用不再需要的节点或数据的后果。</p>
<p><code>renderer</code> 对象会在某些时候被替换或移除，这样就会导致由定时处理程序封装的代码变得冗余。当这种情况发生的时候，不管是定时处理程序还是它的依赖都不会被垃圾回收，这是由于需要先停止定时器(记住，定时器仍然处于激活状态)。这可以归结为保存和处理数据加载的 <code>serverData</code> 变量也不会被垃圾回收。</p>
<p>当使用观察者的时候，你需要确保一旦你不再需要它们的时候显式地移除它们(不再需要观察者或者对象变得不可获得)。</p>
<p>幸运的是，大多数现代浏览器都会替你进行处理：当被观察者对象变得不可获得时，即使你忘记移除事件监听函数，浏览器也会自动回收观察者处理程序。以前，一些老掉牙的浏览器处理不了这些情况(如老旧的 IE6)。</p>
<p>那么，最佳实践是当对象被废弃的时候，移除观察者处理程序。查看如下例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'launch-button'</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  element.innerHTML = <span class="string">'text'</span> + counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, onClick);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些操作</span></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>, onClick);</span><br><span class="line">element.parentNode.removeChild(element);</span><br><span class="line"><span class="comment">// 现在当元素超出范围</span></span><br><span class="line"><span class="comment">// 即使在不能很好处理循环引用的浏览器中也会回收元素和 onClick 事件</span></span><br></pre></td></tr></table></figure>

<p>在让一个 DOM 节点不可获得之前，你不再需要调用 <code>removeEventListener</code>，因为现代浏览器支持用内存垃圾回收器来检测并适当地处理 DOM 节点的生命周期。</p>
<p>如果你使用 <code>jQuery</code> API(其它的库和框架也支持的 API)，你可以在废弃节点之前移除事件监听函数。jQuery 也会确保即使在老旧的浏览器之中，也不会产生内存泄漏。</p>
<h3 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3. 闭包"></a>3. 闭包</h3><p>闭包是 JavaScript 的一个重要功能：嵌套函数可以访问外部(封闭)函数的变量。鉴于 JavaScript 运行时的实现细节，以下方法可能会造成内存泄漏：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (originalThing) <span class="comment">// 引用 originalThing</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">    someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>当调用 <code>replaceThing</code> 的时候，<code>theThing</code> 对象由一个大数组和新的闭包(<code>someMethod</code>)所组成。而 <code>originalThing</code> 由 <code>unused</code> 变量创建的闭包所引用(即引用 <code>replaceThing</code> 函数之前的 <code>theThing</code> 变量)。需要记住的是当一旦为同一个父作用域中的闭包创建闭包作用域的时候，该闭包作用域是共享的。</p>
<p>在这样的情况下，闭包 <code>someMethod</code> 和 <code>unused</code> 共享相同的作用域。<code>unused</code> 引用了 <code>origintalThing</code>。即使 <code>unused</code> 永不使用，也可以在 <code>replaceThing</code> 的作用域外使用 <code>someMethod</code> 函数。然后由于 <code>someMethod</code> 和 <code>unused</code> 共享相同的闭包作用域，<code>unused</code> 变量引用 <code>originalThing</code> 会强迫 <code>unused</code> 保持激活状态(两个闭包共享作用域)。这会阻止内存垃圾回收。</p>
<p>在以上例子中，闭包 <code>someMethod</code> 和 <code>unused</code> 共享作用域，而 <code>unused</code> 引用 <code>origintalThing</code>。可以在 <code>replaceThing</code> 作用域外通过 <code>theThing</code> 使用 <code>someMethod</code>，即使 <code>unused</code> 从未被使用。事实上，由于 <code>someMethod</code> 和 <code>unused</code> 共享闭包作用域，unused 引用 <code>origintalThing</code> 要求 unused 保持激活状态。</p>
<p>所有的这些行为会导致内存泄漏。当你不断地运行如上代码片段，你将会发现飙升的内存使用率。当内存垃圾回收器运行的时候，这些内存使用率不会下降。这里会创建出一份闭包链表(当前情况下，其根变量是 <code>theThing</code>)，每个闭包作用域都间接引用了大数组。</p>
<p>该问题是由 Metor 小组发现的并且他们写了一篇很好的<a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156">文章</a>来详细描述该问题。</p>
<h3 id="4-源自-DOM-引用"><a href="#4-源自-DOM-引用" class="headerlink" title="4: 源自 DOM 引用"></a>4: 源自 DOM 引用</h3><p>有时候，开发者会在数据结构中存储 DOM 节点。</p>
<p>假设你想要快速更新几行表格内容。如果你在一个字典或者数组中保存对每个表格行的引用，这将会造成重复引用相同的 DOM 元素：一个在 DOM 树中而另一个在字典中。如果你想要释放对这些表格行的引用，你需要记得让这些引用变成不可获得。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">  button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</span><br><span class="line">  image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  elements.image.src = <span class="string">'http://example.com/image_name.png'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// image 元素是 body 元素的直系后代元素</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'image'</span>));</span><br><span class="line">    <span class="comment">// 这时，我们仍然在 elements 全局对象中引用了 #button 元素</span></span><br><span class="line">    <span class="comment">// 换句话说，按钮元素仍然在内存中且不能够被垃圾回收器收集</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你还需要额外考虑的情况是引用 DOM 树中的内节点或者叶节点。如果你在代码中保存着对一个单元格的引用，这时候当你决定从 DOM 中移除表格，却仍然会保持对该单元格的引用，这就会导致大量的内存泄漏。你可以认为内存垃圾回收器将会释放除了该单元格以外的内存。而这还没完。因为单元格是表格的一个后代元素而后代元素保存着对其父节点的引用，<strong>对一个单元格的引用会导致无法释放整个表格所占用的内存</strong>。</p>
<h1 id="内存管理心得"><a href="#内存管理心得" class="headerlink" title="内存管理心得"></a>内存管理心得</h1><p>以下内容为博主原创分享。By <a href="https://github.com/heaven2049">三月</a>。</p>
<h3 id="指导思想"><a href="#指导思想" class="headerlink" title="指导思想"></a>指导思想</h3><p>尽可能减少内存占用，尽可能减少 GC。</p>
<ul>
<li><p>减少 GC 次数</p>
<p>浏览器会不定时回收垃圾内存，称为 GC，不定时触发，一般在向浏览器申请新内存时，浏览器会检测是否到达一个临界值再进行触发。一般来说，GC 会较为耗时，GC 触发时可能会导致页面卡顿及丢帧。故我们要尽可能避免GC的触发。GC 无法通过代码触发，但部分浏览器如 Chrome，可在 DevTools -&gt; TimeLine 页面手动点击 CollectGarbage 按钮触发 GC。</p>
</li>
<li><p>减少内存占用</p>
<p>降低内存占用，可避免内存占用过多导致的应用/系统卡顿，App 闪退等，在移动端尤为明显。当内存消耗较多时，浏览器可能会频繁触发 GC。而如前所述，GC 发生在申请新内存时，若能避免申请新内存，则可避免GC 触发。</p>
</li>
</ul>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><h4 id="使用对象池"><a href="#使用对象池" class="headerlink" title="使用对象池"></a>使用对象池</h4><blockquote>
<p>对象池<strong>（英语：object pool pattern）是一种<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F">设计模式</a>。</strong>一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。</p>
</blockquote>
<blockquote>
<p>若初始化、实例化的代价高，且有需求需要经常实例化，但每次实例化的数量较少的情况下，使用对象池可以获得显著的效能提升。从池子中取得对象的时间是可预测的，但新建一个实例所需的时间是不确定。</p>
<p>以上摘自维基百科。</p>
</blockquote>
<p>使用对象池技术能显著优化需频繁创建对象时的内存消耗，但建议按不同使用场景做以下细微优化。</p>
<ol>
<li><p>按需创建</p>
<p>默认创建空对象池，按需创建对象，用完归还池子。</p>
</li>
<li><p>预创建对象</p>
<p>如在高频操作下，如滚动事件、TouchMove事件、resize事件、for 循环内部等频繁创建对象，则可能会触发GC的发生。故在特殊情况下，可优化为提前创建对象放入池子。</p>
<p>高频情况下，建议使用<a href="https://rockjins.js.org/2017/02/21/2017-02-21-debounce-function/">截流/防抖</a>及任务队列相关技术。</p>
</li>
<li><p>定时释放</p>
<p>对象池内的对象不会被垃圾回收，若极端情况下创建了大量对象回收进池子却不释放只会适得其反。</p>
<p>故池子需设计定时/定量释放对象机制，如以已用容量/最大容量/池子使用时间等参数来定时释放对象。</p>
</li>
</ol>
<h4 id="其他优化tips"><a href="#其他优化tips" class="headerlink" title="其他优化tips"></a>其他优化tips</h4><ol>
<li><p>尽可能避免创建对象，非必要情况下避免调用会创建对象的方法，如 <code>Array.slice</code>、<code>Array.map</code>、<code>Array.filter</code>、字符串相加、<code>$(&#39;div&#39;)</code>、<code>ArrayBuffer.slice</code> 等。</p>
</li>
<li><p>不再使用的对象，手动赋为 null，可避免循环引用等问题。</p>
</li>
<li><p>使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">Weakmap</a></p>
</li>
<li><p>生产环境勿用 <code>console.log</code> 大对象，包括 DOM、大数组、ImageData、ArrayBuffer 等。因为 <code>console.log</code> 的对象不会被垃圾回收。详见<a href="https://stackoverflow.com/questions/28839652/will-console-log-prevent-garbage-collection">Will console.log prevent garbage collection?</a>。</p>
</li>
<li><p>合理设计页面，按需创建对象/渲染页面/加载图片等。</p>
<ul>
<li><p>避免如下问题：</p>
<ul>
<li>为了省事儿，一次性请求全部数据。</li>
<li>为了省事儿，一次性渲染全部数据，再做隐藏。</li>
<li>为了省事儿，一次性加载/渲染全部图片。</li>
</ul>
</li>
<li><p>使用重复 DOM 等，如重复使用同一个弹窗而非创建多个。</p>
<p>如 Vue-Element 框架中，PopOver/Tooltip 等组件用于表格内时会创建 m * n 个实例，可优化为只创建一个实例，动态设置位置及数据。</p>
</li>
</ul>
</li>
<li><p>ImageData 对象是 JS 内存杀手，避免重复创建 ImageData 对象。</p>
</li>
<li><p>重复使用 ArrayBuffer。</p>
</li>
<li><p>压缩图片、按需加载图片、按需渲染图片，使用恰当的图片尺寸、图片格式，如 WebP 格式。</p>
</li>
</ol>
<h4 id="图片处理优化"><a href="#图片处理优化" class="headerlink" title="图片处理优化"></a>图片处理优化</h4><p>假设渲染一张 100KB 大小，300x500 的透明图片，粗略的可分为三个过程：</p>
<ol>
<li><p>加载图片</p>
<p>加载图片二进制格式到内存中并缓存，此时消耗了100KB 内存 &amp; 100KB 缓存。</p>
</li>
<li><p>解码图片</p>
<p>将二进制格式解码为像素格式，此时占用宽 * 高 * 24（透明为32位）比特大小的内存,即 300 * 500 * 32，约等于 585 KB，这里约定名为像素格式内存。个人猜测此时浏览器会回收加载图片时创建的 100KB 内存。</p>
</li>
<li><p>渲染图片</p>
<p>通过 CPU 或 GPU 渲染图片，若为 GPU 渲染，则还需上传到 GPU 显存，该过程较为耗时，由图片尺寸 / 显存位宽决定，图片尺寸越大，上传时间越慢，占用显存越多。</p>
</li>
</ol>
<blockquote>
<p>其中，较旧的浏览器如Firefox回收像素内存时机较晚，若渲染了大量图片时会内存占用过高。</p>
</blockquote>
<p>PS：浏览器会复用同一份图片二进制内存及像素格式内存，浏览器渲染图片会按以下顺序去获取数据：</p>
<p>显存  &gt;&gt; 像素格式内存 &gt;&gt; 二进制内存 &gt;&gt; 缓存 &gt;&gt; 从服务器获取。我们需控制和优化的是二进制内存及像素内存的大小及回收。</p>
<p>总结一下，浏览器渲染图片时所消耗内存由图片文件大小内存、宽高、透明度等所决定，故建议：</p>
<ol>
<li><p>使用 CSS3、SVG、IconFont、Canvas 替代图片。展示大量图片的页面，建议使用 Canvas 渲染而非直接使用img标签。具体详见 <a href="http://www.voidcn.com/article/p-rrwveyhj-dc.html">Javascript的Image对象、图像渲染与浏览器内存两三事</a>。</p>
</li>
<li><p>适当压缩图片，可减小带宽消耗及图片内存占用。</p>
</li>
<li><p>使用恰当的图片尺寸，即响应式图片，为不同终端输出不同尺寸图片，勿使用原图缩小代替 ICON 等，比如一些图片服务如 OSS。</p>
</li>
<li><p>使用恰当的图片格式，如使用WebP格式等。详细图片格式对比，使用场景等建议查看<a href="http://jixianqianduan.com/frontend-weboptimize/2015/11/17/front-end-image-optmize.html">web前端图片极限优化策略</a>。</p>
</li>
<li><p>按需加载及按需渲染图片。</p>
</li>
<li><p>预加载图片时，切记要将 img 对象赋为 null，否则会导致图片内存无法释放。</p>
<p>当实际渲染图片时，浏览器会从缓存中再次读取。</p>
</li>
<li><p>将离屏 img 对象赋为 null，src 赋为 null，督促浏览器及时回收内存及像素格式内存。</p>
</li>
<li><p>将非可视区域图片移除，需要时再次渲染。和按需渲染结合时实现很简单，切换 src 与 v-src 即可。</p>
</li>
</ol>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="http://buildnewgames.com/garbage-collector-friendly-code/">garbage-collector-friendly-code/</a></p>
<p><a href="https://imququ.com/post/wpo-of-mobile-web-2.html">移动 WEB 通用优化策略介绍（二）</a></p>
<p><a href="https://blog.csdn.net/u011363981/article/details/50481159">H5前端性能优化高级进阶</a></p>
<p><a href="http://www.voidcn.com/article/p-rrwveyhj-dc.html">Javascript的Image对象、图像渲染与浏览器内存两三事</a></p>
<p><a href="http://jixianqianduan.com/frontend-weboptimize/2015/11/17/front-end-image-optmize.html">web前端图片极限优化策略</a></p>
<p><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">MDN Weakmap</a></p>
<p><a href="https://rockjins.js.org/2017/02/21/2017-02-21-debounce-function/">函数节流、函数防抖实现原理分析</a></p>
<p><a href="http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection">a-tour-of-v8-garbage-collection</a></p>
</div><ul class="article-post-copyright"><li>本文于 2021-03-01 发布在 <span>代码</span> 分类下，当前已有<span id="busuanzi_container_page_pv">共 &nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span> 人围观</span></li><li><strong>相关标签 : </strong><a class="link-muted mr-2" rel="tag" href="/tags/How-JavaScript-works/">How JavaScript works</a><span>‚ </span><a class="link-muted mr-2" rel="tag" href="/tags/Javascript/">Javascript</a></li><li><strong>本文链接 : </strong><a href="https://chkaos.top/posts/5ba3987d.html">https://chkaos.top/posts/5ba3987d.html</a></li><li><strong>版权声明 : </strong><span>自由转载-署名-非商业性使用 | <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a></span></li></ul><!--!--></article></div><div class="card donate"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/me/wechat.jpg" class="lazyload" data-srcset="https://chkaos.oss-cn-hangzhou.aliyuncs.com/image/me/wechat.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 is-mobile"><div class="article-nav-prev"><a class="link-muted" href="/posts/efa9d1a1.html"><i class="fas fa-chevron-left"></i><span class="article-nav-title">事件循环及异步编程</span></a></div><div class="article-nav-next"><a class="link-muted" href="/posts/84794ca2.html"><span class="article-nav-title">V8 引擎探索及编写最优代码的5个技巧</span><i class="fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: '1afede2e529c7020cd6c0474ebcbd96f',
            repo: 'blog-comment',
            owner: 'chkaos',
            clientID: 'a6f32bbb1abb8ffc964e',
            clientSecret: '530244c02ace009860b74607dfcb1eb49e57134d',
            admin: ["chkaos"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card left-navbar"><div class="card-content"><div class="left-navbar-menu"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" target="_blank" rel="noopener" title="RSS" href="http://chkaos.top/atom.xml">RSS</a><a class="navbar-item" target="_blank" rel="noopener" title="MIT挑战" href="http://chkaos.top/note/mit/">MIT挑战</a></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#概述"><span>概述</span></a></li><li><a class="is-flex is-mobile" href="#内存生命周期"><span>内存生命周期</span></a></li><li><a class="is-flex is-mobile" href="#内存是什么？"><span>内存是什么？</span></a></li><li><a class="is-flex is-mobile" href="#动态内存分配"><span>动态内存分配</span></a></li><li><a class="is-flex is-mobile" href="#JavaScript-中的内存分配"><span>JavaScript 中的内存分配</span></a></li><li><a class="is-flex is-mobile" href="#JavaScript-中的内存使用"><span>JavaScript 中的内存使用</span></a></li><li><a class="is-flex is-mobile" href="#释放空闲内存"><span>释放空闲内存</span></a></li><li><a class="is-flex is-mobile" href="#垃圾回收"><span>垃圾回收</span></a></li><li><a class="is-flex is-mobile" href="#内存引用"><span>内存引用</span></a></li><li><a class="is-flex is-mobile" href="#垃圾回收引用计数"><span>垃圾回收引用计数</span></a></li><li><a class="is-flex is-mobile" href="#循环引用造成的麻烦"><span>循环引用造成的麻烦</span></a></li><li><a class="is-flex is-mobile" href="#标记-清除算法"><span>标记-清除算法</span></a></li><li><a class="is-flex is-mobile" href="#循环引用不再是问题"><span>循环引用不再是问题</span></a></li><li><a class="is-flex is-mobile" href="#内存垃圾回收器的反直观行为"><span>内存垃圾回收器的反直观行为</span></a></li><li><a class="is-flex is-mobile" href="#内存泄漏是什么？"><span>内存泄漏是什么？</span></a></li><li><a class="is-flex is-mobile" href="#四种常见的-JavaScript-内存泄漏"><span>四种常见的 JavaScript 内存泄漏</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1-全局变量"><span>1: 全局变量</span></a></li><li><a class="is-flex is-mobile" href="#2：定时器及被遗忘的回调函数"><span>2：定时器及被遗忘的回调函数</span></a></li><li><a class="is-flex is-mobile" href="#3-闭包"><span>3. 闭包</span></a></li><li><a class="is-flex is-mobile" href="#4-源自-DOM-引用"><span>4: 源自 DOM 引用</span></a></li></ul></li></ul><li><a class="is-flex is-mobile" href="#内存管理心得"><span>内存管理心得</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#指导思想"><span>指导思想</span></a></li><li><a class="is-flex is-mobile" href="#图片处理优化"><span>图片处理优化</span></a></li><li><a class="is-flex is-mobile" href="#参考链接："><span>参考链接：</span></a></li></ul></ul></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/%E4%BB%A3%E7%A0%81/"><span class="level-start"><span class="level-item categoty-title">代码</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item categoty-title">工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%80%9D%E8%80%83/"><span class="level-start"><span class="level-item categoty-title">思考</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%B8%B8%E6%88%8F/"><span class="level-start"><span class="level-item categoty-title">游戏</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%81%8C%E4%B8%9A/"><span class="level-start"><span class="level-item categoty-title">职业</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p><time dateTime="2021-08-15T07:35:41.000Z">2021-08-15</time></p><p class="title is-6"><a class="link-muted media-title" href="/posts/df33f624.html">创建型/结构型/行为型设计模式及 4 种最佳实践</a></p></div></article><article class="media"><div class="media-content"><p><time dateTime="2021-07-26T16:15:39.000Z">2021-07-27</time></p><p class="title is-6"><a class="link-muted media-title" href="/posts/92b02c59.html">Deno 简介</a></p></div></article><article class="media"><div class="media-content"><p><time dateTime="2021-06-27T14:31:00.000Z">2021-06-27</time></p><p class="title is-6"><a class="link-muted media-title" href="/posts/c6a7ef4.html">KK 给年轻人的一些人生建议</a></p></div></article><article class="media"><div class="media-content"><p><time dateTime="2021-06-23T04:10:00.000Z">2021-06-23</time></p><p class="title is-6"><a class="link-muted media-title" href="/posts/5e24e4b2.html">So long, gay 骆驼</a></p></div></article><article class="media"><div class="media-content"><p><time dateTime="2021-06-16T11:10:00.000Z">2021-06-16</time></p><p class="title is-6"><a class="link-muted media-title" href="/posts/b1ca8d55.html">谷歌学术使用指南</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2021/08/"><span class="level-start"><span class="level-item archive-title">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/07/"><span class="level-start"><span class="level-item archive-title">七月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/06/"><span class="level-start"><span class="level-item archive-title">六月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/05/"><span class="level-start"><span class="level-item archive-title">五月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/04/"><span class="level-start"><span class="level-item archive-title">四月 2021</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部 &gt;</span></span></a></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline tag-container"><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag tag-name">CSS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Class/"><span class="tag tag-name">Class</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Deno/"><span class="tag tag-name">Deno</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Google-Chrome-V8/"><span class="tag tag-name">Google Chrome V8</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Google-Scholar/"><span class="tag tag-name">Google Scholar</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag tag-name">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/How-JavaScript-works/"><span class="tag tag-name">How JavaScript works</span><span class="tag">28</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag tag-name">Javascript</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MIT%E6%8C%91%E6%88%98/"><span class="tag tag-name">MIT挑战</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MutationObserver/"><span class="tag tag-name">MutationObserver</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag tag-name">React</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-Diff/"><span class="tag tag-name">React Diff</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Service-Workers/"><span class="tag tag-name">Service Workers</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shadow-DOM/"><span class="tag tag-name">Shadow DOM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Theia/"><span class="tag tag-name">Theia</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VS-Code/"><span class="tag tag-name">VS Code</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web-Workers/"><span class="tag tag-name">Web Workers</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WebAssembly/"><span class="tag tag-name">WebAssembly</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WebRTC/"><span class="tag tag-name">WebRTC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%87%AF%E6%96%87%C2%B7%E5%87%AF%E5%88%A9/"><span class="tag tag-name">凯文·凯利</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"><span class="tag tag-name">函数式编程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E7%94%BB/"><span class="tag tag-name">动画</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"><span class="tag tag-name">同源策略</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"><span class="tag tag-name">密码学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%AB%E5%B8%88%E4%B8%89/"><span class="tag tag-name">巫师三</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BB%BA%E7%AB%99%E5%B0%8F%E8%AE%B0/"><span class="tag tag-name">建站小记</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"><span class="tag tag-name">异常处理</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag tag-name">排序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"><span class="tag tag-name">浏览器</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"><span class="tag tag-name">浏览器缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"><span class="tag tag-name">渲染引擎</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B8%B8%E6%88%8F/"><span class="tag tag-name">游戏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag tag-name">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><span class="tag tag-name">编译原理</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tag tag-name">网络</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E9%A1%B5%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"><span class="tag tag-name">网页消息推送</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"><span class="tag tag-name">职业发展</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0/"><span class="tag tag-name">自定义元素</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"><span class="tag tag-name">计算机科学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag tag-name">设计模式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"><span class="tag tag-name">跨站脚本攻击</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag tag-name">面试</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><meting-js server="netease" type="playlist" id="2683835425" theme="#3273dc" loop="all" fixed="true" mini="true" autoplay="true" order="list" storageName="aplayer-setting" list-folded="true" lrctype="0" list-max-height="300px"></meting-js><footer class="footer"><div class="container"><div class="level"><p class="size-small"><span>&copy; 2021 Chkaos Find the calm in chaos</span><span> | </span><span>Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></span></p><p class="size-small"><span id="statistic-times">loading...</span><script>function createTime(time) {
      var n = new Date(time);
      now.setTime(now.getTime() + 250),
          days = (now - n) / 1e3 / 60 / 60 / 24,
          dnum = Math.floor(days),
          hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
          hnum = Math.floor(hours),
      1 == String(hnum).length && (hnum = "0" + hnum),
          minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
          mnum = Math.floor(minutes),
      1 == String(mnum).length && (mnum = "0" + mnum),
          seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
          snum = Math.round(seconds),
      1 == String(snum).length && (snum = "0" + snum),
          document.getElementById("statistic-times").innerHTML = "本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒";
  }var now = new Date();setInterval("createTime('2020/07/11 00:00:00')", 250,"");</script><br></p><p class="size-small"><span id="busuanzi_container_site_uv">共 <span id="busuanzi_value_site_uv">0</span> 人围观</span></p><p class="size-small"><a href="http://chkaos.gitee.io/">备用网址</a></p></div></div></footer><script src="/js/lazyload.js"></script><script src="/js/utils.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://chkaos.top',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
            $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
        
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            lazyLoadImg();
        });</script><script src="/js/toc.js" defer></script><script type="text/javascript" src="/js/theme.js"></script><script type="text/javascript" src="/js/egg.js"></script><script src="/js/main.js" defer></script><script src="/js/music.js"></script><script src="/js/copyright.js"></script><script src="/js/instant.page.js" type="module" integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>